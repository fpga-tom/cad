
trx.elf:     file format elf32-littlenios2
trx.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x20008190

Program Header:
    LOAD off    0x00001000 vaddr 0x20008000 paddr 0x20008000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x20008020 paddr 0x20008020 align 2**12
         filesz 0x00006810 memsz 0x00006810 flags r-x
    LOAD off    0x00008000 vaddr 0x00000000 paddr 0x2000e830 align 2**12
         filesz 0x000005ac memsz 0x00007954 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  20008000  20008000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000170  20008020  20008020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000066a0  20008190  20008190  00001190  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000001bc  00000000  2000e830  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000003f0  000001bc  2000e9ec  000081bc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000073a8  000005ac  2000eddc  000085ac  2**2
                  ALLOC, SMALL_DATA
  6 .mem_if_lpddr2_emif_0 00000000  00007954  00007954  000085ac  2**0
                  CONTENTS
  7 .onchip_mem   00000000  2000eddc  2000eddc  000085ac  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  000085ac  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000898  00000000  00000000  000085d0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0001495f  00000000  00000000  00008e68  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00005a83  00000000  00000000  0001d7c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00005f83  00000000  00000000  0002324a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00001850  00000000  00000000  000291d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000359a  00000000  00000000  0002aa20  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00007e1f  00000000  00000000  0002dfba  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000020  00000000  00000000  00035ddc  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000488  00000000  00000000  00035e00  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00039ca7  2**0
                  CONTENTS, READONLY
 19 .cpu          00000003  00000000  00000000  00039cad  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00039cb0  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00039cb1  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00039cb2  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00039cb6  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00039cba  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   00000009  00000000  00000000  00039cbe  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    00000009  00000000  00000000  00039cc7  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   00000009  00000000  00000000  00039cd0  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000006  00000000  00000000  00039cd9  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000014  00000000  00000000  00039cdf  2**0
                  CONTENTS, READONLY
 30 .jdi          00007537  00000000  00000000  00039cf3  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     000f3ed1  00000000  00000000  0004122a  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
20008000 l    d  .entry	00000000 .entry
20008020 l    d  .exceptions	00000000 .exceptions
20008190 l    d  .text	00000000 .text
00000000 l    d  .rodata	00000000 .rodata
000001bc l    d  .rwdata	00000000 .rwdata
000005ac l    d  .bss	00000000 .bss
00007954 l    d  .mem_if_lpddr2_emif_0	00000000 .mem_if_lpddr2_emif_0
2000eddc l    d  .onchip_mem	00000000 .onchip_mem
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../trx_bsp//obj/HAL/src/crt0.o
200081c8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_ucosii.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
20008420 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
000001bc l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
20008af8 l     F .text	0000006c udivmodsi4
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
20008dc4 l     F .text	00000020 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
00000504 l     O .rwdata	00000004 lockid
000005bc l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000508 l     O .rwdata	00000004 lockid
000005c4 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
20009014 l     F .text	0000003c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
2000a0b4 l     F .text	0000009c OS_FlagBlock
2000a5d4 l     F .text	00000090 OS_FlagTaskRdy
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000328 l     O .rwdata	0000002c jtag_uart
000002f8 l     O .rwdata	00000030 sgdma_0
000002c8 l     O .rwdata	00000030 sgdma_1
0000029c l     O .rwdata	0000002c uart
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
2000d254 l     F .text	0000005c alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
2000d828 l     F .text	0000003c alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
00000000 l    df *ABS*	00000000 alt_close.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
2000dac4 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
2000dd58 l     F .text	00000078 alt_open_fd.constprop.0
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
0000062c g     O .bss	00000004 alt_instruction_exception_handler
00000532 g     O .rwdata	00000002 OSTaskNameSize
20008d1c g     F .text	000000a8 alt_main
20008370 g     F .text	00000080 _puts_r
00007854 g     O .bss	00000100 alt_irq
2000af48 g     F .text	0000007c OS_MemInit
2000e9ec g       *ABS*	00000000 __flash_rwdata_start
2000d0d8 g     F .text	00000024 OSTimeSet
200098c8 g     F .text	00000338 OSEventPendMulti
2000e288 g     F .text	00000004 OSTaskCreateHook
00000630 g     O .bss	00002000 task1_stk
20008324 g     F .text	0000004c printf
0000055a g     O .rwdata	00000002 OSMboxEn
2000d32c g     F .text	00000080 alt_avalon_sgdma_do_sync_transfer
20009084 g     F .text	0000003c OSIntEnter
0000054a g     O .rwdata	00000002 OSQEn
20008fc0 g     F .text	00000054 __malloc_unlock
2000e294 g     F .text	00000004 OSTaskStatHook
000005cc g     O .bss	00000001 OSLockNesting
0000050c g     O .rwdata	00000002 OSDataSize
000005cd g     O .bss	00000001 OSRunning
2000d4c4 g     F .text	00000114 alt_avalon_sgdma_construct_descriptor_burst
2000e29c g     F .text	00000004 OSInitHookBegin
00000514 g     O .rwdata	00000002 OSTmrSize
000005d0 g     O .bss	00000004 OSIdleCtr
2000e0d8 g     F .text	00000008 altera_nios2_gen2_irq_init
2000e18c g       .text	00000000 OSStartTsk
00000000  w      *UND*	00000000 __errno
20009f38 g     F .text	00000178 OS_TCBInit
20008000 g     F .entry	0000001c __reset
0000050e g     O .rwdata	00000002 OSTmrWheelTblSize
2000d658 g     F .text	0000004c alt_avalon_sgdma_construct_stream_to_mem_desc_burst
20008020 g       *ABS*	00000000 __flash_exceptions_start
0000056e g     O .rwdata	00000002 OSEventSize
000005d4 g     O .bss	00000001 OSPrioHighRdy
2000e28c g     F .text	00000004 OSTaskDelHook
000005ac g     O .bss	00000004 errno
2000e16c g       .text	00000000 OSStartHighRdy
2000ccac g     F .text	0000017c OSTaskCreateExt
2000a498 g     F .text	00000028 OSFlagPendGetFlagsRdy
0000052e g     O .rwdata	00000002 OSTaskStatStkSize
2000a150 g     F .text	00000138 OSFlagAccept
2000b2ec g     F .text	00000050 OSQFlush
2000afc4 g     F .text	00000094 OSQAccept
000005b4 g     O .bss	00000004 alt_argv
000084fc g       *ABS*	00000000 _gp
2000c228 g     F .text	00000118 OSTaskCreate
2000bfb8 g     F .text	00000270 OSTaskChangePrio
000005c8 g     O .bss	00000004 alt_heapsem
2000a0b0 g     F .text	00000004 OSDebugInit
2000c340 g     F .text	00000260 OSTaskDel
00000354 g     O .rwdata	00000180 alt_fd_list
00004630 g     O .bss	00000370 OSFlagTbl
20009464 g     F .text	0000003c OS_EventTaskRemove
2000dbd4 g     F .text	00000074 alt_find_dev
00000544 g     O .rwdata	00000002 OSRdyTblSize
2000ddd0 g     F .text	00000078 alt_io_redirect
2000e830 g       *ABS*	00000000 __DTOR_END__
200083f0 g     F .text	00000014 puts
2000e42c g     F .text	00000074 alt_exception_cause_generated_bad_addr
20009c7c g     F .text	000000a8 OSEventNameGet
00000000 g       *ABS*	00000000 __alt_mem_mem_if_lpddr2_emif_0
00000560 g     O .rwdata	00000002 OSFlagMax
200090c0 g     F .text	000000a8 OSIntExit
00000526 g     O .rwdata	00000002 OSTCBSize
2000d6cc g     F .text	00000050 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
000005d5 g     O .bss	00000001 OSPrioCur
2000d1c4 g     F .text	0000005c altera_avalon_jtag_uart_read
00000000  w      *UND*	00000000 malloc
200082e8 g     F .text	0000003c _printf_r
20008c14 g     F .text	00000008 .hidden __udivsi3
00000540 g     O .rwdata	00000002 OSStkWidth
0000054c g     O .rwdata	00000002 OSPtrSize
0000056c g     O .rwdata	00000002 OSEventTblSize
2000e0e0 g       .text	00000000 OSCtxSw
2000e3f4 g     F .text	00000038 alt_icache_flush
000005d8 g     O .bss	00000004 OSTCBList
0000061c g     O .bss	00000004 alt_fd_list_lock
2000d3d4 g     F .text	0000001c alt_avalon_sgdma_stop
000049a0 g     O .bss	00000c30 OSMemTbl
000005dc g     O .bss	00000001 OSTickStepState
00000548 g     O .rwdata	00000002 OSQMax
000055d0 g     O .bss	00000800 OSTaskStatStk
2000ad34 g     F .text	00000090 OSMemNameGet
00000568 g     O .rwdata	00000002 OSFlagEn
00000522 g     O .rwdata	00000002 OSTimeTickHookEn
2000dabc g     F .text	00000004 alt_dcache_flush
2000b5b0 g     F .text	000000cc OSQPost
2000a59c g     F .text	00000038 OS_FlagUnlink
00000588 g     O .rwdata	00000004 alt_max_fd
20009818 g     F .text	00000028 OS_MemCopy
20009840 g     F .text	00000088 OS_Sched
2000acd8 g     F .text	0000005c OSMemGet
2000c748 g     F .text	00000110 OSTaskNameSet
000005e0 g     O .bss	00000004 OSCtxSwCtr
2000e298 g     F .text	00000004 OSTimeTickHook
0000055e g     O .rwdata	00000002 OSFlagNameSize
200094a0 g     F .text	00000050 OS_EventTaskRemoveMulti
200093e8 g     F .text	0000007c OS_EventTaskWaitMulti
00000546 g     O .rwdata	00000002 OSQSize
2000bbf4 g     F .text	00000150 OSSemPend
000004fc g     O .rwdata	00000004 _global_impure_ptr
0000055c g     O .rwdata	00000002 OSLowestPrio
00007954 g       *ABS*	00000000 __bss_end
2000dcf0 g     F .text	00000068 alt_iic_isr_register
2000d2b0 g     F .text	0000007c alt_avalon_sgdma_do_async_transfer
2000e2a8 g     F .text	00000004 OSTCBInitHook
00000516 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
2000e020 g     F .text	000000b8 alt_tick
00000574 g     O .rwdata	00000002 OSEventEn
0000051a g     O .rwdata	00000002 OSTmrCfgNameSize
2000dcd8 g     F .text	00000018 alt_ic_irq_enabled
2000a510 g     F .text	0000008c OS_FlagInit
2000dfec g     F .text	00000034 alt_alarm_stop
00000538 g     O .rwdata	00000002 OSTaskIdleStkSize
00000620 g     O .bss	00000004 alt_irq_active
2000b9ac g     F .text	00000044 OSSemAccept
2000ae84 g     F .text	00000060 OSMemPut
2000ac14 g     F .text	000000c4 OSMemCreate
000005e4 g     O .bss	00000004 OSIdleCtrMax
20008000 g       *ABS*	00000000 __alt_mem_onchip_mem
200080fc g     F .exceptions	00000068 alt_irq_handler
000004d4 g     O .rwdata	00000028 alt_dev_null
00000524 g     O .rwdata	00000002 OSTicksPerSec
2000d3f0 g     F .text	0000002c alt_avalon_sgdma_check_descriptor_status
2000e0e0 g       .text	00000000 OSIntCtxSw
2000dac0 g     F .text	00000004 alt_dcache_flush_all
000005e8 g     O .bss	00000004 OSTCBFreeList
000005ac g       *ABS*	00000000 __ram_rwdata_end
2000bd44 g     F .text	000000ec OSSemPendAbort
0000058c g     O .rwdata	00000008 alt_dev_list
20008de4 g     F .text	00000088 write
2000d474 g     F .text	00000030 alt_avalon_sgdma_enable_desc_poll
00000520 g     O .rwdata	00000002 OSVersionNbr
000001bc g       *ABS*	00000000 __ram_rodata_end
00000578 g     O .rwdata	00000004 OSEndiannessTest
20008c1c g     F .text	00000008 .hidden __umodsi3
2000d71c g     F .text	00000040 alt_avalon_sgdma_construct_mem_to_stream_desc
00000566 g     O .rwdata	00000002 OSFlagGrpSize
2000d3ac g     F .text	00000010 alt_avalon_sgdma_register_callback
00007954 g       *ABS*	00000000 end
2000d968 g     F .text	00000090 altera_avalon_uart_write
20009eac g     F .text	0000008c OS_TaskStat
20008164 g     F .exceptions	0000002c alt_instruction_exception_entry
2000e830 g       *ABS*	00000000 __CTOR_LIST__
20000000 g       *ABS*	00000000 __alt_stack_pointer
2000d4a4 g     F .text	00000020 alt_avalon_sgdma_disable_desc_poll
2000d864 g     F .text	00000050 alt_avalon_timer_sc_init
2000d8c8 g     F .text	00000014 altera_avalon_uart_write_fd
2000d220 g     F .text	00000034 altera_avalon_jtag_uart_write
2000d620 g     F .text	00000038 alt_avalon_sgdma_construct_mem_to_mem_desc
200095f0 g     F .text	0000001c OS_MemClr
2000848c g     F .text	00000544 ___vfprintf_internal_r
2000e1b0 g     F .text	000000d8 OSTaskStkInit
200081cc g     F .text	00000044 task1
2000d6a4 g     F .text	00000028 alt_avalon_sgdma_construct_stream_to_mem_desc
200094f0 g     F .text	000000ec OS_EventTaskRdy
2000e674 g     F .text	0000019c __call_exitprocs
000005ec g     O .bss	00000001 OSCPUUsage
20008190 g     F .text	0000003c _start
20008210 g     F .text	00000044 task2
00000628 g     O .bss	00000004 _alt_tick_rate
2000b33c g     F .text	0000018c OSQPend
2000d41c g     F .text	00000058 alt_avalon_sgdma_open
2000ce28 g     F .text	0000008c OSTimeDly
00000624 g     O .bss	00000004 _alt_nticks
2000d11c g     F .text	00000080 alt_sys_init
2000e524 g     F .text	00000150 __register_exitproc
000005ed g     O .bss	00000001 OSTaskCtr
2000ceb4 g     F .text	000000f8 OSTimeDlyHMSM
000001bc g       *ABS*	00000000 __ram_rwdata_start
00000000 g       *ABS*	00000000 __ram_rodata_start
00000572 g     O .rwdata	00000002 OSEventMax
2000be30 g     F .text	000000a8 OSSemPost
20009c00 g     F .text	00000050 OSSchedUnlock
2000d19c g     F .text	00000014 altera_avalon_jtag_uart_read_fd
2000e358 g     F .text	0000009c alt_get_fd
000005f0 g     O .bss	00000004 OSMemFreeList
200091fc g     F .text	00000064 OSStatInit
2000a4c0 g     F .text	00000050 OSFlagQuery
0000053c g     O .rwdata	00000002 OSTaskCreateExtEn
2000e4d4 g     F .text	00000030 memcmp
20009374 g     F .text	00000004 OS_Dummy
00007954 g       *ABS*	00000000 __alt_stack_base
00005dd0 g     O .bss	000001e0 OSQTbl
000005f4 g     O .bss	00000004 OSTCBHighRdy
000005f8 g     O .bss	00000004 OSQFreeList
2000e2ac g     F .text	000000ac alt_find_file
2000dacc g     F .text	00000078 alt_dev_llist_insert
20008f14 g     F .text	000000ac __malloc_lock
2000d3bc g     F .text	00000018 alt_avalon_sgdma_start
20009d40 g     F .text	000000d0 OSEventNameSet
000005fc g     O .bss	00000001 OSRdyGrp
200089f4 g     F .text	000000ac __sfvwrite_small_dev
000005ac g       *ABS*	00000000 __bss_start
2000e504 g     F .text	00000020 memset
20008254 g     F .text	00000094 main
000005b0 g     O .bss	00000004 alt_envp
2000d1b0 g     F .text	00000014 altera_avalon_jtag_uart_write_fd
0000007e g     O .rodata	00000100 OSUnMapTbl
00000580 g     O .rwdata	00000008 alt_sgdma_list
00000542 g     O .rwdata	00000002 OSSemEn
2000a7d4 g     F .text	000001ac OSFlagPost
20009378 g     F .text	00000070 OS_EventTaskWait
00002630 g     O .bss	00002000 task2_stk
20009e10 g     F .text	0000009c OS_TaskStatStkChk
2000c5a0 g     F .text	000000b4 OSTaskDelReq
0000059c g     O .rwdata	00000004 alt_errno
200091ac g     F .text	00000050 OSStart
20008eec g     F .text	00000028 __env_unlock
2000c858 g     F .text	0000011c OSTaskResume
2000aee4 g     F .text	00000064 OSMemQuery
00000530 g     O .rwdata	00000002 OSTaskStatEn
00000556 g     O .rwdata	00000002 OSMemMax
2000b67c g     F .text	000000cc OSQPostFront
20008b64 g     F .text	00000054 .hidden __divsi3
000005fd g     O .bss	00000003 OSRdyTbl
0000057c g     O .rwdata	00000002 OSDebugEn
2000e830 g       *ABS*	00000000 __CTOR_END__
00000564 g     O .rwdata	00000002 OSFlagNodeSize
0000051c g     O .rwdata	00000002 OSTmrCfgMax
2000b058 g     F .text	000000f4 OSQCreate
2000c654 g     F .text	000000f4 OSTaskNameGet
2000e830 g       *ABS*	00000000 __flash_rodata_start
2000b748 g     F .text	00000158 OSQPostOpt
20009260 g     F .text	0000010c OSTimeTick
00000534 g     O .rwdata	00000002 OSTaskMax
2000e830 g       *ABS*	00000000 __DTOR_LIST__
2000b9f0 g     F .text	00000094 OSSemCreate
00000510 g     O .rwdata	00000002 OSTmrWheelSize
0000053a g     O .rwdata	00000002 OSTaskDelEn
2000bed8 g     F .text	0000007c OSSemQuery
2000b14c g     F .text	000001a0 OSQDel
2000b4c8 g     F .text	000000e8 OSQPendAbort
2000d0fc g     F .text	00000020 alt_irq_init
2000dfc8 g     F .text	00000024 alt_release_fd
2000e4a0 g     F .text	00000014 atexit
20008aa0 g     F .text	00000058 _write_r
20009168 g     F .text	00000044 OSSchedLock
2000a288 g     F .text	00000080 OSFlagCreate
00000500 g     O .rwdata	00000004 _impure_ptr
000005b8 g     O .bss	00000004 alt_argc
2000db8c g     F .text	00000048 _do_dtors
0000056a g     O .rwdata	00000002 OSEventMultiEn
2000a664 g     F .text	00000170 OSFlagDel
00000600 g     O .bss	00000004 OSEventFreeList
20008020 g       .exceptions	00000000 alt_irq_entry
2000a980 g     F .text	00000294 OSFlagPend
0000051e g     O .rwdata	00000002 OSTmrEn
00000594 g     O .rwdata	00000008 alt_fs_list
20009c50 g     F .text	0000002c OS_StrCopy
00000554 g     O .rwdata	00000002 OSMemNameSize
2000e2a0 g     F .text	00000004 OSInitHookEnd
20008020 g       *ABS*	00000000 __ram_exceptions_start
00000528 g     O .rwdata	00000002 OSTCBPrioTblMax
0000052c g     O .rwdata	00000002 OSTaskStatStkChkEn
2000dc54 g     F .text	00000004 alt_ic_isr_register
00000558 g     O .rwdata	00000002 OSMemEn
0000054e g     O .rwdata	00000002 OSMutexEn
000005ac g       *ABS*	00000000 _edata
2000d8b4 g     F .text	00000014 altera_avalon_uart_read_fd
00007954 g       *ABS*	00000000 _end
00000604 g     O .bss	00000001 OSIntNesting
20008190 g       *ABS*	00000000 __ram_exceptions_end
2000cfac g     F .text	00000108 OSTimeDlyResume
2000a3bc g     F .text	000000dc OSFlagNameSet
2000c974 g     F .text	00000108 OSTaskStkChk
2000dc98 g     F .text	00000040 alt_ic_irq_disable
00000552 g     O .rwdata	00000002 OSMemSize
2000d75c g     F .text	00000048 alt_avalon_sgdma_construct_descriptor
00000608 g     O .bss	00000004 OSTCBCur
2000e4b4 g     F .text	00000020 exit
00000550 g     O .rwdata	00000002 OSMemTblSize
20008bb8 g     F .text	0000005c .hidden __modsi3
20000000 g       *ABS*	00000000 __alt_data_end
20008020 g     F .exceptions	00000000 alt_exception
2000960c g     F .text	0000020c OSInit
2000cbac g     F .text	000000dc OSTaskQuery
2000b948 g     F .text	00000064 OS_QInit
20009d24 g     F .text	0000001c OS_StrLen
2000adc4 g     F .text	000000c0 OSMemNameSet
00000536 g     O .rwdata	00000002 OSTaskProfileEn
0000060c g     O .bss	00000004 OSTime
00005fb0 g     O .bss	00000800 OSTaskIdleStk
2000e810 g     F .text	00000020 _exit
2000a308 g     F .text	000000b4 OSFlagNameGet
2000d0b4 g     F .text	00000024 OSTimeGet
20008404 g     F .text	0000001c strlen
2000e290 g     F .text	00000004 OSTaskSwHook
2000de48 g     F .text	00000180 open
000067b0 g     O .bss	00000b40 OSEventTbl
000072f0 g     O .bss	00000510 OSTCBTbl
2000bf54 g     F .text	00000064 OSSemSet
2000dc48 g     F .text	0000000c alt_icache_flush_all
000005a0 g     O .rwdata	00000004 alt_priority_mask
2000ba84 g     F .text	00000170 OSSemDel
00000610 g     O .bss	00000004 OSFlagFreeList
2000dc58 g     F .text	00000040 alt_ic_irq_enable
00000570 g     O .rwdata	00000002 OSEventNameSize
200089d0 g     F .text	00000024 __vfprintf_internal
00000614 g     O .bss	00000001 OSStatRdy
00007800 g     O .bss	00000054 OSTCBPrioTbl
2000d8dc g     F .text	0000008c altera_avalon_uart_read
20008e6c g     F .text	00000080 __env_lock
0000052a g     O .rwdata	00000002 OSTaskSwHookEn
2000d5d8 g     F .text	00000048 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
000005a4 g     O .rwdata	00000008 alt_alarm_list
00000562 g     O .rwdata	00000002 OSFlagWidth
2000db44 g     F .text	00000048 _do_ctors
2000d9f8 g     F .text	000000c4 close
000005c0 g     O .bss	00000004 alt_envsem
00000618 g     O .bss	00000004 OSIdleCtrRun
2000936c g     F .text	00000008 OSVersion
00000518 g     O .rwdata	00000002 OSTmrCfgWheelSize
20008c24 g     F .text	000000f8 alt_load
2000cc88 g     F .text	00000024 OS_TaskStkClr
0000053e g     O .rwdata	00000002 OSTaskCreateEn
200095dc g     F .text	00000014 OS_EventWaitListInit
2000d7a4 g     F .text	00000084 alt_avalon_sgdma_init
2000e2a4 g     F .text	00000004 OSTaskIdleHook
00000000  w      *UND*	00000000 free
2000ca7c g     F .text	00000130 OSTaskSuspend
20009050 g     F .text	00000034 OS_TaskIdle
00000512 g     O .rwdata	00000002 OSTmrTblSize
2000b8a0 g     F .text	000000a8 OSQQuery



Disassembly of section .entry:

20008000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
20008000:	00820014 	movui	r2,2048
#endif

0:
    initi r2
20008004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
20008008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
2000800c:	00bffd16 	blt	zero,r2,20008004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
20008010:	00480034 	movhi	at,8192
    ori r1, r1, %lo(_start)
20008014:	08606414 	ori	at,at,33168
    jmp r1
20008018:	0800683a 	jmp	at
2000801c:	00000000 	call	20000000 <__alt_data_end>

Disassembly of section .exceptions:

20008020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
20008020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
20008024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
20008028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
2000802c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
20008030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
20008034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
20008038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
2000803c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
20008040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
20008044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
20008048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
2000804c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
20008050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
20008054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
20008058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
2000805c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
20008060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
20008064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
20008068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
2000806c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
20008070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
20008074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
20008078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
2000807c:	10000326 	beq	r2,zero,2000808c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
20008080:	20000226 	beq	r4,zero,2000808c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
20008084:	00080fc0 	call	200080fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
20008088:	00000706 	br	200080a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
2000808c:	df401215 	stw	ea,72(sp)
        ldhu.n  r2, 0(r4)
        ldhu.n  r3, 2(r4)
        slli.n  r3, r3, 16
        or.n    r2, r2, r3 /* Instruction that caused exception */
#else
        ldw   r2, -4(ea)   /* Instruction that caused exception */
20008090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
20008094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
20008098:	00081640 	call	20008164 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
2000809c:	1000021e 	bne	r2,zero,200080a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
200080a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
200080a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
200080a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
200080ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
200080b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
200080b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
200080b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
200080bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
200080c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
200080c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
200080c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
200080cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
200080d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
200080d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
200080d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
200080dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
200080e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
200080e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
200080e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
200080ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
200080f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
200080f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
200080f8:	ef80083a 	eret

200080fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
200080fc:	defffe04 	addi	sp,sp,-8
20008100:	dfc00115 	stw	ra,4(sp)
20008104:	dc000015 	stw	r16,0(sp)
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
20008108:	00090840 	call	20009084 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
2000810c:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
20008110:	04000034 	movhi	r16,0
20008114:	841e1504 	addi	r16,r16,30804

  active = alt_irq_pending ();

  do
  {
    i = 0;
20008118:	0005883a 	mov	r2,zero
    mask = 1;
2000811c:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
20008120:	190a703a 	and	r5,r3,r4
20008124:	28000c26 	beq	r5,zero,20008158 <alt_irq_handler+0x5c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
20008128:	100490fa 	slli	r2,r2,3
2000812c:	8087883a 	add	r3,r16,r2
20008130:	1805883a 	mov	r2,r3
20008134:	11000117 	ldw	r4,4(r2)
20008138:	18c00017 	ldw	r3,0(r3)
2000813c:	183ee83a 	callr	r3
20008140:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
20008144:	203ff41e 	bne	r4,zero,20008118 <alt_irq_handler+0x1c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
20008148:	dfc00117 	ldw	ra,4(sp)
2000814c:	dc000017 	ldw	r16,0(sp)
20008150:	dec00204 	addi	sp,sp,8

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
20008154:	00090c01 	jmpi	200090c0 <OSIntExit>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
20008158:	18c7883a 	add	r3,r3,r3
      i++;
2000815c:	10800044 	addi	r2,r2,1

    } while (1);
20008160:	003fef06 	br	20008120 <alt_irq_handler+0x24>

20008164 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
20008164:	200b883a 	mov	r5,r4
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
20008168:	000531fa 	rdctl	r2,exception
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
2000816c:	000d333a 	rdctl	r6,badaddr
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
20008170:	d0e04c17 	ldw	r3,-32464(gp)
20008174:	18000326 	beq	r3,zero,20008184 <alt_instruction_exception_entry+0x20>
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
20008178:	11001f0c 	andi	r4,r2,124
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
2000817c:	2008d0ba 	srli	r4,r4,2
20008180:	1800683a 	jmp	r3
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
20008184:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
20008188:	0005883a 	mov	r2,zero
2000818c:	f800283a 	ret

Disassembly of section .text:

20008190 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
20008190:	06c80034 	movhi	sp,8192
    ori sp, sp, %lo(__alt_stack_pointer)
20008194:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
20008198:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
2000819c:	d6a13f14 	ori	gp,gp,34044
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
200081a0:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
200081a4:	10816b14 	ori	r2,r2,1452

    movhi r3, %hi(__bss_end)
200081a8:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
200081ac:	18de5514 	ori	r3,r3,31060

    beq r2, r3, 1f
200081b0:	10c00326 	beq	r2,r3,200081c0 <_start+0x30>

0:
    stw zero, (r2)
200081b4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
200081b8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
200081bc:	10fffd36 	bltu	r2,r3,200081b4 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
200081c0:	0008c240 	call	20008c24 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
200081c4:	0008d1c0 	call	20008d1c <alt_main>

200081c8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
200081c8:	003fff06 	br	200081c8 <alt_after_alt_main>

200081cc <task1>:
#define TASK1_PRIORITY      1
#define TASK2_PRIORITY      2

/* Prints "Hello World" and sleeps for three seconds */
void task1(void* pdata)
{
200081cc:	defffd04 	addi	sp,sp,-12
200081d0:	dfc00215 	stw	ra,8(sp)
200081d4:	df000115 	stw	fp,4(sp)
200081d8:	df000104 	addi	fp,sp,4
200081dc:	e13fff15 	stw	r4,-4(fp)
	printf("task1\n");
200081e0:	01000034 	movhi	r4,0
200081e4:	21000004 	addi	r4,r4,0
200081e8:	00083f00 	call	200083f0 <puts>
  while (1)
  { 
    printf("Hello from task1\n");
200081ec:	01000034 	movhi	r4,0
200081f0:	21000204 	addi	r4,r4,8
200081f4:	00083f00 	call	200083f0 <puts>
    OSTimeDlyHMSM(0, 0, 3, 0);
200081f8:	0009883a 	mov	r4,zero
200081fc:	000b883a 	mov	r5,zero
20008200:	018000c4 	movi	r6,3
20008204:	000f883a 	mov	r7,zero
20008208:	000ceb40 	call	2000ceb4 <OSTimeDlyHMSM>
  }
2000820c:	003ff706 	br	200081ec <task1+0x20>

20008210 <task2>:
}
/* Prints "Hello World" and sleeps for three seconds */
void task2(void* pdata)
{
20008210:	defffd04 	addi	sp,sp,-12
20008214:	dfc00215 	stw	ra,8(sp)
20008218:	df000115 	stw	fp,4(sp)
2000821c:	df000104 	addi	fp,sp,4
20008220:	e13fff15 	stw	r4,-4(fp)
	printf("task2\n");
20008224:	01000034 	movhi	r4,0
20008228:	21000704 	addi	r4,r4,28
2000822c:	00083f00 	call	200083f0 <puts>
  while (1)
  { 
    printf("Hello from task2\n");
20008230:	01000034 	movhi	r4,0
20008234:	21000904 	addi	r4,r4,36
20008238:	00083f00 	call	200083f0 <puts>
    OSTimeDlyHMSM(0, 0, 3, 0);
2000823c:	0009883a 	mov	r4,zero
20008240:	000b883a 	mov	r5,zero
20008244:	018000c4 	movi	r6,3
20008248:	000f883a 	mov	r7,zero
2000824c:	000ceb40 	call	2000ceb4 <OSTimeDlyHMSM>
  }
20008250:	003ff706 	br	20008230 <task2+0x20>

20008254 <main>:
}
/* The main function creates two task and starts multi-tasking */
int main(void)
{
20008254:	defff804 	addi	sp,sp,-32
20008258:	dfc00715 	stw	ra,28(sp)
2000825c:	df000615 	stw	fp,24(sp)
20008260:	df000604 	addi	fp,sp,24
  printf("main\n");
20008264:	01000034 	movhi	r4,0
20008268:	21000e04 	addi	r4,r4,56
2000826c:	00083f00 	call	200083f0 <puts>
  OSInit();
20008270:	000960c0 	call	2000960c <OSInit>
  INT8U r=OSTaskCreateExt(task1,
20008274:	00800044 	movi	r2,1
20008278:	d8800015 	stw	r2,0(sp)
2000827c:	00800034 	movhi	r2,0
20008280:	10818c04 	addi	r2,r2,1584
20008284:	d8800115 	stw	r2,4(sp)
20008288:	00820004 	movi	r2,2048
2000828c:	d8800215 	stw	r2,8(sp)
20008290:	d8000315 	stw	zero,12(sp)
20008294:	d8000415 	stw	zero,16(sp)
20008298:	01080074 	movhi	r4,8193
2000829c:	21207304 	addi	r4,r4,-32308
200082a0:	000b883a 	mov	r5,zero
200082a4:	01800034 	movhi	r6,0
200082a8:	31898b04 	addi	r6,r6,9772
200082ac:	01c00044 	movi	r7,1
200082b0:	000ccac0 	call	2000ccac <OSTaskCreateExt>
200082b4:	e0bfff05 	stb	r2,-4(fp)
                  TASK1_PRIORITY,
                  task1_stk,
                  TASK_STACKSIZE,
                  NULL,
                  0);
          printf("task 1 %d\n",r);
200082b8:	e0bfff03 	ldbu	r2,-4(fp)
200082bc:	01000034 	movhi	r4,0
200082c0:	21001004 	addi	r4,r4,64
200082c4:	100b883a 	mov	r5,r2
200082c8:	00083240 	call	20008324 <printf>
                  TASK2_PRIORITY,
                  task2_stk,
                  TASK_STACKSIZE,
                  NULL,
                  0);*/
  OSStart();
200082cc:	00091ac0 	call	200091ac <OSStart>
  return 0;
200082d0:	0005883a 	mov	r2,zero
}
200082d4:	e037883a 	mov	sp,fp
200082d8:	dfc00117 	ldw	ra,4(sp)
200082dc:	df000017 	ldw	fp,0(sp)
200082e0:	dec00204 	addi	sp,sp,8
200082e4:	f800283a 	ret

200082e8 <_printf_r>:
200082e8:	defffd04 	addi	sp,sp,-12
200082ec:	dfc00015 	stw	ra,0(sp)
200082f0:	d9800115 	stw	r6,4(sp)
200082f4:	d9c00215 	stw	r7,8(sp)
200082f8:	20c00217 	ldw	r3,8(r4)
200082fc:	280d883a 	mov	r6,r5
20008300:	01480074 	movhi	r5,8193
20008304:	29627d04 	addi	r5,r5,-30220
20008308:	19400115 	stw	r5,4(r3)
2000830c:	21400217 	ldw	r5,8(r4)
20008310:	d9c00104 	addi	r7,sp,4
20008314:	000848c0 	call	2000848c <___vfprintf_internal_r>
20008318:	dfc00017 	ldw	ra,0(sp)
2000831c:	dec00304 	addi	sp,sp,12
20008320:	f800283a 	ret

20008324 <printf>:
20008324:	defffc04 	addi	sp,sp,-16
20008328:	dfc00015 	stw	ra,0(sp)
2000832c:	d9400115 	stw	r5,4(sp)
20008330:	d9800215 	stw	r6,8(sp)
20008334:	d9c00315 	stw	r7,12(sp)
20008338:	00800034 	movhi	r2,0
2000833c:	10814004 	addi	r2,r2,1280
20008340:	10800017 	ldw	r2,0(r2)
20008344:	200b883a 	mov	r5,r4
20008348:	01080074 	movhi	r4,8193
2000834c:	10c00217 	ldw	r3,8(r2)
20008350:	21227d04 	addi	r4,r4,-30220
20008354:	d9800104 	addi	r6,sp,4
20008358:	19000115 	stw	r4,4(r3)
2000835c:	11000217 	ldw	r4,8(r2)
20008360:	00089d00 	call	200089d0 <__vfprintf_internal>
20008364:	dfc00017 	ldw	ra,0(sp)
20008368:	dec00404 	addi	sp,sp,16
2000836c:	f800283a 	ret

20008370 <_puts_r>:
20008370:	defffd04 	addi	sp,sp,-12
20008374:	dc000015 	stw	r16,0(sp)
20008378:	2021883a 	mov	r16,r4
2000837c:	2809883a 	mov	r4,r5
20008380:	dfc00215 	stw	ra,8(sp)
20008384:	dc400115 	stw	r17,4(sp)
20008388:	2823883a 	mov	r17,r5
2000838c:	00084040 	call	20008404 <strlen>
20008390:	81400217 	ldw	r5,8(r16)
20008394:	00c80074 	movhi	r3,8193
20008398:	18e27d04 	addi	r3,r3,-30220
2000839c:	28c00115 	stw	r3,4(r5)
200083a0:	8009883a 	mov	r4,r16
200083a4:	880d883a 	mov	r6,r17
200083a8:	100f883a 	mov	r7,r2
200083ac:	00089f40 	call	200089f4 <__sfvwrite_small_dev>
200083b0:	00ffffc4 	movi	r3,-1
200083b4:	10c00926 	beq	r2,r3,200083dc <_puts_r+0x6c>
200083b8:	81400217 	ldw	r5,8(r16)
200083bc:	01800034 	movhi	r6,0
200083c0:	8009883a 	mov	r4,r16
200083c4:	28800117 	ldw	r2,4(r5)
200083c8:	31801304 	addi	r6,r6,76
200083cc:	01c00044 	movi	r7,1
200083d0:	103ee83a 	callr	r2
200083d4:	10bfffe0 	cmpeqi	r2,r2,-1
200083d8:	0085c83a 	sub	r2,zero,r2
200083dc:	dfc00217 	ldw	ra,8(sp)
200083e0:	dc400117 	ldw	r17,4(sp)
200083e4:	dc000017 	ldw	r16,0(sp)
200083e8:	dec00304 	addi	sp,sp,12
200083ec:	f800283a 	ret

200083f0 <puts>:
200083f0:	00800034 	movhi	r2,0
200083f4:	10814004 	addi	r2,r2,1280
200083f8:	200b883a 	mov	r5,r4
200083fc:	11000017 	ldw	r4,0(r2)
20008400:	00083701 	jmpi	20008370 <_puts_r>

20008404 <strlen>:
20008404:	2005883a 	mov	r2,r4
20008408:	10c00007 	ldb	r3,0(r2)
2000840c:	18000226 	beq	r3,zero,20008418 <strlen+0x14>
20008410:	10800044 	addi	r2,r2,1
20008414:	003ffc06 	br	20008408 <strlen+0x4>
20008418:	1105c83a 	sub	r2,r2,r4
2000841c:	f800283a 	ret

20008420 <print_repeat>:
20008420:	defffb04 	addi	sp,sp,-20
20008424:	dc800315 	stw	r18,12(sp)
20008428:	dc400215 	stw	r17,8(sp)
2000842c:	dc000115 	stw	r16,4(sp)
20008430:	dfc00415 	stw	ra,16(sp)
20008434:	2025883a 	mov	r18,r4
20008438:	2823883a 	mov	r17,r5
2000843c:	d9800005 	stb	r6,0(sp)
20008440:	3821883a 	mov	r16,r7
20008444:	04000a0e 	bge	zero,r16,20008470 <print_repeat+0x50>
20008448:	88800117 	ldw	r2,4(r17)
2000844c:	9009883a 	mov	r4,r18
20008450:	880b883a 	mov	r5,r17
20008454:	d80d883a 	mov	r6,sp
20008458:	01c00044 	movi	r7,1
2000845c:	103ee83a 	callr	r2
20008460:	843fffc4 	addi	r16,r16,-1
20008464:	103ff726 	beq	r2,zero,20008444 <print_repeat+0x24>
20008468:	00bfffc4 	movi	r2,-1
2000846c:	00000106 	br	20008474 <print_repeat+0x54>
20008470:	0005883a 	mov	r2,zero
20008474:	dfc00417 	ldw	ra,16(sp)
20008478:	dc800317 	ldw	r18,12(sp)
2000847c:	dc400217 	ldw	r17,8(sp)
20008480:	dc000117 	ldw	r16,4(sp)
20008484:	dec00504 	addi	sp,sp,20
20008488:	f800283a 	ret

2000848c <___vfprintf_internal_r>:
2000848c:	deffe404 	addi	sp,sp,-112
20008490:	d8c00804 	addi	r3,sp,32
20008494:	df001a15 	stw	fp,104(sp)
20008498:	ddc01915 	stw	r23,100(sp)
2000849c:	dd801815 	stw	r22,96(sp)
200084a0:	dd401715 	stw	r21,92(sp)
200084a4:	dd001615 	stw	r20,88(sp)
200084a8:	dcc01515 	stw	r19,84(sp)
200084ac:	dc801415 	stw	r18,80(sp)
200084b0:	dc401315 	stw	r17,76(sp)
200084b4:	dc001215 	stw	r16,72(sp)
200084b8:	dfc01b15 	stw	ra,108(sp)
200084bc:	2027883a 	mov	r19,r4
200084c0:	2839883a 	mov	fp,r5
200084c4:	382f883a 	mov	r23,r7
200084c8:	d9800f15 	stw	r6,60(sp)
200084cc:	0021883a 	mov	r16,zero
200084d0:	d8000e15 	stw	zero,56(sp)
200084d4:	002d883a 	mov	r22,zero
200084d8:	0029883a 	mov	r20,zero
200084dc:	0025883a 	mov	r18,zero
200084e0:	0023883a 	mov	r17,zero
200084e4:	d8000c15 	stw	zero,48(sp)
200084e8:	d8000b15 	stw	zero,44(sp)
200084ec:	002b883a 	mov	r21,zero
200084f0:	d8c00915 	stw	r3,36(sp)
200084f4:	d8c00f17 	ldw	r3,60(sp)
200084f8:	19000003 	ldbu	r4,0(r3)
200084fc:	20803fcc 	andi	r2,r4,255
20008500:	1080201c 	xori	r2,r2,128
20008504:	10bfe004 	addi	r2,r2,-128
20008508:	10012426 	beq	r2,zero,2000899c <___vfprintf_internal_r+0x510>
2000850c:	00c00044 	movi	r3,1
20008510:	a8c01426 	beq	r21,r3,20008564 <___vfprintf_internal_r+0xd8>
20008514:	1d400216 	blt	r3,r21,20008520 <___vfprintf_internal_r+0x94>
20008518:	a8000626 	beq	r21,zero,20008534 <___vfprintf_internal_r+0xa8>
2000851c:	00011b06 	br	2000898c <___vfprintf_internal_r+0x500>
20008520:	01400084 	movi	r5,2
20008524:	a9401d26 	beq	r21,r5,2000859c <___vfprintf_internal_r+0x110>
20008528:	014000c4 	movi	r5,3
2000852c:	a9402926 	beq	r21,r5,200085d4 <___vfprintf_internal_r+0x148>
20008530:	00011606 	br	2000898c <___vfprintf_internal_r+0x500>
20008534:	01400944 	movi	r5,37
20008538:	11410326 	beq	r2,r5,20008948 <___vfprintf_internal_r+0x4bc>
2000853c:	e0800117 	ldw	r2,4(fp)
20008540:	d9000005 	stb	r4,0(sp)
20008544:	e00b883a 	mov	r5,fp
20008548:	9809883a 	mov	r4,r19
2000854c:	d80d883a 	mov	r6,sp
20008550:	01c00044 	movi	r7,1
20008554:	103ee83a 	callr	r2
20008558:	1000de1e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
2000855c:	84000044 	addi	r16,r16,1
20008560:	00010a06 	br	2000898c <___vfprintf_internal_r+0x500>
20008564:	01400c04 	movi	r5,48
20008568:	11410026 	beq	r2,r5,2000896c <___vfprintf_internal_r+0x4e0>
2000856c:	01400944 	movi	r5,37
20008570:	11400a1e 	bne	r2,r5,2000859c <___vfprintf_internal_r+0x110>
20008574:	d8800005 	stb	r2,0(sp)
20008578:	e0800117 	ldw	r2,4(fp)
2000857c:	9809883a 	mov	r4,r19
20008580:	e00b883a 	mov	r5,fp
20008584:	d80d883a 	mov	r6,sp
20008588:	a80f883a 	mov	r7,r21
2000858c:	103ee83a 	callr	r2
20008590:	1000d01e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
20008594:	84000044 	addi	r16,r16,1
20008598:	0000fb06 	br	20008988 <___vfprintf_internal_r+0x4fc>
2000859c:	217ff404 	addi	r5,r4,-48
200085a0:	29403fcc 	andi	r5,r5,255
200085a4:	00c00244 	movi	r3,9
200085a8:	19400736 	bltu	r3,r5,200085c8 <___vfprintf_internal_r+0x13c>
200085ac:	00bfffc4 	movi	r2,-1
200085b0:	88800226 	beq	r17,r2,200085bc <___vfprintf_internal_r+0x130>
200085b4:	8c4002a4 	muli	r17,r17,10
200085b8:	00000106 	br	200085c0 <___vfprintf_internal_r+0x134>
200085bc:	0023883a 	mov	r17,zero
200085c0:	8963883a 	add	r17,r17,r5
200085c4:	0000ea06 	br	20008970 <___vfprintf_internal_r+0x4e4>
200085c8:	01400b84 	movi	r5,46
200085cc:	1140ec26 	beq	r2,r5,20008980 <___vfprintf_internal_r+0x4f4>
200085d0:	05400084 	movi	r21,2
200085d4:	213ff404 	addi	r4,r4,-48
200085d8:	21003fcc 	andi	r4,r4,255
200085dc:	00c00244 	movi	r3,9
200085e0:	19000736 	bltu	r3,r4,20008600 <___vfprintf_internal_r+0x174>
200085e4:	00bfffc4 	movi	r2,-1
200085e8:	90800226 	beq	r18,r2,200085f4 <___vfprintf_internal_r+0x168>
200085ec:	948002a4 	muli	r18,r18,10
200085f0:	00000106 	br	200085f8 <___vfprintf_internal_r+0x16c>
200085f4:	0025883a 	mov	r18,zero
200085f8:	9125883a 	add	r18,r18,r4
200085fc:	0000e306 	br	2000898c <___vfprintf_internal_r+0x500>
20008600:	00c01b04 	movi	r3,108
20008604:	10c0dc26 	beq	r2,r3,20008978 <___vfprintf_internal_r+0x4ec>
20008608:	013fffc4 	movi	r4,-1
2000860c:	91000226 	beq	r18,r4,20008618 <___vfprintf_internal_r+0x18c>
20008610:	d8000b15 	stw	zero,44(sp)
20008614:	00000106 	br	2000861c <___vfprintf_internal_r+0x190>
20008618:	04800044 	movi	r18,1
2000861c:	01001a44 	movi	r4,105
20008620:	11001626 	beq	r2,r4,2000867c <___vfprintf_internal_r+0x1f0>
20008624:	20800916 	blt	r4,r2,2000864c <___vfprintf_internal_r+0x1c0>
20008628:	010018c4 	movi	r4,99
2000862c:	11009226 	beq	r2,r4,20008878 <___vfprintf_internal_r+0x3ec>
20008630:	01001904 	movi	r4,100
20008634:	11001126 	beq	r2,r4,2000867c <___vfprintf_internal_r+0x1f0>
20008638:	01001604 	movi	r4,88
2000863c:	1100d21e 	bne	r2,r4,20008988 <___vfprintf_internal_r+0x4fc>
20008640:	00c00044 	movi	r3,1
20008644:	d8c00e15 	stw	r3,56(sp)
20008648:	00001406 	br	2000869c <___vfprintf_internal_r+0x210>
2000864c:	01001cc4 	movi	r4,115
20008650:	1100a226 	beq	r2,r4,200088dc <___vfprintf_internal_r+0x450>
20008654:	20800416 	blt	r4,r2,20008668 <___vfprintf_internal_r+0x1dc>
20008658:	01001bc4 	movi	r4,111
2000865c:	1100ca1e 	bne	r2,r4,20008988 <___vfprintf_internal_r+0x4fc>
20008660:	05000204 	movi	r20,8
20008664:	00000e06 	br	200086a0 <___vfprintf_internal_r+0x214>
20008668:	01001d44 	movi	r4,117
2000866c:	11000c26 	beq	r2,r4,200086a0 <___vfprintf_internal_r+0x214>
20008670:	01001e04 	movi	r4,120
20008674:	11000926 	beq	r2,r4,2000869c <___vfprintf_internal_r+0x210>
20008678:	0000c306 	br	20008988 <___vfprintf_internal_r+0x4fc>
2000867c:	b8800104 	addi	r2,r23,4
20008680:	b0000726 	beq	r22,zero,200086a0 <___vfprintf_internal_r+0x214>
20008684:	d8800d15 	stw	r2,52(sp)
20008688:	bdc00017 	ldw	r23,0(r23)
2000868c:	b800080e 	bge	r23,zero,200086b0 <___vfprintf_internal_r+0x224>
20008690:	05efc83a 	sub	r23,zero,r23
20008694:	02400044 	movi	r9,1
20008698:	00000606 	br	200086b4 <___vfprintf_internal_r+0x228>
2000869c:	05000404 	movi	r20,16
200086a0:	b8c00104 	addi	r3,r23,4
200086a4:	d8c00d15 	stw	r3,52(sp)
200086a8:	bdc00017 	ldw	r23,0(r23)
200086ac:	002d883a 	mov	r22,zero
200086b0:	0013883a 	mov	r9,zero
200086b4:	002b883a 	mov	r21,zero
200086b8:	dd4d883a 	add	r6,sp,r21
200086bc:	b8001626 	beq	r23,zero,20008718 <___vfprintf_internal_r+0x28c>
200086c0:	b809883a 	mov	r4,r23
200086c4:	a00b883a 	mov	r5,r20
200086c8:	d9801015 	stw	r6,64(sp)
200086cc:	da401115 	stw	r9,68(sp)
200086d0:	0008c140 	call	20008c14 <__udivsi3>
200086d4:	a089383a 	mul	r4,r20,r2
200086d8:	00c00244 	movi	r3,9
200086dc:	d9801017 	ldw	r6,64(sp)
200086e0:	b92fc83a 	sub	r23,r23,r4
200086e4:	da401117 	ldw	r9,68(sp)
200086e8:	1dc00216 	blt	r3,r23,200086f4 <___vfprintf_internal_r+0x268>
200086ec:	bdc00c04 	addi	r23,r23,48
200086f0:	00000506 	br	20008708 <___vfprintf_internal_r+0x27c>
200086f4:	d8c00e17 	ldw	r3,56(sp)
200086f8:	18000226 	beq	r3,zero,20008704 <___vfprintf_internal_r+0x278>
200086fc:	bdc00dc4 	addi	r23,r23,55
20008700:	00000106 	br	20008708 <___vfprintf_internal_r+0x27c>
20008704:	bdc015c4 	addi	r23,r23,87
20008708:	35c00005 	stb	r23,0(r6)
2000870c:	ad400044 	addi	r21,r21,1
20008710:	102f883a 	mov	r23,r2
20008714:	003fe806 	br	200086b8 <___vfprintf_internal_r+0x22c>
20008718:	36c7c83a 	sub	r3,r6,sp
2000871c:	d8c00a15 	stw	r3,40(sp)
20008720:	90c5c83a 	sub	r2,r18,r3
20008724:	302f883a 	mov	r23,r6
20008728:	00800e0e 	bge	zero,r2,20008764 <___vfprintf_internal_r+0x2d8>
2000872c:	302b883a 	mov	r21,r6
20008730:	3085883a 	add	r2,r6,r2
20008734:	01400c04 	movi	r5,48
20008738:	d8c00917 	ldw	r3,36(sp)
2000873c:	a809883a 	mov	r4,r21
20008740:	a8c0052e 	bgeu	r21,r3,20008758 <___vfprintf_internal_r+0x2cc>
20008744:	ad400044 	addi	r21,r21,1
20008748:	21400005 	stb	r5,0(r4)
2000874c:	a82f883a 	mov	r23,r21
20008750:	a8bff91e 	bne	r21,r2,20008738 <___vfprintf_internal_r+0x2ac>
20008754:	00000106 	br	2000875c <___vfprintf_internal_r+0x2d0>
20008758:	a82f883a 	mov	r23,r21
2000875c:	aeebc83a 	sub	r21,r21,sp
20008760:	dd400a15 	stw	r21,40(sp)
20008764:	d8c00a17 	ldw	r3,40(sp)
20008768:	1a51883a 	add	r8,r3,r9
2000876c:	d8c00b17 	ldw	r3,44(sp)
20008770:	8a2bc83a 	sub	r21,r17,r8
20008774:	18001726 	beq	r3,zero,200087d4 <___vfprintf_internal_r+0x348>
20008778:	48000a26 	beq	r9,zero,200087a4 <___vfprintf_internal_r+0x318>
2000877c:	00800b44 	movi	r2,45
20008780:	d8800805 	stb	r2,32(sp)
20008784:	e0800117 	ldw	r2,4(fp)
20008788:	9809883a 	mov	r4,r19
2000878c:	e00b883a 	mov	r5,fp
20008790:	d9800804 	addi	r6,sp,32
20008794:	01c00044 	movi	r7,1
20008798:	103ee83a 	callr	r2
2000879c:	10004d1e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
200087a0:	84000044 	addi	r16,r16,1
200087a4:	0540070e 	bge	zero,r21,200087c4 <___vfprintf_internal_r+0x338>
200087a8:	9809883a 	mov	r4,r19
200087ac:	e00b883a 	mov	r5,fp
200087b0:	01800c04 	movi	r6,48
200087b4:	a80f883a 	mov	r7,r21
200087b8:	00084200 	call	20008420 <print_repeat>
200087bc:	1000451e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
200087c0:	8561883a 	add	r16,r16,r21
200087c4:	d8c00a17 	ldw	r3,40(sp)
200087c8:	b811883a 	mov	r8,r23
200087cc:	1debc83a 	sub	r21,r3,r23
200087d0:	00002206 	br	2000885c <___vfprintf_internal_r+0x3d0>
200087d4:	0540090e 	bge	zero,r21,200087fc <___vfprintf_internal_r+0x370>
200087d8:	9809883a 	mov	r4,r19
200087dc:	e00b883a 	mov	r5,fp
200087e0:	01800804 	movi	r6,32
200087e4:	a80f883a 	mov	r7,r21
200087e8:	da401115 	stw	r9,68(sp)
200087ec:	00084200 	call	20008420 <print_repeat>
200087f0:	da401117 	ldw	r9,68(sp)
200087f4:	1000371e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
200087f8:	8561883a 	add	r16,r16,r21
200087fc:	483ff126 	beq	r9,zero,200087c4 <___vfprintf_internal_r+0x338>
20008800:	00800b44 	movi	r2,45
20008804:	d8800805 	stb	r2,32(sp)
20008808:	e0800117 	ldw	r2,4(fp)
2000880c:	9809883a 	mov	r4,r19
20008810:	e00b883a 	mov	r5,fp
20008814:	d9800804 	addi	r6,sp,32
20008818:	01c00044 	movi	r7,1
2000881c:	103ee83a 	callr	r2
20008820:	10002c1e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
20008824:	84000044 	addi	r16,r16,1
20008828:	003fe606 	br	200087c4 <___vfprintf_internal_r+0x338>
2000882c:	423fffc4 	addi	r8,r8,-1
20008830:	40800003 	ldbu	r2,0(r8)
20008834:	9809883a 	mov	r4,r19
20008838:	e00b883a 	mov	r5,fp
2000883c:	d8800805 	stb	r2,32(sp)
20008840:	e0800117 	ldw	r2,4(fp)
20008844:	d9800804 	addi	r6,sp,32
20008848:	da001015 	stw	r8,64(sp)
2000884c:	01c00044 	movi	r7,1
20008850:	103ee83a 	callr	r2
20008854:	da001017 	ldw	r8,64(sp)
20008858:	10001e1e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
2000885c:	8205c83a 	sub	r2,r16,r8
20008860:	4549883a 	add	r4,r8,r21
20008864:	b885883a 	add	r2,r23,r2
20008868:	013ff016 	blt	zero,r4,2000882c <___vfprintf_internal_r+0x3a0>
2000886c:	1021883a 	mov	r16,r2
20008870:	ddc00d17 	ldw	r23,52(sp)
20008874:	00004406 	br	20008988 <___vfprintf_internal_r+0x4fc>
20008878:	00800044 	movi	r2,1
2000887c:	1440080e 	bge	r2,r17,200088a0 <___vfprintf_internal_r+0x414>
20008880:	8d7fffc4 	addi	r21,r17,-1
20008884:	9809883a 	mov	r4,r19
20008888:	e00b883a 	mov	r5,fp
2000888c:	01800804 	movi	r6,32
20008890:	a80f883a 	mov	r7,r21
20008894:	00084200 	call	20008420 <print_repeat>
20008898:	10000e1e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
2000889c:	8561883a 	add	r16,r16,r21
200088a0:	b8800017 	ldw	r2,0(r23)
200088a4:	9809883a 	mov	r4,r19
200088a8:	e00b883a 	mov	r5,fp
200088ac:	d8800005 	stb	r2,0(sp)
200088b0:	e0800117 	ldw	r2,4(fp)
200088b4:	d80d883a 	mov	r6,sp
200088b8:	01c00044 	movi	r7,1
200088bc:	bd400104 	addi	r21,r23,4
200088c0:	103ee83a 	callr	r2
200088c4:	1000031e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
200088c8:	84000044 	addi	r16,r16,1
200088cc:	a82f883a 	mov	r23,r21
200088d0:	00002d06 	br	20008988 <___vfprintf_internal_r+0x4fc>
200088d4:	00bfffc4 	movi	r2,-1
200088d8:	00003106 	br	200089a0 <___vfprintf_internal_r+0x514>
200088dc:	bd400017 	ldw	r21,0(r23)
200088e0:	b8c00104 	addi	r3,r23,4
200088e4:	d8c00a15 	stw	r3,40(sp)
200088e8:	a809883a 	mov	r4,r21
200088ec:	00084040 	call	20008404 <strlen>
200088f0:	8893c83a 	sub	r9,r17,r2
200088f4:	102f883a 	mov	r23,r2
200088f8:	0240090e 	bge	zero,r9,20008920 <___vfprintf_internal_r+0x494>
200088fc:	480f883a 	mov	r7,r9
20008900:	9809883a 	mov	r4,r19
20008904:	e00b883a 	mov	r5,fp
20008908:	01800804 	movi	r6,32
2000890c:	da401115 	stw	r9,68(sp)
20008910:	00084200 	call	20008420 <print_repeat>
20008914:	da401117 	ldw	r9,68(sp)
20008918:	103fee1e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
2000891c:	8261883a 	add	r16,r16,r9
20008920:	e0800117 	ldw	r2,4(fp)
20008924:	9809883a 	mov	r4,r19
20008928:	e00b883a 	mov	r5,fp
2000892c:	a80d883a 	mov	r6,r21
20008930:	b80f883a 	mov	r7,r23
20008934:	103ee83a 	callr	r2
20008938:	103fe61e 	bne	r2,zero,200088d4 <___vfprintf_internal_r+0x448>
2000893c:	85e1883a 	add	r16,r16,r23
20008940:	ddc00a17 	ldw	r23,40(sp)
20008944:	00001006 	br	20008988 <___vfprintf_internal_r+0x4fc>
20008948:	05800044 	movi	r22,1
2000894c:	04bfffc4 	movi	r18,-1
20008950:	d8000e15 	stw	zero,56(sp)
20008954:	05000284 	movi	r20,10
20008958:	9023883a 	mov	r17,r18
2000895c:	d8000c15 	stw	zero,48(sp)
20008960:	d8000b15 	stw	zero,44(sp)
20008964:	b02b883a 	mov	r21,r22
20008968:	00000806 	br	2000898c <___vfprintf_internal_r+0x500>
2000896c:	dd400b15 	stw	r21,44(sp)
20008970:	05400084 	movi	r21,2
20008974:	00000506 	br	2000898c <___vfprintf_internal_r+0x500>
20008978:	00c00044 	movi	r3,1
2000897c:	d8c00c15 	stw	r3,48(sp)
20008980:	054000c4 	movi	r21,3
20008984:	00000106 	br	2000898c <___vfprintf_internal_r+0x500>
20008988:	002b883a 	mov	r21,zero
2000898c:	d8c00f17 	ldw	r3,60(sp)
20008990:	18c00044 	addi	r3,r3,1
20008994:	d8c00f15 	stw	r3,60(sp)
20008998:	003ed606 	br	200084f4 <___vfprintf_internal_r+0x68>
2000899c:	8005883a 	mov	r2,r16
200089a0:	dfc01b17 	ldw	ra,108(sp)
200089a4:	df001a17 	ldw	fp,104(sp)
200089a8:	ddc01917 	ldw	r23,100(sp)
200089ac:	dd801817 	ldw	r22,96(sp)
200089b0:	dd401717 	ldw	r21,92(sp)
200089b4:	dd001617 	ldw	r20,88(sp)
200089b8:	dcc01517 	ldw	r19,84(sp)
200089bc:	dc801417 	ldw	r18,80(sp)
200089c0:	dc401317 	ldw	r17,76(sp)
200089c4:	dc001217 	ldw	r16,72(sp)
200089c8:	dec01c04 	addi	sp,sp,112
200089cc:	f800283a 	ret

200089d0 <__vfprintf_internal>:
200089d0:	2007883a 	mov	r3,r4
200089d4:	01000034 	movhi	r4,0
200089d8:	21014004 	addi	r4,r4,1280
200089dc:	21000017 	ldw	r4,0(r4)
200089e0:	2805883a 	mov	r2,r5
200089e4:	300f883a 	mov	r7,r6
200089e8:	180b883a 	mov	r5,r3
200089ec:	100d883a 	mov	r6,r2
200089f0:	000848c1 	jmpi	2000848c <___vfprintf_internal_r>

200089f4 <__sfvwrite_small_dev>:
200089f4:	2880000b 	ldhu	r2,0(r5)
200089f8:	defffa04 	addi	sp,sp,-24
200089fc:	dc000015 	stw	r16,0(sp)
20008a00:	dfc00515 	stw	ra,20(sp)
20008a04:	dd000415 	stw	r20,16(sp)
20008a08:	dcc00315 	stw	r19,12(sp)
20008a0c:	dc800215 	stw	r18,8(sp)
20008a10:	dc400115 	stw	r17,4(sp)
20008a14:	1080020c 	andi	r2,r2,8
20008a18:	2821883a 	mov	r16,r5
20008a1c:	10001726 	beq	r2,zero,20008a7c <__sfvwrite_small_dev+0x88>
20008a20:	2880008f 	ldh	r2,2(r5)
20008a24:	10001216 	blt	r2,zero,20008a70 <__sfvwrite_small_dev+0x7c>
20008a28:	2027883a 	mov	r19,r4
20008a2c:	3025883a 	mov	r18,r6
20008a30:	3823883a 	mov	r17,r7
20008a34:	05010004 	movi	r20,1024
20008a38:	04400b0e 	bge	zero,r17,20008a68 <__sfvwrite_small_dev+0x74>
20008a3c:	8140008f 	ldh	r5,2(r16)
20008a40:	880f883a 	mov	r7,r17
20008a44:	a440010e 	bge	r20,r17,20008a4c <__sfvwrite_small_dev+0x58>
20008a48:	01c10004 	movi	r7,1024
20008a4c:	9809883a 	mov	r4,r19
20008a50:	900d883a 	mov	r6,r18
20008a54:	0008aa00 	call	20008aa0 <_write_r>
20008a58:	0080050e 	bge	zero,r2,20008a70 <__sfvwrite_small_dev+0x7c>
20008a5c:	88a3c83a 	sub	r17,r17,r2
20008a60:	90a5883a 	add	r18,r18,r2
20008a64:	003ff406 	br	20008a38 <__sfvwrite_small_dev+0x44>
20008a68:	0005883a 	mov	r2,zero
20008a6c:	00000406 	br	20008a80 <__sfvwrite_small_dev+0x8c>
20008a70:	8080000b 	ldhu	r2,0(r16)
20008a74:	10801014 	ori	r2,r2,64
20008a78:	8080000d 	sth	r2,0(r16)
20008a7c:	00bfffc4 	movi	r2,-1
20008a80:	dfc00517 	ldw	ra,20(sp)
20008a84:	dd000417 	ldw	r20,16(sp)
20008a88:	dcc00317 	ldw	r19,12(sp)
20008a8c:	dc800217 	ldw	r18,8(sp)
20008a90:	dc400117 	ldw	r17,4(sp)
20008a94:	dc000017 	ldw	r16,0(sp)
20008a98:	dec00604 	addi	sp,sp,24
20008a9c:	f800283a 	ret

20008aa0 <_write_r>:
20008aa0:	defffd04 	addi	sp,sp,-12
20008aa4:	dc000015 	stw	r16,0(sp)
20008aa8:	04000034 	movhi	r16,0
20008aac:	dc400115 	stw	r17,4(sp)
20008ab0:	84016b04 	addi	r16,r16,1452
20008ab4:	2023883a 	mov	r17,r4
20008ab8:	2809883a 	mov	r4,r5
20008abc:	300b883a 	mov	r5,r6
20008ac0:	380d883a 	mov	r6,r7
20008ac4:	dfc00215 	stw	ra,8(sp)
20008ac8:	80000015 	stw	zero,0(r16)
20008acc:	0008de40 	call	20008de4 <write>
20008ad0:	00ffffc4 	movi	r3,-1
20008ad4:	10c0031e 	bne	r2,r3,20008ae4 <_write_r+0x44>
20008ad8:	80c00017 	ldw	r3,0(r16)
20008adc:	18000126 	beq	r3,zero,20008ae4 <_write_r+0x44>
20008ae0:	88c00015 	stw	r3,0(r17)
20008ae4:	dfc00217 	ldw	ra,8(sp)
20008ae8:	dc400117 	ldw	r17,4(sp)
20008aec:	dc000017 	ldw	r16,0(sp)
20008af0:	dec00304 	addi	sp,sp,12
20008af4:	f800283a 	ret

20008af8 <udivmodsi4>:
20008af8:	2900182e 	bgeu	r5,r4,20008b5c <udivmodsi4+0x64>
20008afc:	28001716 	blt	r5,zero,20008b5c <udivmodsi4+0x64>
20008b00:	00800804 	movi	r2,32
20008b04:	00c00044 	movi	r3,1
20008b08:	00000206 	br	20008b14 <udivmodsi4+0x1c>
20008b0c:	10001126 	beq	r2,zero,20008b54 <udivmodsi4+0x5c>
20008b10:	28000516 	blt	r5,zero,20008b28 <udivmodsi4+0x30>
20008b14:	294b883a 	add	r5,r5,r5
20008b18:	10bfffc4 	addi	r2,r2,-1
20008b1c:	18c7883a 	add	r3,r3,r3
20008b20:	293ffa36 	bltu	r5,r4,20008b0c <udivmodsi4+0x14>
20008b24:	18000b26 	beq	r3,zero,20008b54 <udivmodsi4+0x5c>
20008b28:	0005883a 	mov	r2,zero
20008b2c:	21400236 	bltu	r4,r5,20008b38 <udivmodsi4+0x40>
20008b30:	2149c83a 	sub	r4,r4,r5
20008b34:	10c4b03a 	or	r2,r2,r3
20008b38:	1806d07a 	srli	r3,r3,1
20008b3c:	280ad07a 	srli	r5,r5,1
20008b40:	183ffa1e 	bne	r3,zero,20008b2c <udivmodsi4+0x34>
20008b44:	3000011e 	bne	r6,zero,20008b4c <udivmodsi4+0x54>
20008b48:	f800283a 	ret
20008b4c:	2005883a 	mov	r2,r4
20008b50:	f800283a 	ret
20008b54:	0005883a 	mov	r2,zero
20008b58:	003ffa06 	br	20008b44 <udivmodsi4+0x4c>
20008b5c:	00c00044 	movi	r3,1
20008b60:	003ff106 	br	20008b28 <udivmodsi4+0x30>

20008b64 <__divsi3>:
20008b64:	defffe04 	addi	sp,sp,-8
20008b68:	dfc00115 	stw	ra,4(sp)
20008b6c:	dc000015 	stw	r16,0(sp)
20008b70:	20000b16 	blt	r4,zero,20008ba0 <__divsi3+0x3c>
20008b74:	0021883a 	mov	r16,zero
20008b78:	28000c16 	blt	r5,zero,20008bac <__divsi3+0x48>
20008b7c:	000d883a 	mov	r6,zero
20008b80:	0008af80 	call	20008af8 <udivmodsi4>
20008b84:	0407c83a 	sub	r3,zero,r16
20008b88:	1884f03a 	xor	r2,r3,r2
20008b8c:	1405883a 	add	r2,r2,r16
20008b90:	dfc00117 	ldw	ra,4(sp)
20008b94:	dc000017 	ldw	r16,0(sp)
20008b98:	dec00204 	addi	sp,sp,8
20008b9c:	f800283a 	ret
20008ba0:	0109c83a 	sub	r4,zero,r4
20008ba4:	04000044 	movi	r16,1
20008ba8:	283ff40e 	bge	r5,zero,20008b7c <__divsi3+0x18>
20008bac:	014bc83a 	sub	r5,zero,r5
20008bb0:	8400005c 	xori	r16,r16,1
20008bb4:	003ff106 	br	20008b7c <__divsi3+0x18>

20008bb8 <__modsi3>:
20008bb8:	defffd04 	addi	sp,sp,-12
20008bbc:	dfc00215 	stw	ra,8(sp)
20008bc0:	dc400115 	stw	r17,4(sp)
20008bc4:	dc000015 	stw	r16,0(sp)
20008bc8:	20000c16 	blt	r4,zero,20008bfc <__modsi3+0x44>
20008bcc:	0023883a 	mov	r17,zero
20008bd0:	0021883a 	mov	r16,zero
20008bd4:	28000d16 	blt	r5,zero,20008c0c <__modsi3+0x54>
20008bd8:	01800044 	movi	r6,1
20008bdc:	0008af80 	call	20008af8 <udivmodsi4>
20008be0:	1404f03a 	xor	r2,r2,r16
20008be4:	8885883a 	add	r2,r17,r2
20008be8:	dfc00217 	ldw	ra,8(sp)
20008bec:	dc400117 	ldw	r17,4(sp)
20008bf0:	dc000017 	ldw	r16,0(sp)
20008bf4:	dec00304 	addi	sp,sp,12
20008bf8:	f800283a 	ret
20008bfc:	0109c83a 	sub	r4,zero,r4
20008c00:	04400044 	movi	r17,1
20008c04:	043fffc4 	movi	r16,-1
20008c08:	283ff30e 	bge	r5,zero,20008bd8 <__modsi3+0x20>
20008c0c:	014bc83a 	sub	r5,zero,r5
20008c10:	003ff106 	br	20008bd8 <__modsi3+0x20>

20008c14 <__udivsi3>:
20008c14:	000d883a 	mov	r6,zero
20008c18:	0008af81 	jmpi	20008af8 <udivmodsi4>

20008c1c <__umodsi3>:
20008c1c:	01800044 	movi	r6,1
20008c20:	0008af81 	jmpi	20008af8 <udivmodsi4>

20008c24 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
20008c24:	deffff04 	addi	sp,sp,-4
20008c28:	01000034 	movhi	r4,0
20008c2c:	01480074 	movhi	r5,8193
20008c30:	dfc00015 	stw	ra,0(sp)
20008c34:	21006f04 	addi	r4,r4,444
20008c38:	297a7b04 	addi	r5,r5,-5652

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
20008c3c:	2140061e 	bne	r4,r5,20008c58 <alt_load+0x34>
20008c40:	01080074 	movhi	r4,8193
20008c44:	01480074 	movhi	r5,8193
20008c48:	21200804 	addi	r4,r4,-32736
20008c4c:	29600804 	addi	r5,r5,-32736
20008c50:	2140141e 	bne	r4,r5,20008ca4 <alt_load+0x80>
20008c54:	00000d06 	br	20008c8c <alt_load+0x68>
20008c58:	00c00034 	movhi	r3,0
20008c5c:	18c16b04 	addi	r3,r3,1452
20008c60:	00bfff04 	movi	r2,-4
20008c64:	1907c83a 	sub	r3,r3,r4
20008c68:	1886703a 	and	r3,r3,r2
20008c6c:	0005883a 	mov	r2,zero
  {
    while( to != end )
20008c70:	10fff326 	beq	r2,r3,20008c40 <alt_load+0x1c>
20008c74:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
20008c78:	39c00017 	ldw	r7,0(r7)
20008c7c:	110d883a 	add	r6,r2,r4
20008c80:	10800104 	addi	r2,r2,4
20008c84:	31c00015 	stw	r7,0(r6)
20008c88:	003ff906 	br	20008c70 <alt_load+0x4c>
20008c8c:	01000034 	movhi	r4,0
20008c90:	01480074 	movhi	r5,8193
20008c94:	21000004 	addi	r4,r4,0
20008c98:	297a0c04 	addi	r5,r5,-6096

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
20008c9c:	2140121e 	bne	r4,r5,20008ce8 <alt_load+0xc4>
20008ca0:	00000d06 	br	20008cd8 <alt_load+0xb4>
20008ca4:	00c80074 	movhi	r3,8193
20008ca8:	18e06404 	addi	r3,r3,-32368
20008cac:	00bfff04 	movi	r2,-4
20008cb0:	1907c83a 	sub	r3,r3,r4
20008cb4:	1886703a 	and	r3,r3,r2
20008cb8:	0005883a 	mov	r2,zero
  {
    while( to != end )
20008cbc:	10fff326 	beq	r2,r3,20008c8c <alt_load+0x68>
20008cc0:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
20008cc4:	39c00017 	ldw	r7,0(r7)
20008cc8:	110d883a 	add	r6,r2,r4
20008ccc:	10800104 	addi	r2,r2,4
20008cd0:	31c00015 	stw	r7,0(r6)
20008cd4:	003ff906 	br	20008cbc <alt_load+0x98>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
20008cd8:	000dac00 	call	2000dac0 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
20008cdc:	dfc00017 	ldw	ra,0(sp)
20008ce0:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
20008ce4:	000dc481 	jmpi	2000dc48 <alt_icache_flush_all>
20008ce8:	00c00034 	movhi	r3,0
20008cec:	18c06f04 	addi	r3,r3,444
20008cf0:	00bfff04 	movi	r2,-4
20008cf4:	1907c83a 	sub	r3,r3,r4
20008cf8:	1886703a 	and	r3,r3,r2

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
20008cfc:	0005883a 	mov	r2,zero
  {
    while( to != end )
20008d00:	10fff526 	beq	r2,r3,20008cd8 <alt_load+0xb4>
20008d04:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
20008d08:	39c00017 	ldw	r7,0(r7)
20008d0c:	110d883a 	add	r6,r2,r4
20008d10:	10800104 	addi	r2,r2,4
20008d14:	31c00015 	stw	r7,0(r6)
20008d18:	003ff906 	br	20008d00 <alt_load+0xdc>

20008d1c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
20008d1c:	defffd04 	addi	sp,sp,-12
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
20008d20:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
20008d24:	dfc00215 	stw	ra,8(sp)
20008d28:	dc400115 	stw	r17,4(sp)
20008d2c:	dc000015 	stw	r16,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
20008d30:	000d0fc0 	call	2000d0fc <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
20008d34:	04000044 	movi	r16,1
20008d38:	000960c0 	call	2000960c <OSInit>
20008d3c:	8009883a 	mov	r4,r16
20008d40:	000b9f00 	call	2000b9f0 <OSSemCreate>
20008d44:	00c00034 	movhi	r3,0
20008d48:	18c17004 	addi	r3,r3,1472
20008d4c:	8009883a 	mov	r4,r16
20008d50:	18800015 	stw	r2,0(r3)
20008d54:	000b9f00 	call	2000b9f0 <OSSemCreate>
20008d58:	00c00034 	movhi	r3,0
20008d5c:	18c17204 	addi	r3,r3,1480
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
20008d60:	8009883a 	mov	r4,r16
20008d64:	18800015 	stw	r2,0(r3)
20008d68:	000b9f00 	call	2000b9f0 <OSSemCreate>
20008d6c:	00c00034 	movhi	r3,0
20008d70:	18c18704 	addi	r3,r3,1564
20008d74:	18800015 	stw	r2,0(r3)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
20008d78:	000d11c0 	call	2000d11c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
20008d7c:	01000034 	movhi	r4,0
20008d80:	21001404 	addi	r4,r4,80
20008d84:	200b883a 	mov	r5,r4
20008d88:	200d883a 	mov	r6,r4
20008d8c:	000ddd00 	call	2000ddd0 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
20008d90:	000db440 	call	2000db44 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
20008d94:	01080074 	movhi	r4,8193
20008d98:	2136e304 	addi	r4,r4,-9332
20008d9c:	000e4a00 	call	2000e4a0 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
20008da0:	d1202f17 	ldw	r4,-32580(gp)
20008da4:	d1602e17 	ldw	r5,-32584(gp)
20008da8:	d1a02d17 	ldw	r6,-32588(gp)
20008dac:	00082540 	call	20008254 <main>
  close(STDOUT_FILENO);
20008db0:	8009883a 	mov	r4,r16
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
20008db4:	1023883a 	mov	r17,r2
  close(STDOUT_FILENO);
20008db8:	000d9f80 	call	2000d9f8 <close>
  exit (result);
20008dbc:	8809883a 	mov	r4,r17
20008dc0:	000e4b40 	call	2000e4b4 <exit>

20008dc4 <alt_get_errno>:

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
20008dc4:	00800034 	movhi	r2,0
20008dc8:	10816704 	addi	r2,r2,1436
20008dcc:	10800017 	ldw	r2,0(r2)
20008dd0:	10000126 	beq	r2,zero,20008dd8 <alt_get_errno+0x14>
20008dd4:	1000683a 	jmp	r2
}
20008dd8:	00800034 	movhi	r2,0
20008ddc:	10816b04 	addi	r2,r2,1452
20008de0:	f800283a 	ret

20008de4 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
20008de4:	defffe04 	addi	sp,sp,-8
20008de8:	dfc00115 	stw	ra,4(sp)
20008dec:	dc000015 	stw	r16,0(sp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
20008df0:	20001516 	blt	r4,zero,20008e48 <write+0x64>
20008df4:	20800324 	muli	r2,r4,12
20008df8:	00c00034 	movhi	r3,0
20008dfc:	18c0d504 	addi	r3,r3,852
20008e00:	10c9883a 	add	r4,r2,r3
  
  if (fd)
20008e04:	20001026 	beq	r4,zero,20008e48 <write+0x64>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
20008e08:	20800217 	ldw	r2,8(r4)
20008e0c:	108000cc 	andi	r2,r2,3
20008e10:	10000a26 	beq	r2,zero,20008e3c <write+0x58>
20008e14:	20800017 	ldw	r2,0(r4)
20008e18:	10800617 	ldw	r2,24(r2)
20008e1c:	10000726 	beq	r2,zero,20008e3c <write+0x58>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
20008e20:	103ee83a 	callr	r2
20008e24:	1021883a 	mov	r16,r2
20008e28:	10000b0e 	bge	r2,zero,20008e58 <write+0x74>
      {
        ALT_ERRNO = -rval;
20008e2c:	0008dc40 	call	20008dc4 <alt_get_errno>
20008e30:	0421c83a 	sub	r16,zero,r16
20008e34:	14000015 	stw	r16,0(r2)
20008e38:	00000606 	br	20008e54 <write+0x70>
      }
      return rval;
    }
    else
    {
      ALT_ERRNO = EACCES;
20008e3c:	0008dc40 	call	20008dc4 <alt_get_errno>
20008e40:	00c00344 	movi	r3,13
20008e44:	00000206 	br	20008e50 <write+0x6c>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
20008e48:	0008dc40 	call	20008dc4 <alt_get_errno>
20008e4c:	00c01444 	movi	r3,81
20008e50:	10c00015 	stw	r3,0(r2)
  }
  return -1;
20008e54:	043fffc4 	movi	r16,-1
}
20008e58:	8005883a 	mov	r2,r16
20008e5c:	dfc00117 	ldw	ra,4(sp)
20008e60:	dc000017 	ldw	r16,0(sp)
20008e64:	dec00204 	addi	sp,sp,8
20008e68:	f800283a 	ret

20008e6c <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
20008e6c:	deffe104 	addi	sp,sp,-124
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
20008e70:	01003fc4 	movi	r4,255
20008e74:	d80b883a 	mov	r5,sp
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
20008e78:	dfc01e15 	stw	ra,120(sp)
20008e7c:	dc001d15 	stw	r16,116(sp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
20008e80:	000cbac0 	call	2000cbac <OSTaskQuery>
20008e84:	d8801c85 	stb	r2,114(sp)
  if (err != OS_NO_ERR)
20008e88:	10803fcc 	andi	r2,r2,255
20008e8c:	1000131e 	bne	r2,zero,20008edc <__env_lock+0x70>

  id = tcb.OSTCBPrio;
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
20008e90:	d1203117 	ldw	r4,-32572(gp)
20008e94:	d9401b04 	addi	r5,sp,108

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;

  id = tcb.OSTCBPrio;
20008e98:	dc000c83 	ldbu	r16,50(sp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
20008e9c:	000bed80 	call	2000bed8 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
20008ea0:	d8801c43 	ldbu	r2,113(sp)
20008ea4:	10000626 	beq	r2,zero,20008ec0 <__env_lock+0x54>
20008ea8:	d0a00217 	ldw	r2,-32760(gp)
20008eac:	8080041e 	bne	r16,r2,20008ec0 <__env_lock+0x54>
  {
    /* we do; just count the recursion */

    locks++;
20008eb0:	d0a03017 	ldw	r2,-32576(gp)
20008eb4:	10800044 	addi	r2,r2,1
20008eb8:	d0a03015 	stw	r2,-32576(gp)
20008ebc:	00000706 	br	20008edc <__env_lock+0x70>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
20008ec0:	d1203117 	ldw	r4,-32572(gp)
20008ec4:	000b883a 	mov	r5,zero
20008ec8:	d9801c84 	addi	r6,sp,114
20008ecc:	000bbf40 	call	2000bbf4 <OSSemPend>
    locks  = 1;
20008ed0:	00800044 	movi	r2,1
20008ed4:	d0a03015 	stw	r2,-32576(gp)
    lockid = id;
20008ed8:	d4200215 	stw	r16,-32760(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
20008edc:	dfc01e17 	ldw	ra,120(sp)
20008ee0:	dc001d17 	ldw	r16,116(sp)
20008ee4:	dec01f04 	addi	sp,sp,124
20008ee8:	f800283a 	ret

20008eec <__env_unlock>:
 */

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
20008eec:	d0a03017 	ldw	r2,-32576(gp)
20008ef0:	10000726 	beq	r2,zero,20008f10 <__env_unlock+0x24>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
20008ef4:	10bfffc4 	addi	r2,r2,-1
20008ef8:	d0a03015 	stw	r2,-32576(gp)
20008efc:	1000041e 	bne	r2,zero,20008f10 <__env_unlock+0x24>
  {
    lockid = -1;
    OSSemPost( alt_envsem );
20008f00:	d1203117 	ldw	r4,-32572(gp)
    * of unlocks 
    */

  if( (--locks) == 0 ) 
  {
    lockid = -1;
20008f04:	00bfffc4 	movi	r2,-1
20008f08:	d0a00215 	stw	r2,-32760(gp)
    OSSemPost( alt_envsem );
20008f0c:	000be301 	jmpi	2000be30 <OSSemPost>
20008f10:	f800283a 	ret

20008f14 <__malloc_lock>:
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
20008f14:	00800034 	movhi	r2,0
20008f18:	10817344 	addi	r2,r2,1485
20008f1c:	10c00003 	ldbu	r3,0(r2)
20008f20:	00800044 	movi	r2,1
20008f24:	1880251e 	bne	r3,r2,20008fbc <__malloc_lock+0xa8>
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
20008f28:	deffe104 	addi	sp,sp,-124
  if (OSRunning != OS_TRUE)
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
20008f2c:	01003fc4 	movi	r4,255
20008f30:	d80b883a 	mov	r5,sp
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
20008f34:	dfc01e15 	stw	ra,120(sp)
20008f38:	dc001d15 	stw	r16,116(sp)
  if (OSRunning != OS_TRUE)
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
20008f3c:	000cbac0 	call	2000cbac <OSTaskQuery>
20008f40:	d8801c85 	stb	r2,114(sp)
  if (err != OS_NO_ERR)
20008f44:	10803fcc 	andi	r2,r2,255
20008f48:	1000191e 	bne	r2,zero,20008fb0 <__malloc_lock+0x9c>

  id = tcb.OSTCBPrio;
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
20008f4c:	d1203317 	ldw	r4,-32564(gp)

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;

  id = tcb.OSTCBPrio;
20008f50:	dc000c83 	ldbu	r16,50(sp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
20008f54:	d9401b04 	addi	r5,sp,108
20008f58:	000bed80 	call	2000bed8 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20008f5c:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20008f60:	00ffff84 	movi	r3,-2
20008f64:	10c6703a 	and	r3,r2,r3
20008f68:	1801703a 	wrctl	status,r3
  
  OS_ENTER_CRITICAL();

  if( !semdata.OSCnt && id == lockid ) 
20008f6c:	d8c01b0b 	ldhu	r3,108(sp)
20008f70:	1800071e 	bne	r3,zero,20008f90 <__malloc_lock+0x7c>
20008f74:	d0e00317 	ldw	r3,-32756(gp)
20008f78:	80c0051e 	bne	r16,r3,20008f90 <__malloc_lock+0x7c>
  {
    /* we do; just count the recursion */
    locks++;
20008f7c:	d0e03217 	ldw	r3,-32568(gp)
20008f80:	18c00044 	addi	r3,r3,1
20008f84:	d0e03215 	stw	r3,-32568(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20008f88:	1001703a 	wrctl	status,r2
20008f8c:	00000806 	br	20008fb0 <__malloc_lock+0x9c>
20008f90:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
20008f94:	d1203317 	ldw	r4,-32564(gp)
20008f98:	000b883a 	mov	r5,zero
20008f9c:	d9801c84 	addi	r6,sp,114
20008fa0:	000bbf40 	call	2000bbf4 <OSSemPend>
    locks  = 1;
20008fa4:	00800044 	movi	r2,1
20008fa8:	d0a03215 	stw	r2,-32568(gp)
    lockid = id;
20008fac:	d4200315 	stw	r16,-32756(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
20008fb0:	dfc01e17 	ldw	ra,120(sp)
20008fb4:	dc001d17 	ldw	r16,116(sp)
20008fb8:	dec01f04 	addi	sp,sp,124
20008fbc:	f800283a 	ret

20008fc0 <__malloc_unlock>:

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
20008fc0:	00800034 	movhi	r2,0
20008fc4:	10817344 	addi	r2,r2,1485
20008fc8:	10c00003 	ldbu	r3,0(r2)
20008fcc:	00800044 	movi	r2,1
20008fd0:	18800f1e 	bne	r3,r2,20009010 <__malloc_unlock+0x50>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20008fd4:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20008fd8:	00bfff84 	movi	r2,-2
20008fdc:	1884703a 	and	r2,r3,r2
20008fe0:	1001703a 	wrctl	status,r2
      return;

  OS_ENTER_CRITICAL();
  if (locks == 0)
20008fe4:	d0a03217 	ldw	r2,-32568(gp)
20008fe8:	10000826 	beq	r2,zero,2000900c <__malloc_unlock+0x4c>
      OS_EXIT_CRITICAL();
      return;
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
20008fec:	10bfffc4 	addi	r2,r2,-1
20008ff0:	d0a03215 	stw	r2,-32568(gp)
20008ff4:	1000051e 	bne	r2,zero,2000900c <__malloc_unlock+0x4c>
  {
    lockid = -1;
20008ff8:	00bfffc4 	movi	r2,-1
20008ffc:	d0a00315 	stw	r2,-32756(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009000:	1801703a 	wrctl	status,r3
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
20009004:	d1203317 	ldw	r4,-32564(gp)
20009008:	000be301 	jmpi	2000be30 <OSSemPost>
2000900c:	1801703a 	wrctl	status,r3
20009010:	f800283a 	ret

20009014 <OS_SchedNew>:
{
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
20009014:	d0a04003 	ldbu	r2,-32512(gp)
20009018:	01400034 	movhi	r5,0
2000901c:	29401f84 	addi	r5,r5,126
20009020:	2885883a 	add	r2,r5,r2
20009024:	10800003 	ldbu	r2,0(r2)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
20009028:	d0e04044 	addi	r3,gp,-32511
2000902c:	11003fcc 	andi	r4,r2,255
20009030:	1909883a 	add	r4,r3,r4
20009034:	20c00003 	ldbu	r3,0(r4)
20009038:	100490fa 	slli	r2,r2,3
2000903c:	28c7883a 	add	r3,r5,r3
20009040:	18c00003 	ldbu	r3,0(r3)
20009044:	10c5883a 	add	r2,r2,r3
20009048:	d0a03605 	stb	r2,-32552(gp)
2000904c:	f800283a 	ret

20009050 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
20009050:	defffe04 	addi	sp,sp,-8
20009054:	dc000015 	stw	r16,0(sp)
20009058:	dfc00115 	stw	ra,4(sp)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000905c:	043fff84 	movi	r16,-2
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009060:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009064:	1c04703a 	and	r2,r3,r16
20009068:	1001703a 	wrctl	status,r2


    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
        OSIdleCtr++;
2000906c:	d0a03517 	ldw	r2,-32556(gp)
20009070:	10800044 	addi	r2,r2,1
20009074:	d0a03515 	stw	r2,-32556(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009078:	1801703a 	wrctl	status,r3
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
2000907c:	000e2a40 	call	2000e2a4 <OSTaskIdleHook>
    }
20009080:	003ff706 	br	20009060 <OS_TaskIdle+0x10>

20009084 <OSIntEnter>:
{
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
#endif

    if (OSRunning == OS_TRUE) {
20009084:	d0e03443 	ldbu	r3,-32559(gp)
20009088:	00800044 	movi	r2,1
2000908c:	18800b1e 	bne	r3,r2,200090bc <OSIntEnter+0x38>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009090:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009094:	00bfff84 	movi	r2,-2
20009098:	1884703a 	and	r2,r3,r2
2000909c:	1001703a 	wrctl	status,r2
        OS_ENTER_CRITICAL();
        if (OSIntNesting < 255u) {
200090a0:	d0a04203 	ldbu	r2,-32504(gp)
200090a4:	01003fc4 	movi	r4,255
200090a8:	11403fcc 	andi	r5,r2,255
200090ac:	29000226 	beq	r5,r4,200090b8 <OSIntEnter+0x34>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
200090b0:	10800044 	addi	r2,r2,1
200090b4:	d0a04205 	stb	r2,-32504(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200090b8:	1801703a 	wrctl	status,r3
200090bc:	f800283a 	ret

200090c0 <OSIntExit>:
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSRunning == OS_TRUE) {
200090c0:	d0e03443 	ldbu	r3,-32559(gp)
200090c4:	00800044 	movi	r2,1
200090c8:	1880261e 	bne	r3,r2,20009164 <OSIntExit+0xa4>
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
200090cc:	defffe04 	addi	sp,sp,-8
200090d0:	dfc00115 	stw	ra,4(sp)
200090d4:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200090d8:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200090dc:	00bfff84 	movi	r2,-2
200090e0:	8084703a 	and	r2,r16,r2
200090e4:	1001703a 	wrctl	status,r2



    if (OSRunning == OS_TRUE) {
        OS_ENTER_CRITICAL();
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
200090e8:	d0a04203 	ldbu	r2,-32504(gp)
200090ec:	10c03fcc 	andi	r3,r2,255
200090f0:	18000226 	beq	r3,zero,200090fc <OSIntExit+0x3c>
            OSIntNesting--;
200090f4:	10bfffc4 	addi	r2,r2,-1
200090f8:	d0a04205 	stb	r2,-32504(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
200090fc:	d0a04203 	ldbu	r2,-32504(gp)
20009100:	1000141e 	bne	r2,zero,20009154 <OSIntExit+0x94>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
20009104:	d0a03403 	ldbu	r2,-32560(gp)
20009108:	1000121e 	bne	r2,zero,20009154 <OSIntExit+0x94>
                OS_SchedNew();
2000910c:	00090140 	call	20009014 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
20009110:	d0a03603 	ldbu	r2,-32552(gp)
20009114:	d0e03643 	ldbu	r3,-32551(gp)
20009118:	10c00e26 	beq	r2,r3,20009154 <OSIntExit+0x94>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
2000911c:	1085883a 	add	r2,r2,r2
20009120:	00c00034 	movhi	r3,0
20009124:	18de0004 	addi	r3,r3,30720
20009128:	1085883a 	add	r2,r2,r2
2000912c:	1885883a 	add	r2,r3,r2
20009130:	10800017 	ldw	r2,0(r2)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
20009134:	10c00e17 	ldw	r3,56(r2)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
                OS_SchedNew();
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
20009138:	d0a03e15 	stw	r2,-32520(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
2000913c:	18c00044 	addi	r3,r3,1
20009140:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
20009144:	d0a03917 	ldw	r2,-32540(gp)
20009148:	10800044 	addi	r2,r2,1
2000914c:	d0a03915 	stw	r2,-32540(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
20009150:	000e0e00 	call	2000e0e0 <OSCtxSw>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009154:	8001703a 	wrctl	status,r16
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
20009158:	dfc00117 	ldw	ra,4(sp)
2000915c:	dc000017 	ldw	r16,0(sp)
20009160:	dec00204 	addi	sp,sp,8
20009164:	f800283a 	ret

20009168 <OSSchedLock>:
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
20009168:	d0e03443 	ldbu	r3,-32559(gp)
2000916c:	00800044 	movi	r2,1
20009170:	18800d1e 	bne	r3,r2,200091a8 <OSSchedLock+0x40>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009174:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009178:	00bfff84 	movi	r2,-2
2000917c:	1884703a 	and	r2,r3,r2
20009180:	1001703a 	wrctl	status,r2
        OS_ENTER_CRITICAL();
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
20009184:	d0a04203 	ldbu	r2,-32504(gp)
20009188:	1000061e 	bne	r2,zero,200091a4 <OSSchedLock+0x3c>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
2000918c:	d0a03403 	ldbu	r2,-32560(gp)
20009190:	01003fc4 	movi	r4,255
20009194:	11403fcc 	andi	r5,r2,255
20009198:	29000226 	beq	r5,r4,200091a4 <OSSchedLock+0x3c>
                OSLockNesting++;                 /* Increment lock nesting level                       */
2000919c:	10800044 	addi	r2,r2,1
200091a0:	d0a03405 	stb	r2,-32560(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200091a4:	1801703a 	wrctl	status,r3
200091a8:	f800283a 	ret

200091ac <OSStart>:
*********************************************************************************************************
*/

void  OSStart (void)
{
    if (OSRunning == OS_FALSE) {
200091ac:	d0a03443 	ldbu	r2,-32559(gp)
200091b0:	1000111e 	bne	r2,zero,200091f8 <OSStart+0x4c>
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
200091b4:	deffff04 	addi	sp,sp,-4
200091b8:	dfc00015 	stw	ra,0(sp)
    if (OSRunning == OS_FALSE) {
        OS_SchedNew();                               /* Find highest priority's task priority number   */
200091bc:	00090140 	call	20009014 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
200091c0:	d0a03603 	ldbu	r2,-32552(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
200091c4:	00c00034 	movhi	r3,0
200091c8:	18de0004 	addi	r3,r3,30720

void  OSStart (void)
{
    if (OSRunning == OS_FALSE) {
        OS_SchedNew();                               /* Find highest priority's task priority number   */
        OSPrioCur     = OSPrioHighRdy;
200091cc:	d0a03645 	stb	r2,-32551(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
200091d0:	10803fcc 	andi	r2,r2,255
200091d4:	1085883a 	add	r2,r2,r2
200091d8:	1085883a 	add	r2,r2,r2
200091dc:	1885883a 	add	r2,r3,r2
200091e0:	10800017 	ldw	r2,0(r2)
200091e4:	d0a03e15 	stw	r2,-32520(gp)
        OSTCBCur      = OSTCBHighRdy;
200091e8:	d0a04315 	stw	r2,-32500(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
    }
}
200091ec:	dfc00017 	ldw	ra,0(sp)
200091f0:	dec00104 	addi	sp,sp,4
    if (OSRunning == OS_FALSE) {
        OS_SchedNew();                               /* Find highest priority's task priority number   */
        OSPrioCur     = OSPrioHighRdy;
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
        OSTCBCur      = OSTCBHighRdy;
        OSStartHighRdy();                            /* Execute target specific code to start task     */
200091f4:	000e16c1 	jmpi	2000e16c <OSStartHighRdy>
200091f8:	f800283a 	ret

200091fc <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
200091fc:	defffe04 	addi	sp,sp,-8
    OS_CPU_SR  cpu_sr = 0;
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
20009200:	01000084 	movi	r4,2
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
20009204:	dfc00115 	stw	ra,4(sp)
20009208:	dc000015 	stw	r16,0(sp)
    OS_CPU_SR  cpu_sr = 0;
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
2000920c:	000ce280 	call	2000ce28 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009210:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009214:	043fff84 	movi	r16,-2
20009218:	1406703a 	and	r3,r2,r16
2000921c:	1801703a 	wrctl	status,r3
    OS_ENTER_CRITICAL();
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
20009220:	d0203515 	stw	zero,-32556(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009224:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
20009228:	01001904 	movi	r4,100
2000922c:	000ce280 	call	2000ce28 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009230:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009234:	1420703a 	and	r16,r2,r16
20009238:	8001703a 	wrctl	status,r16
    OS_ENTER_CRITICAL();
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
2000923c:	d0e03517 	ldw	r3,-32556(gp)
20009240:	d0e03a15 	stw	r3,-32536(gp)
    OSStatRdy    = OS_TRUE;
20009244:	00c00044 	movi	r3,1
20009248:	d0e04605 	stb	r3,-32488(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000924c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
20009250:	dfc00117 	ldw	ra,4(sp)
20009254:	dc000017 	ldw	r16,0(sp)
20009258:	dec00204 	addi	sp,sp,8
2000925c:	f800283a 	ret

20009260 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
20009260:	deffff04 	addi	sp,sp,-4
20009264:	dfc00015 	stw	ra,0(sp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
20009268:	000e2980 	call	2000e298 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000926c:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009270:	00bfff84 	movi	r2,-2
20009274:	1884703a 	and	r2,r3,r2
20009278:	1001703a 	wrctl	status,r2
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
    OSTime++;
2000927c:	d0a04417 	ldw	r2,-32496(gp)
20009280:	10800044 	addi	r2,r2,1
20009284:	d0a04415 	stw	r2,-32496(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009288:	1801703a 	wrctl	status,r3
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
2000928c:	d0a03443 	ldbu	r2,-32559(gp)
20009290:	00c00044 	movi	r3,1
20009294:	10c0321e 	bne	r2,r3,20009360 <OSTimeTick+0x100>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
20009298:	d0e03803 	ldbu	r3,-32544(gp)
2000929c:	18803026 	beq	r3,r2,20009360 <OSTimeTick+0x100>
200092a0:	18000526 	beq	r3,zero,200092b8 <OSTimeTick+0x58>
200092a4:	01000084 	movi	r4,2
200092a8:	1900021e 	bne	r3,r4,200092b4 <OSTimeTick+0x54>
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
                 break;

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
                 OSTickStepState = OS_TICK_STEP_WAIT;
200092ac:	d0a03805 	stb	r2,-32544(gp)
                 break;
200092b0:	00000106 	br	200092b8 <OSTimeTick+0x58>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
200092b4:	d0203805 	stb	zero,-32544(gp)
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
200092b8:	d0a03717 	ldw	r2,-32548(gp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
200092bc:	02800504 	movi	r10,20
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200092c0:	027fff84 	movi	r9,-2
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
200092c4:	d2204044 	addi	r8,gp,-32511
            OS_ENTER_CRITICAL();
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
200092c8:	01fff204 	movi	r7,-56
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
200092cc:	01800044 	movi	r6,1
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
200092d0:	10c00c83 	ldbu	r3,50(r2)
200092d4:	1a802226 	beq	r3,r10,20009360 <OSTimeTick+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
200092d8:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
200092dc:	2a46703a 	and	r3,r5,r9
200092e0:	1801703a 	wrctl	status,r3
            OS_ENTER_CRITICAL();
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
200092e4:	10c00b8b 	ldhu	r3,46(r2)
200092e8:	193fffcc 	andi	r4,r3,65535
200092ec:	20001926 	beq	r4,zero,20009354 <OSTimeTick+0xf4>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
200092f0:	18ffffc4 	addi	r3,r3,-1
200092f4:	10c00b8d 	sth	r3,46(r2)
200092f8:	18ffffcc 	andi	r3,r3,65535
200092fc:	1800151e 	bne	r3,zero,20009354 <OSTimeTick+0xf4>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
20009300:	10c00c03 	ldbu	r3,48(r2)
20009304:	19000dcc 	andi	r4,r3,55
20009308:	20000426 	beq	r4,zero,2000931c <OSTimeTick+0xbc>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
2000930c:	19c6703a 	and	r3,r3,r7
20009310:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
20009314:	11800c45 	stb	r6,49(r2)
20009318:	00000106 	br	20009320 <OSTimeTick+0xc0>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
2000931c:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
20009320:	10c00c03 	ldbu	r3,48(r2)
20009324:	18c0020c 	andi	r3,r3,8
20009328:	18000a1e 	bne	r3,zero,20009354 <OSTimeTick+0xf4>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
2000932c:	11000d83 	ldbu	r4,54(r2)
20009330:	d0e04003 	ldbu	r3,-32512(gp)
20009334:	20c6b03a 	or	r3,r4,r3
20009338:	d0e04005 	stb	r3,-32512(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
2000933c:	10c00d03 	ldbu	r3,52(r2)
20009340:	11000d43 	ldbu	r4,53(r2)
20009344:	40c7883a 	add	r3,r8,r3
20009348:	1ac00003 	ldbu	r11,0(r3)
2000934c:	5908b03a 	or	r4,r11,r4
20009350:	19000005 	stb	r4,0(r3)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
20009354:	10800517 	ldw	r2,20(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009358:	2801703a 	wrctl	status,r5
2000935c:	003fdc06 	br	200092d0 <OSTimeTick+0x70>
            OS_EXIT_CRITICAL();
        }
    }
}
20009360:	dfc00017 	ldw	ra,0(sp)
20009364:	dec00104 	addi	sp,sp,4
20009368:	f800283a 	ret

2000936c <OSVersion>:
*/

INT16U  OSVersion (void)
{
    return (OS_VERSION);
}
2000936c:	00804784 	movi	r2,286
20009370:	f800283a 	ret

20009374 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
20009374:	f800283a 	ret

20009378 <OS_EventTaskWait>:
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
20009378:	d0a04317 	ldw	r2,-32500(gp)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
2000937c:	10c00d03 	ldbu	r3,52(r2)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
20009380:	11000715 	stw	r4,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
20009384:	11400d43 	ldbu	r5,53(r2)
20009388:	20c7883a 	add	r3,r4,r3
2000938c:	198002c3 	ldbu	r6,11(r3)
20009390:	314ab03a 	or	r5,r6,r5
20009394:	194002c5 	stb	r5,11(r3)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
20009398:	11400d83 	ldbu	r5,54(r2)
2000939c:	20c00283 	ldbu	r3,10(r4)
200093a0:	28c6b03a 	or	r3,r5,r3
200093a4:	20c00285 	stb	r3,10(r4)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
200093a8:	10c00d03 	ldbu	r3,52(r2)
200093ac:	d1204044 	addi	r4,gp,-32511
200093b0:	20c9883a 	add	r4,r4,r3
200093b4:	10c00d43 	ldbu	r3,53(r2)
200093b8:	00ca303a 	nor	r5,zero,r3
200093bc:	20c00003 	ldbu	r3,0(r4)
200093c0:	28c6703a 	and	r3,r5,r3
200093c4:	20c00005 	stb	r3,0(r4)
    if (OSRdyTbl[y] == 0) {
200093c8:	18c03fcc 	andi	r3,r3,255
200093cc:	1800051e 	bne	r3,zero,200093e4 <OS_EventTaskWait+0x6c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
200093d0:	10800d83 	ldbu	r2,54(r2)
200093d4:	0086303a 	nor	r3,zero,r2
200093d8:	d0a04003 	ldbu	r2,-32512(gp)
200093dc:	1884703a 	and	r2,r3,r2
200093e0:	d0a04005 	stb	r2,-32512(gp)
200093e4:	f800283a 	ret

200093e8 <OS_EventTaskWaitMulti>:
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
200093e8:	d0e04317 	ldw	r3,-32500(gp)
200093ec:	18000715 	stw	zero,28(r3)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
200093f0:	19000815 	stw	r4,32(r3)
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
200093f4:	21800017 	ldw	r6,0(r4)
200093f8:	18800d03 	ldbu	r2,52(r3)
200093fc:	19400d43 	ldbu	r5,53(r3)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
20009400:	30000a26 	beq	r6,zero,2000942c <OS_EventTaskWaitMulti+0x44>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
20009404:	3085883a 	add	r2,r6,r2
20009408:	11c002c3 	ldbu	r7,11(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
2000940c:	21000104 	addi	r4,r4,4
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
20009410:	394ab03a 	or	r5,r7,r5
20009414:	114002c5 	stb	r5,11(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
20009418:	19400d83 	ldbu	r5,54(r3)
2000941c:	30800283 	ldbu	r2,10(r6)
20009420:	2884b03a 	or	r2,r5,r2
20009424:	30800285 	stb	r2,10(r6)
20009428:	003ff206 	br	200093f4 <OS_EventTaskWaitMulti+0xc>
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
2000942c:	d1204044 	addi	r4,gp,-32511
20009430:	2085883a 	add	r2,r4,r2
20009434:	11000003 	ldbu	r4,0(r2)
20009438:	014a303a 	nor	r5,zero,r5
2000943c:	2908703a 	and	r4,r5,r4
20009440:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
20009444:	21003fcc 	andi	r4,r4,255
20009448:	2000051e 	bne	r4,zero,20009460 <OS_EventTaskWaitMulti+0x78>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
2000944c:	18800d83 	ldbu	r2,54(r3)
20009450:	0086303a 	nor	r3,zero,r2
20009454:	d0a04003 	ldbu	r2,-32512(gp)
20009458:	1884703a 	and	r2,r3,r2
2000945c:	d0a04005 	stb	r2,-32512(gp)
20009460:	f800283a 	ret

20009464 <OS_EventTaskRemove>:
{
    INT8U  y;


    y                       =  ptcb->OSTCBY;
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
20009464:	20c00d03 	ldbu	r3,52(r4)
20009468:	20800d43 	ldbu	r2,53(r4)
2000946c:	28c7883a 	add	r3,r5,r3
20009470:	008c303a 	nor	r6,zero,r2
20009474:	188002c3 	ldbu	r2,11(r3)
20009478:	3084703a 	and	r2,r6,r2
2000947c:	188002c5 	stb	r2,11(r3)
    if (pevent->OSEventTbl[y] == 0) {
20009480:	10803fcc 	andi	r2,r2,255
20009484:	1000051e 	bne	r2,zero,2000949c <OS_EventTaskRemove+0x38>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
20009488:	20800d83 	ldbu	r2,54(r4)
2000948c:	0086303a 	nor	r3,zero,r2
20009490:	28800283 	ldbu	r2,10(r5)
20009494:	1884703a 	and	r2,r3,r2
20009498:	28800285 	stb	r2,10(r5)
2000949c:	f800283a 	ret

200094a0 <OS_EventTaskRemoveMulti>:
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
200094a0:	21c00d83 	ldbu	r7,54(r4)
    bitx    =  ptcb->OSTCBBitX;
200094a4:	21800d43 	ldbu	r6,53(r4)
    pevents =  pevents_multi;
    pevent  = *pevents;
200094a8:	28c00017 	ldw	r3,0(r5)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
        pevent->OSEventTbl[y]  &= ~bitx;
200094ac:	22000d03 	ldbu	r8,52(r4)
200094b0:	018c303a 	nor	r6,zero,r6
        if (pevent->OSEventTbl[y] == 0) {
            pevent->OSEventGrp &= ~bity;
200094b4:	01ce303a 	nor	r7,zero,r7
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
200094b8:	18000c26 	beq	r3,zero,200094ec <OS_EventTaskRemoveMulti+0x4c>
        pevent->OSEventTbl[y]  &= ~bitx;
200094bc:	1a09883a 	add	r4,r3,r8
200094c0:	208002c3 	ldbu	r2,11(r4)
200094c4:	3084703a 	and	r2,r6,r2
200094c8:	208002c5 	stb	r2,11(r4)
        if (pevent->OSEventTbl[y] == 0) {
200094cc:	10803fcc 	andi	r2,r2,255
200094d0:	1000031e 	bne	r2,zero,200094e0 <OS_EventTaskRemoveMulti+0x40>
            pevent->OSEventGrp &= ~bity;
200094d4:	18800283 	ldbu	r2,10(r3)
200094d8:	3884703a 	and	r2,r7,r2
200094dc:	18800285 	stb	r2,10(r3)
        }
        pevents++;
200094e0:	29400104 	addi	r5,r5,4
        pevent = *pevents;
200094e4:	28c00017 	ldw	r3,0(r5)
200094e8:	003ff306 	br	200094b8 <OS_EventTaskRemoveMulti+0x18>
    }
}
200094ec:	f800283a 	ret

200094f0 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
200094f0:	defffc04 	addi	sp,sp,-16
200094f4:	dc800215 	stw	r18,8(sp)
200094f8:	2025883a 	mov	r18,r4
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
200094fc:	90800283 	ldbu	r2,10(r18)
20009500:	01000034 	movhi	r4,0
20009504:	21001f84 	addi	r4,r4,126
20009508:	2085883a 	add	r2,r4,r2
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
2000950c:	dc400115 	stw	r17,4(sp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
20009510:	14400003 	ldbu	r17,0(r2)
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
20009514:	dc000015 	stw	r16,0(sp)
20009518:	dfc00315 	stw	ra,12(sp)
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
2000951c:	88803fcc 	andi	r2,r17,255
20009520:	9087883a 	add	r3,r18,r2
20009524:	18c002c3 	ldbu	r3,11(r3)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
20009528:	882290fa 	slli	r17,r17,3
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
2000952c:	018c303a 	nor	r6,zero,r6
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
20009530:	20c7883a 	add	r3,r4,r3
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
20009534:	18c00003 	ldbu	r3,0(r3)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
20009538:	01000034 	movhi	r4,0
2000953c:	211e0004 	addi	r4,r4,30720


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
20009540:	88e3883a 	add	r17,r17,r3
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
20009544:	88c03fcc 	andi	r3,r17,255
20009548:	18c7883a 	add	r3,r3,r3
2000954c:	18c7883a 	add	r3,r3,r3
20009550:	20c7883a 	add	r3,r4,r3
20009554:	1c000017 	ldw	r16,0(r3)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
20009558:	80c00c03 	ldbu	r3,48(r16)
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
2000955c:	80000b8d 	sth	zero,46(r16)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
20009560:	81400915 	stw	r5,36(r16)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
20009564:	30cc703a 	and	r6,r6,r3
20009568:	81800c05 	stb	r6,48(r16)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
2000956c:	81c00c45 	stb	r7,49(r16)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
20009570:	3180020c 	andi	r6,r6,8
20009574:	30000a1e 	bne	r6,zero,200095a0 <OS_EventTaskRdy+0xb0>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
20009578:	81000d83 	ldbu	r4,54(r16)
2000957c:	d0e04003 	ldbu	r3,-32512(gp)
20009580:	20c6b03a 	or	r3,r4,r3
20009584:	d0e04005 	stb	r3,-32512(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
20009588:	d0e04044 	addi	r3,gp,-32511
2000958c:	1885883a 	add	r2,r3,r2
20009590:	11000003 	ldbu	r4,0(r2)
20009594:	80c00d43 	ldbu	r3,53(r16)
20009598:	20c6b03a 	or	r3,r4,r3
2000959c:	10c00005 	stb	r3,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
200095a0:	900b883a 	mov	r5,r18
200095a4:	8009883a 	mov	r4,r16
200095a8:	00094640 	call	20009464 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
200095ac:	81400817 	ldw	r5,32(r16)
200095b0:	28000326 	beq	r5,zero,200095c0 <OS_EventTaskRdy+0xd0>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
200095b4:	8009883a 	mov	r4,r16
200095b8:	00094a00 	call	200094a0 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
200095bc:	84800715 	stw	r18,28(r16)
    }
#endif

    return (prio);
}
200095c0:	8805883a 	mov	r2,r17
200095c4:	dfc00317 	ldw	ra,12(sp)
200095c8:	dc800217 	ldw	r18,8(sp)
200095cc:	dc400117 	ldw	r17,4(sp)
200095d0:	dc000017 	ldw	r16,0(sp)
200095d4:	dec00404 	addi	sp,sp,16
200095d8:	f800283a 	ret

200095dc <OS_EventWaitListInit>:
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
200095dc:	20000285 	stb	zero,10(r4)
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *ptbl++ = 0;
200095e0:	200002c5 	stb	zero,11(r4)
200095e4:	20000305 	stb	zero,12(r4)
200095e8:	20000345 	stb	zero,13(r4)
200095ec:	f800283a 	ret

200095f0 <OS_MemClr>:
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
200095f0:	28bfffcc 	andi	r2,r5,65535
200095f4:	10000426 	beq	r2,zero,20009608 <OS_MemClr+0x18>
        *pdest++ = (INT8U)0;
200095f8:	20000005 	stb	zero,0(r4)
        size--;
200095fc:	297fffc4 	addi	r5,r5,-1
20009600:	21000044 	addi	r4,r4,1
20009604:	003ffa06 	br	200095f0 <OS_MemClr>
    }
}
20009608:	f800283a 	ret

2000960c <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
2000960c:	defff704 	addi	sp,sp,-36
20009610:	dfc00815 	stw	ra,32(sp)
20009614:	dc400715 	stw	r17,28(sp)
20009618:	dc000615 	stw	r16,24(sp)
    OSInitHookBegin();                                           /* Call port specific initialization code   */
2000961c:	000e29c0 	call	2000e29c <OSInitHookBegin>


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
        *prdytbl++ = 0;
20009620:	d0a04044 	addi	r2,gp,-32511
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
20009624:	01000034 	movhi	r4,0


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
        *prdytbl++ = 0;
20009628:	10000045 	stb	zero,1(r2)
2000962c:	10000085 	stb	zero,2(r2)
*/

static  void  OS_InitMisc (void)
{
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
20009630:	d0204415 	stw	zero,-32496(gp)
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
20009634:	211cbc04 	addi	r4,r4,29424
20009638:	01414404 	movi	r5,1296
{
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
2000963c:	d0204205 	stb	zero,-32504(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
20009640:	d0203405 	stb	zero,-32560(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
20009644:	d0203c45 	stb	zero,-32527(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
20009648:	d0203445 	stb	zero,-32559(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
2000964c:	d0203915 	stw	zero,-32540(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
20009650:	d0203515 	stw	zero,-32556(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
20009654:	d0204715 	stw	zero,-32484(gp)
    OSIdleCtrMax  = 0L;
20009658:	d0203a15 	stw	zero,-32536(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
2000965c:	d0204605 	stb	zero,-32488(gp)
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
20009660:	d0204005 	stb	zero,-32512(gp)
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
        *prdytbl++ = 0;
20009664:	d0204045 	stb	zero,-32511(gp)
    }

    OSPrioCur     = 0;
20009668:	d0203645 	stb	zero,-32551(gp)
    OSPrioHighRdy = 0;
2000966c:	d0203605 	stb	zero,-32552(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
20009670:	d0203e15 	stw	zero,-32520(gp)
    OSTCBCur      = (OS_TCB *)0;
20009674:	d0204315 	stw	zero,-32500(gp)
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
20009678:	00095f00 	call	200095f0 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
2000967c:	01000034 	movhi	r4,0
20009680:	211e0004 	addi	r4,r4,30720
20009684:	01401504 	movi	r5,84
20009688:	00095f00 	call	200095f0 <OS_MemClr>
2000968c:	00800034 	movhi	r2,0
20009690:	109cc104 	addi	r2,r2,29444
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
20009694:	0009883a 	mov	r4,zero
        ptcb1->OSTCBNext = ptcb2;
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
20009698:	01800fc4 	movi	r6,63

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
2000969c:	014002c4 	movi	r5,11
200096a0:	10c01604 	addi	r3,r2,88
        ptcb1->OSTCBNext = ptcb2;
200096a4:	10c00015 	stw	r3,0(r2)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
200096a8:	20c00044 	addi	r3,r4,1
        ptcb1->OSTCBNext = ptcb2;
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
200096ac:	11800e05 	stb	r6,56(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
200096b0:	10000e45 	stb	zero,57(r2)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
200096b4:	1809883a 	mov	r4,r3
200096b8:	18c03fcc 	andi	r3,r3,255
        ptcb1->OSTCBNext = ptcb2;
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
200096bc:	04000fc4 	movi	r16,63
200096c0:	10801b04 	addi	r2,r2,108

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
200096c4:	197ff61e 	bne	r3,r5,200096a0 <OSInit+0x94>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
200096c8:	00800034 	movhi	r2,0
200096cc:	109cbc04 	addi	r2,r2,29424
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
200096d0:	01000034 	movhi	r4,0
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
200096d4:	10012e15 	stw	zero,1208(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
200096d8:	14013c05 	stb	r16,1264(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
200096dc:	10013c45 	stb	zero,1265(r2)
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
200096e0:	2119ec04 	addi	r4,r4,26544
200096e4:	0142d004 	movi	r5,2880
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
    OSTCBFreeList           = &OSTCBTbl[0];
200096e8:	d0a03b15 	stw	r2,-32532(gp)
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
200096ec:	d0203715 	stw	zero,-32548(gp)
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
200096f0:	00095f00 	call	200095f0 <OS_MemClr>
200096f4:	00c00034 	movhi	r3,0
200096f8:	18d9ed04 	addi	r3,r3,26548
200096fc:	0005883a 	mov	r2,zero
20009700:	19bfff04 	addi	r6,r3,-4
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
20009704:	01c2c404 	movi	r7,2832
20009708:	11400c04 	addi	r5,r2,48
2000970c:	1185883a 	add	r2,r2,r6
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
20009710:	10000005 	stb	zero,0(r2)
20009714:	2985883a 	add	r2,r5,r6
        pevent1->OSEventPtr     = pevent2;
20009718:	18800015 	stw	r2,0(r3)
2000971c:	01000034 	movhi	r4,0
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
20009720:	1c000285 	stb	r16,10(r3)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
20009724:	180002c5 	stb	zero,11(r3)
20009728:	2119ec04 	addi	r4,r4,26544
2000972c:	18c00c04 	addi	r3,r3,48
20009730:	2805883a 	mov	r2,r5


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
20009734:	29fff41e 	bne	r5,r7,20009708 <OSInit+0xfc>
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
    pevent1->OSEventPtr             = (OS_EVENT *)0;
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
20009738:	00800fc4 	movi	r2,63
2000973c:	2082c785 	stb	r2,2846(r4)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
20009740:	2002c405 	stb	zero,2832(r4)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
20009744:	2002c515 	stw	zero,2836(r4)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
20009748:	2002c7c5 	stb	zero,2847(r4)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
2000974c:	d1204115 	stw	r4,-32508(gp)
    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
20009750:	000a5100 	call	2000a510 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
20009754:	000af480 	call	2000af48 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
20009758:	000b9480 	call	2000b948 <OS_QInit>
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
2000975c:	01800034 	movhi	r6,0
20009760:	04408004 	movi	r17,512
20009764:	040000c4 	movi	r16,3
20009768:	00bfffd4 	movui	r2,65535
2000976c:	3197ec04 	addi	r6,r6,24496
20009770:	01080074 	movhi	r4,8193
20009774:	d9800115 	stw	r6,4(sp)
20009778:	01c00504 	movi	r7,20
2000977c:	d8800015 	stw	r2,0(sp)
20009780:	dc400215 	stw	r17,8(sp)
20009784:	d8000315 	stw	zero,12(sp)
20009788:	dc000415 	stw	r16,16(sp)
2000978c:	21241404 	addi	r4,r4,-28592
20009790:	000b883a 	mov	r5,zero
20009794:	3181ff04 	addi	r6,r6,2044
20009798:	000ccac0 	call	2000ccac <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
2000979c:	01000504 	movi	r4,20
200097a0:	01400034 	movhi	r5,0
200097a4:	d90d883a 	add	r6,sp,r4
200097a8:	29401804 	addi	r5,r5,96
200097ac:	000c7480 	call	2000c748 <OSTaskNameSet>
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
200097b0:	01800034 	movhi	r6,0
200097b4:	00bfff94 	movui	r2,65534
200097b8:	31957404 	addi	r6,r6,21968
200097bc:	01080074 	movhi	r4,8193
200097c0:	01c004c4 	movi	r7,19
200097c4:	d9800115 	stw	r6,4(sp)
200097c8:	d8800015 	stw	r2,0(sp)
200097cc:	dc400215 	stw	r17,8(sp)
200097d0:	d8000315 	stw	zero,12(sp)
200097d4:	dc000415 	stw	r16,16(sp)
200097d8:	2127ab04 	addi	r4,r4,-24916
200097dc:	000b883a 	mov	r5,zero
200097e0:	3181ff04 	addi	r6,r6,2044
200097e4:	000ccac0 	call	2000ccac <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
200097e8:	01400034 	movhi	r5,0
200097ec:	010004c4 	movi	r4,19
200097f0:	29401c04 	addi	r5,r5,112
200097f4:	d9800504 	addi	r6,sp,20
200097f8:	000c7480 	call	2000c748 <OSTaskNameSet>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
200097fc:	000e2a00 	call	2000e2a0 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
20009800:	000a0b00 	call	2000a0b0 <OSDebugInit>
#endif
}
20009804:	dfc00817 	ldw	ra,32(sp)
20009808:	dc400717 	ldw	r17,28(sp)
2000980c:	dc000617 	ldw	r16,24(sp)
20009810:	dec00904 	addi	sp,sp,36
20009814:	f800283a 	ret

20009818 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
20009818:	31bfffcc 	andi	r6,r6,65535
    while (size > 0) {
2000981c:	0005883a 	mov	r2,zero
20009820:	11800626 	beq	r2,r6,2000983c <OS_MemCopy+0x24>
20009824:	2887883a 	add	r3,r5,r2
        *pdest++ = *psrc++;
20009828:	19c00003 	ldbu	r7,0(r3)
2000982c:	2087883a 	add	r3,r4,r2
20009830:	10800044 	addi	r2,r2,1
20009834:	19c00005 	stb	r7,0(r3)
20009838:	003ff906 	br	20009820 <OS_MemCopy+0x8>
        size--;
    }
}
2000983c:	f800283a 	ret

20009840 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
20009840:	defffe04 	addi	sp,sp,-8
20009844:	dfc00115 	stw	ra,4(sp)
20009848:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000984c:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009850:	00bfff84 	movi	r2,-2
20009854:	8084703a 	and	r2,r16,r2
20009858:	1001703a 	wrctl	status,r2
#endif



    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
2000985c:	d0a04203 	ldbu	r2,-32504(gp)
20009860:	1000141e 	bne	r2,zero,200098b4 <OS_Sched+0x74>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
20009864:	d0a03403 	ldbu	r2,-32560(gp)
20009868:	1000121e 	bne	r2,zero,200098b4 <OS_Sched+0x74>
            OS_SchedNew();
2000986c:	00090140 	call	20009014 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
20009870:	d0a03603 	ldbu	r2,-32552(gp)
20009874:	d0e03643 	ldbu	r3,-32551(gp)
20009878:	10c00e26 	beq	r2,r3,200098b4 <OS_Sched+0x74>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
2000987c:	1085883a 	add	r2,r2,r2
20009880:	00c00034 	movhi	r3,0
20009884:	18de0004 	addi	r3,r3,30720
20009888:	1085883a 	add	r2,r2,r2
2000988c:	1885883a 	add	r2,r3,r2
20009890:	10800017 	ldw	r2,0(r2)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
20009894:	10c00e17 	ldw	r3,56(r2)
    OS_ENTER_CRITICAL();
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
            OS_SchedNew();
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
20009898:	d0a03e15 	stw	r2,-32520(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
2000989c:	18c00044 	addi	r3,r3,1
200098a0:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
200098a4:	d0a03917 	ldw	r2,-32540(gp)
200098a8:	10800044 	addi	r2,r2,1
200098ac:	d0a03915 	stw	r2,-32540(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
200098b0:	000e0e00 	call	2000e0e0 <OSCtxSw>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
200098b4:	8001703a 	wrctl	status,r16
            }
        }
    }
    OS_EXIT_CRITICAL();
}
200098b8:	dfc00117 	ldw	ra,4(sp)
200098bc:	dc000017 	ldw	r16,0(sp)
200098c0:	dec00204 	addi	sp,sp,8
200098c4:	f800283a 	ret

200098c8 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
200098c8:	defff604 	addi	sp,sp,-40
200098cc:	dd000415 	stw	r20,16(sp)
200098d0:	dd000a17 	ldw	r20,40(sp)
200098d4:	dfc00915 	stw	ra,36(sp)
200098d8:	df000815 	stw	fp,32(sp)
200098dc:	ddc00715 	stw	r23,28(sp)
200098e0:	dd800615 	stw	r22,24(sp)
200098e4:	dd400515 	stw	r21,20(sp)
200098e8:	dcc00315 	stw	r19,12(sp)
200098ec:	dc800215 	stw	r18,8(sp)
200098f0:	dc400115 	stw	r17,4(sp)
200098f4:	dc000015 	stw	r16,0(sp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
200098f8:	a000b426 	beq	r20,zero,20009bcc <OSEventPendMulti+0x304>
200098fc:	202d883a 	mov	r22,r4
        return (0);
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
20009900:	2000021e 	bne	r4,zero,2000990c <OSEventPendMulti+0x44>
       *perr =  OS_ERR_PEVENT_NULL;
20009904:	00800104 	movi	r2,4
20009908:	00001906 	br	20009970 <OSEventPendMulti+0xa8>
2000990c:	2821883a 	mov	r16,r5
        return (0);
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
20009910:	283ffc26 	beq	r5,zero,20009904 <OSEventPendMulti+0x3c>
20009914:	3025883a 	mov	r18,r6
       *perr =  OS_ERR_PEVENT_NULL;
        return (0);
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
20009918:	303ffa26 	beq	r6,zero,20009904 <OSEventPendMulti+0x3c>
       *perr =  OS_ERR_PEVENT_NULL;
        return (0);
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
2000991c:	28000015 	stw	zero,0(r5)

    pevents     =  pevents_pend;
    pevent      = *pevents;
20009920:	20800017 	ldw	r2,0(r4)
    while  (pevent != (OS_EVENT *)0) {
20009924:	2007883a 	mov	r3,r4
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
20009928:	01000084 	movi	r4,2
2000992c:	1023883a 	mov	r17,r2

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
20009930:	10000826 	beq	r2,zero,20009954 <OSEventPendMulti+0x8c>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
20009934:	10800003 	ldbu	r2,0(r2)
20009938:	10bfffc4 	addi	r2,r2,-1
2000993c:	2080022e 	bgeu	r4,r2,20009948 <OSEventPendMulti+0x80>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
20009940:	00800044 	movi	r2,1
20009944:	00000a06 	br	20009970 <OSEventPendMulti+0xa8>
                 return (0);
        }
        pevents++;
20009948:	18c00104 	addi	r3,r3,4
        pevent = *pevents;
2000994c:	18800017 	ldw	r2,0(r3)
20009950:	003ff706 	br	20009930 <OSEventPendMulti+0x68>
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
20009954:	d0a04203 	ldbu	r2,-32504(gp)
20009958:	10000226 	beq	r2,zero,20009964 <OSEventPendMulti+0x9c>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
2000995c:	00800084 	movi	r2,2
20009960:	00000306 	br	20009970 <OSEventPendMulti+0xa8>
        return (0);
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
20009964:	d0a03403 	ldbu	r2,-32560(gp)
20009968:	10000326 	beq	r2,zero,20009978 <OSEventPendMulti+0xb0>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
2000996c:	00800344 	movi	r2,13
20009970:	a0800005 	stb	r2,0(r20)
20009974:	00009506 	br	20009bcc <OSEventPendMulti+0x304>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009978:	002f303a 	rdctl	r23,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000997c:	00bfff84 	movi	r2,-2
20009980:	b884703a 	and	r2,r23,r2
20009984:	1001703a 	wrctl	status,r2
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
20009988:	b00d883a 	mov	r6,r22

/*$PAGE*/
    OS_ENTER_CRITICAL();
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
2000998c:	0005883a 	mov	r2,zero
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
20009990:	002b883a 	mov	r21,zero
        return (0);
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
    events_rdy     =  OS_FALSE;
20009994:	0009883a 	mov	r4,zero
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
        switch (pevent->OSEventType) {
20009998:	02400084 	movi	r9,2
2000999c:	028000c4 	movi	r10,3
200099a0:	02000044 	movi	r8,1
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
200099a4:	88003a26 	beq	r17,zero,20009a90 <OSEventPendMulti+0x1c8>
        switch (pevent->OSEventType) {
200099a8:	88c00003 	ldbu	r3,0(r17)
200099ac:	1a401926 	beq	r3,r9,20009a14 <OSEventPendMulti+0x14c>
200099b0:	1a800226 	beq	r3,r10,200099bc <OSEventPendMulti+0xf4>
200099b4:	1a002e1e 	bne	r3,r8,20009a70 <OSEventPendMulti+0x1a8>
200099b8:	00000e06 	br	200099f4 <OSEventPendMulti+0x12c>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
200099bc:	88c0020b 	ldhu	r3,8(r17)
200099c0:	197fffcc 	andi	r5,r3,65535
200099c4:	28000926 	beq	r5,zero,200099ec <OSEventPendMulti+0x124>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
200099c8:	18ffffc4 	addi	r3,r3,-1
200099cc:	88c0020d 	sth	r3,8(r17)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
200099d0:	84400015 	stw	r17,0(r16)
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
200099d4:	90000015 	stw	zero,0(r18)
                      events_rdy_nbr++;
200099d8:	ad400044 	addi	r21,r21,1
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
200099dc:	94800104 	addi	r18,r18,4
        switch (pevent->OSEventType) {
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
200099e0:	84000104 	addi	r16,r16,4
                      events_rdy   =  OS_TRUE;
200099e4:	01000044 	movi	r4,1
200099e8:	00002606 	br	20009a84 <OSEventPendMulti+0x1bc>
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
200099ec:	10800054 	ori	r2,r2,1
200099f0:	00002406 	br	20009a84 <OSEventPendMulti+0x1bc>
                 break;
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
200099f4:	88c00117 	ldw	r3,4(r17)
200099f8:	18000426 	beq	r3,zero,20009a0c <OSEventPendMulti+0x144>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
200099fc:	90c00015 	stw	r3,0(r18)
                     pevent->OSEventPtr  = (void *)0;
20009a00:	88000115 	stw	zero,4(r17)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
20009a04:	84400015 	stw	r17,0(r16)
20009a08:	003ff306 	br	200099d8 <OSEventPendMulti+0x110>
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
20009a0c:	10800094 	ori	r2,r2,2
20009a10:	00001c06 	br	20009a84 <OSEventPendMulti+0x1bc>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
20009a14:	88c00117 	ldw	r3,4(r17)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
20009a18:	1940058b 	ldhu	r5,22(r3)
20009a1c:	2affffcc 	andi	r11,r5,65535
20009a20:	58001126 	beq	r11,zero,20009a68 <OSEventPendMulti+0x1a0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
20009a24:	19000417 	ldw	r4,16(r3)
20009a28:	92c00104 	addi	r11,r18,4
20009a2c:	23000104 	addi	r12,r4,4
20009a30:	1b000415 	stw	r12,16(r3)
20009a34:	21000017 	ldw	r4,0(r4)
20009a38:	91000015 	stw	r4,0(r18)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
20009a3c:	1b000417 	ldw	r12,16(r3)
20009a40:	19000217 	ldw	r4,8(r3)
20009a44:	6100021e 	bne	r12,r4,20009a50 <OSEventPendMulti+0x188>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
20009a48:	19000117 	ldw	r4,4(r3)
20009a4c:	19000415 	stw	r4,16(r3)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
20009a50:	297fffc4 	addi	r5,r5,-1
20009a54:	1940058d 	sth	r5,22(r3)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
20009a58:	84400015 	stw	r17,0(r16)
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;
20009a5c:	ad400044 	addi	r21,r21,1
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
20009a60:	5825883a 	mov	r18,r11
20009a64:	003fde06 	br	200099e0 <OSEventPendMulti+0x118>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
20009a68:	10800114 	ori	r2,r2,4
20009a6c:	00000506 	br	20009a84 <OSEventPendMulti+0x1bc>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009a70:	b801703a 	wrctl	status,r23

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
20009a74:	80000015 	stw	zero,0(r16)
                *perr        =  OS_ERR_EVENT_TYPE;
20009a78:	00800044 	movi	r2,1
20009a7c:	a0800005 	stb	r2,0(r20)
20009a80:	00000a06 	br	20009aac <OSEventPendMulti+0x1e4>
                 return (events_rdy_nbr);
        }
        pevents++;
20009a84:	31800104 	addi	r6,r6,4
        pevent = *pevents;
20009a88:	34400017 	ldw	r17,0(r6)
20009a8c:	003fc506 	br	200099a4 <OSEventPendMulti+0xdc>
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
20009a90:	21003fcc 	andi	r4,r4,255
20009a94:	a827883a 	mov	r19,r21
20009a98:	8039883a 	mov	fp,r16
20009a9c:	20000526 	beq	r4,zero,20009ab4 <OSEventPendMulti+0x1ec>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
20009aa0:	80000015 	stw	zero,0(r16)
20009aa4:	b801703a 	wrctl	status,r23
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
20009aa8:	a0000005 	stb	zero,0(r20)
        return (events_rdy_nbr);
20009aac:	a805883a 	mov	r2,r21
20009ab0:	00004706 	br	20009bd0 <OSEventPendMulti+0x308>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
20009ab4:	d0e04317 	ldw	r3,-32500(gp)
20009ab8:	013fe004 	movi	r4,-128
20009abc:	19400c03 	ldbu	r5,48(r3)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
20009ac0:	18000c45 	stb	zero,49(r3)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
20009ac4:	19c00b8d 	sth	r7,46(r3)
20009ac8:	2908b03a 	or	r4,r5,r4
       *perr        =  OS_ERR_NONE;
        return (events_rdy_nbr);
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
20009acc:	2084b03a 	or	r2,r4,r2
20009ad0:	18800c05 	stb	r2,48(r3)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
20009ad4:	b009883a 	mov	r4,r22
20009ad8:	00093e80 	call	200093e8 <OS_EventTaskWaitMulti>
20009adc:	b801703a 	wrctl	status,r23

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
20009ae0:	00098400 	call	20009840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009ae4:	002f303a 	rdctl	r23,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009ae8:	00bfff84 	movi	r2,-2
20009aec:	b884703a 	and	r2,r23,r2
20009af0:	1001703a 	wrctl	status,r2
    OS_ENTER_CRITICAL();

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
20009af4:	d1204317 	ldw	r4,-32500(gp)
20009af8:	20800c43 	ldbu	r2,49(r4)
20009afc:	10000226 	beq	r2,zero,20009b08 <OSEventPendMulti+0x240>
20009b00:	00c00084 	movi	r3,2
20009b04:	10c0091e 	bne	r2,r3,20009b2c <OSEventPendMulti+0x264>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
20009b08:	24400717 	ldw	r17,28(r4)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
20009b0c:	88000526 	beq	r17,zero,20009b24 <OSEventPendMulti+0x25c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
20009b10:	84000104 	addi	r16,r16,4
20009b14:	e4400015 	stw	r17,0(fp)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
20009b18:	e0000115 	stw	zero,4(fp)
                  events_rdy_nbr++;
20009b1c:	acc00044 	addi	r19,r21,1
20009b20:	00000406 	br	20009b34 <OSEventPendMulti+0x26c>

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
20009b24:	00800044 	movi	r2,1
20009b28:	20800c45 	stb	r2,49(r4)
             }
			 break;

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
20009b2c:	b00b883a 	mov	r5,r22
20009b30:	00094a00 	call	200094a0 <OS_EventTaskRemoveMulti>
             break;
    }

    switch (OSTCBCur->OSTCBStatPend) {
20009b34:	d0e04317 	ldw	r3,-32500(gp)
20009b38:	18800c43 	ldbu	r2,49(r3)
20009b3c:	10000526 	beq	r2,zero,20009b54 <OSEventPendMulti+0x28c>
20009b40:	00c00084 	movi	r3,2
20009b44:	10c0151e 	bne	r2,r3,20009b9c <OSEventPendMulti+0x2d4>
             }
            *perr = OS_ERR_NONE;
             break;

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
20009b48:	90000015 	stw	zero,0(r18)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
20009b4c:	00800384 	movi	r2,14
20009b50:	00001406 	br	20009ba4 <OSEventPendMulti+0x2dc>
             break;
    }

    switch (OSTCBCur->OSTCBStatPend) {
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
20009b54:	88800003 	ldbu	r2,0(r17)
20009b58:	10000926 	beq	r2,zero,20009b80 <OSEventPendMulti+0x2b8>
20009b5c:	01000084 	movi	r4,2
20009b60:	2080042e 	bgeu	r4,r2,20009b74 <OSEventPendMulti+0x2ac>
20009b64:	00c000c4 	movi	r3,3
20009b68:	10c0051e 	bne	r2,r3,20009b80 <OSEventPendMulti+0x2b8>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
20009b6c:	90000015 	stw	zero,0(r18)
                      break;
20009b70:	00000806 	br	20009b94 <OSEventPendMulti+0x2cc>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
20009b74:	18800917 	ldw	r2,36(r3)
20009b78:	90800015 	stw	r2,0(r18)
                      break;
20009b7c:	00000506 	br	20009b94 <OSEventPendMulti+0x2cc>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009b80:	b801703a 	wrctl	status,r23

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
20009b84:	80000015 	stw	zero,0(r16)
                     *perr        =  OS_ERR_EVENT_TYPE;
20009b88:	00800044 	movi	r2,1
20009b8c:	a0800005 	stb	r2,0(r20)
20009b90:	00000c06 	br	20009bc4 <OSEventPendMulti+0x2fc>
                      return (events_rdy_nbr);
             }
            *perr = OS_ERR_NONE;
20009b94:	a0000005 	stb	zero,0(r20)
             break;
20009b98:	00000306 	br	20009ba8 <OSEventPendMulti+0x2e0>
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
             break;
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
20009b9c:	90000015 	stw	zero,0(r18)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
20009ba0:	00800284 	movi	r2,10
20009ba4:	a0800005 	stb	r2,0(r20)
             break;
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
20009ba8:	d0a04317 	ldw	r2,-32500(gp)
20009bac:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
20009bb0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
20009bb4:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
20009bb8:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
20009bbc:	10000915 	stw	zero,36(r2)
20009bc0:	b801703a 	wrctl	status,r23
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
20009bc4:	9805883a 	mov	r2,r19
20009bc8:	00000106 	br	20009bd0 <OSEventPendMulti+0x308>



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
        return (0);
20009bcc:	0005883a 	mov	r2,zero
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
}
20009bd0:	dfc00917 	ldw	ra,36(sp)
20009bd4:	df000817 	ldw	fp,32(sp)
20009bd8:	ddc00717 	ldw	r23,28(sp)
20009bdc:	dd800617 	ldw	r22,24(sp)
20009be0:	dd400517 	ldw	r21,20(sp)
20009be4:	dd000417 	ldw	r20,16(sp)
20009be8:	dcc00317 	ldw	r19,12(sp)
20009bec:	dc800217 	ldw	r18,8(sp)
20009bf0:	dc400117 	ldw	r17,4(sp)
20009bf4:	dc000017 	ldw	r16,0(sp)
20009bf8:	dec00a04 	addi	sp,sp,40
20009bfc:	f800283a 	ret

20009c00 <OSSchedUnlock>:
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
20009c00:	d0e03443 	ldbu	r3,-32559(gp)
20009c04:	00800044 	movi	r2,1
20009c08:	1880101e 	bne	r3,r2,20009c4c <OSSchedUnlock+0x4c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009c0c:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009c10:	00bfff84 	movi	r2,-2
20009c14:	1884703a 	and	r2,r3,r2
20009c18:	1001703a 	wrctl	status,r2
        OS_ENTER_CRITICAL();
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
20009c1c:	d0a03403 	ldbu	r2,-32560(gp)
20009c20:	11003fcc 	andi	r4,r2,255
20009c24:	20000826 	beq	r4,zero,20009c48 <OSSchedUnlock+0x48>
            OSLockNesting--;                               /* Decrement lock nesting level             */
20009c28:	10bfffc4 	addi	r2,r2,-1
20009c2c:	d0a03405 	stb	r2,-32560(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
20009c30:	10803fcc 	andi	r2,r2,255
20009c34:	1000041e 	bne	r2,zero,20009c48 <OSSchedUnlock+0x48>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
20009c38:	d0a04203 	ldbu	r2,-32504(gp)
20009c3c:	1000021e 	bne	r2,zero,20009c48 <OSSchedUnlock+0x48>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009c40:	1801703a 	wrctl	status,r3
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
20009c44:	00098401 	jmpi	20009840 <OS_Sched>
20009c48:	1801703a 	wrctl	status,r3
20009c4c:	f800283a 	ret

20009c50 <OS_StrCopy>:
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
20009c50:	2007883a 	mov	r3,r4
20009c54:	29800003 	ldbu	r6,0(r5)
20009c58:	1905c83a 	sub	r2,r3,r4
20009c5c:	31c03fcc 	andi	r7,r6,255
20009c60:	38000426 	beq	r7,zero,20009c74 <OS_StrCopy+0x24>
        *pdest++ = *psrc++;
20009c64:	19800005 	stb	r6,0(r3)
20009c68:	29400044 	addi	r5,r5,1
20009c6c:	18c00044 	addi	r3,r3,1
20009c70:	003ff806 	br	20009c54 <OS_StrCopy+0x4>
        len++;
    }
    *pdest = OS_ASCII_NUL;
20009c74:	18000005 	stb	zero,0(r3)
    return (len);
}
20009c78:	f800283a 	ret

20009c7c <OSEventNameGet>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
20009c7c:	30002726 	beq	r6,zero,20009d1c <OSEventNameGet+0xa0>
20009c80:	2007883a 	mov	r3,r4
        return (0);
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
20009c84:	2000021e 	bne	r4,zero,20009c90 <OSEventNameGet+0x14>
        *perr = OS_ERR_PEVENT_NULL;
20009c88:	00800104 	movi	r2,4
20009c8c:	00000206 	br	20009c98 <OSEventNameGet+0x1c>
        return (0);
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
20009c90:	2800031e 	bne	r5,zero,20009ca0 <OSEventNameGet+0x24>
        *perr = OS_ERR_PNAME_NULL;
20009c94:	00800304 	movi	r2,12
20009c98:	30800005 	stb	r2,0(r6)
20009c9c:	00001f06 	br	20009d1c <OSEventNameGet+0xa0>
        return (0);
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
20009ca0:	d0a04203 	ldbu	r2,-32504(gp)
20009ca4:	11003fcc 	andi	r4,r2,255
20009ca8:	20000226 	beq	r4,zero,20009cb4 <OSEventNameGet+0x38>
        *perr  = OS_ERR_NAME_GET_ISR;
20009cac:	00800444 	movi	r2,17
20009cb0:	003ff906 	br	20009c98 <OSEventNameGet+0x1c>
        return (0);
    }
    switch (pevent->OSEventType) {
20009cb4:	19000003 	ldbu	r4,0(r3)
20009cb8:	01c000c4 	movi	r7,3
20009cbc:	213fffc4 	addi	r4,r4,-1
20009cc0:	3900032e 	bgeu	r7,r4,20009cd0 <OSEventNameGet+0x54>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
20009cc4:	00c00044 	movi	r3,1
20009cc8:	30c00005 	stb	r3,0(r6)
             return (0);
20009ccc:	f800283a 	ret
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
20009cd0:	defffd04 	addi	sp,sp,-12
20009cd4:	dc000015 	stw	r16,0(sp)
20009cd8:	2809883a 	mov	r4,r5
20009cdc:	3021883a 	mov	r16,r6
20009ce0:	dfc00215 	stw	ra,8(sp)
20009ce4:	dc400115 	stw	r17,4(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009ce8:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009cec:	00bfff84 	movi	r2,-2
20009cf0:	8884703a 	and	r2,r17,r2
20009cf4:	1001703a 	wrctl	status,r2
        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
20009cf8:	19400384 	addi	r5,r3,14
20009cfc:	0009c500 	call	20009c50 <OS_StrCopy>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009d00:	8801703a 	wrctl	status,r17
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
20009d04:	80000005 	stb	zero,0(r16)
    return (len);
}
20009d08:	dfc00217 	ldw	ra,8(sp)
20009d0c:	dc400117 	ldw	r17,4(sp)
20009d10:	dc000017 	ldw	r16,0(sp)
20009d14:	dec00304 	addi	sp,sp,12
20009d18:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return (0);
20009d1c:	0005883a 	mov	r2,zero
20009d20:	f800283a 	ret

20009d24 <OS_StrLen>:
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
20009d24:	2007883a 	mov	r3,r4
20009d28:	19400003 	ldbu	r5,0(r3)
20009d2c:	1905c83a 	sub	r2,r3,r4
20009d30:	28000226 	beq	r5,zero,20009d3c <OS_StrLen+0x18>
        psrc++;
20009d34:	18c00044 	addi	r3,r3,1
20009d38:	003ffb06 	br	20009d28 <OS_StrLen+0x4>
        len++;
    }
    return (len);
}
20009d3c:	f800283a 	ret

20009d40 <OSEventNameSet>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
20009d40:	30003226 	beq	r6,zero,20009e0c <OSEventNameSet+0xcc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
20009d44:	2000021e 	bne	r4,zero,20009d50 <OSEventNameSet+0x10>
        *perr = OS_ERR_PEVENT_NULL;
20009d48:	00800104 	movi	r2,4
20009d4c:	00000c06 	br	20009d80 <OSEventNameSet+0x40>
        return;
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
20009d50:	2800021e 	bne	r5,zero,20009d5c <OSEventNameSet+0x1c>
        *perr = OS_ERR_PNAME_NULL;
20009d54:	00800304 	movi	r2,12
20009d58:	00000906 	br	20009d80 <OSEventNameSet+0x40>
        return;
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
20009d5c:	d0a04203 	ldbu	r2,-32504(gp)
20009d60:	10000226 	beq	r2,zero,20009d6c <OSEventNameSet+0x2c>
        *perr = OS_ERR_NAME_SET_ISR;
20009d64:	00800484 	movi	r2,18
20009d68:	00000506 	br	20009d80 <OSEventNameSet+0x40>
        return;
    }
    switch (pevent->OSEventType) {
20009d6c:	20800003 	ldbu	r2,0(r4)
20009d70:	00c000c4 	movi	r3,3
20009d74:	10bfffc4 	addi	r2,r2,-1
20009d78:	1880032e 	bgeu	r3,r2,20009d88 <OSEventNameSet+0x48>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
20009d7c:	00800044 	movi	r2,1
20009d80:	30800005 	stb	r2,0(r6)
20009d84:	f800283a 	ret
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
20009d88:	defffb04 	addi	sp,sp,-20
20009d8c:	dc800215 	stw	r18,8(sp)
20009d90:	dc400115 	stw	r17,4(sp)
20009d94:	dc000015 	stw	r16,0(sp)
20009d98:	2823883a 	mov	r17,r5
20009d9c:	3021883a 	mov	r16,r6
20009da0:	2025883a 	mov	r18,r4
20009da4:	dfc00415 	stw	ra,16(sp)
20009da8:	dcc00315 	stw	r19,12(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009dac:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009db0:	00bfff84 	movi	r2,-2
20009db4:	9884703a 	and	r2,r19,r2
20009db8:	1001703a 	wrctl	status,r2
        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
20009dbc:	2809883a 	mov	r4,r5
20009dc0:	0009d240 	call	20009d24 <OS_StrLen>
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
20009dc4:	10803fcc 	andi	r2,r2,255
20009dc8:	00c007c4 	movi	r3,31
20009dcc:	1880042e 	bgeu	r3,r2,20009de0 <OSEventNameSet+0xa0>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009dd0:	9801703a 	wrctl	status,r19
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
20009dd4:	008002c4 	movi	r2,11
20009dd8:	80800005 	stb	r2,0(r16)
        return;
20009ddc:	00000506 	br	20009df4 <OSEventNameSet+0xb4>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
20009de0:	91000384 	addi	r4,r18,14
20009de4:	880b883a 	mov	r5,r17
20009de8:	0009c500 	call	20009c50 <OS_StrCopy>
20009dec:	9801703a 	wrctl	status,r19
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
20009df0:	80000005 	stb	zero,0(r16)
}
20009df4:	dfc00417 	ldw	ra,16(sp)
20009df8:	dcc00317 	ldw	r19,12(sp)
20009dfc:	dc800217 	ldw	r18,8(sp)
20009e00:	dc400117 	ldw	r17,4(sp)
20009e04:	dc000017 	ldw	r16,0(sp)
20009e08:	dec00504 	addi	sp,sp,20
20009e0c:	f800283a 	ret

20009e10 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
20009e10:	defff904 	addi	sp,sp,-28
20009e14:	dc800415 	stw	r18,16(sp)
20009e18:	04800034 	movhi	r18,0
20009e1c:	dcc00515 	stw	r19,20(sp)
20009e20:	dc400315 	stw	r17,12(sp)
20009e24:	dc000215 	stw	r16,8(sp)
20009e28:	dfc00615 	stw	ra,24(sp)
20009e2c:	0021883a 	mov	r16,zero
20009e30:	949e0004 	addi	r18,r18,30720
    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
        err = OSTaskStkChk(prio, &stk_data);
        if (err == OS_ERR_NONE) {
            ptcb = OSTCBPrioTbl[prio];
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
20009e34:	04c00044 	movi	r19,1
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
20009e38:	04400544 	movi	r17,21
        err = OSTaskStkChk(prio, &stk_data);
20009e3c:	8009883a 	mov	r4,r16
20009e40:	d80b883a 	mov	r5,sp
20009e44:	000c9740 	call	2000c974 <OSTaskStkChk>
        if (err == OS_ERR_NONE) {
20009e48:	10803fcc 	andi	r2,r2,255
20009e4c:	10000e1e 	bne	r2,zero,20009e88 <OS_TaskStatStkChk+0x78>
20009e50:	8405883a 	add	r2,r16,r16
20009e54:	1085883a 	add	r2,r2,r2
20009e58:	1485883a 	add	r2,r2,r18
            ptcb = OSTCBPrioTbl[prio];
20009e5c:	10c00017 	ldw	r3,0(r2)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
20009e60:	18000926 	beq	r3,zero,20009e88 <OS_TaskStatStkChk+0x78>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
20009e64:	1cc00826 	beq	r3,r19,20009e88 <OS_TaskStatStkChk+0x78>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
20009e68:	18800317 	ldw	r2,12(r3)
20009e6c:	19000217 	ldw	r4,8(r3)
20009e70:	1085883a 	add	r2,r2,r2
20009e74:	1085883a 	add	r2,r2,r2
20009e78:	2085883a 	add	r2,r4,r2
20009e7c:	18801115 	stw	r2,68(r3)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
20009e80:	d8800117 	ldw	r2,4(sp)
20009e84:	18801215 	stw	r2,72(r3)
20009e88:	84000044 	addi	r16,r16,1
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
20009e8c:	847feb1e 	bne	r16,r17,20009e3c <OS_TaskStatStkChk+0x2c>
#endif
                }
            }
        }
    }
}
20009e90:	dfc00617 	ldw	ra,24(sp)
20009e94:	dcc00517 	ldw	r19,20(sp)
20009e98:	dc800417 	ldw	r18,16(sp)
20009e9c:	dc400317 	ldw	r17,12(sp)
20009ea0:	dc000217 	ldw	r16,8(sp)
20009ea4:	dec00704 	addi	sp,sp,28
20009ea8:	f800283a 	ret

20009eac <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
20009eac:	defffd04 	addi	sp,sp,-12
20009eb0:	dfc00215 	stw	ra,8(sp)
20009eb4:	dc400115 	stw	r17,4(sp)
20009eb8:	dc000015 	stw	r16,0(sp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
20009ebc:	d0a04603 	ldbu	r2,-32488(gp)
20009ec0:	1000031e 	bne	r2,zero,20009ed0 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
20009ec4:	01003204 	movi	r4,200
20009ec8:	000ce280 	call	2000ce28 <OSTimeDly>
20009ecc:	003ffb06 	br	20009ebc <OS_TaskStat+0x10>
    }
    OSIdleCtrMax /= 100L;
20009ed0:	d1203a17 	ldw	r4,-32536(gp)
20009ed4:	01401904 	movi	r5,100
20009ed8:	0008c140 	call	20008c14 <__udivsi3>
20009edc:	d0a03a15 	stw	r2,-32536(gp)
    if (OSIdleCtrMax == 0L) {
20009ee0:	1000031e 	bne	r2,zero,20009ef0 <OS_TaskStat+0x44>
        OSCPUUsage = 0;
        (void)OSTaskSuspend(OS_PRIO_SELF);
20009ee4:	01003fc4 	movi	r4,255
    while (OSStatRdy == OS_FALSE) {
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
    if (OSIdleCtrMax == 0L) {
        OSCPUUsage = 0;
20009ee8:	d0203c05 	stb	zero,-32528(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
20009eec:	000ca7c0 	call	2000ca7c <OSTaskSuspend>
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009ef0:	047fff84 	movi	r17,-2
    for (;;) {
        OS_ENTER_CRITICAL();
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
20009ef4:	04001904 	movi	r16,100
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009ef8:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009efc:	1446703a 	and	r3,r2,r17
20009f00:	1801703a 	wrctl	status,r3
        OSCPUUsage = 0;
        (void)OSTaskSuspend(OS_PRIO_SELF);
    }
    for (;;) {
        OS_ENTER_CRITICAL();
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
20009f04:	d1203517 	ldw	r4,-32556(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
20009f08:	d0203515 	stw	zero,-32556(gp)
        OSCPUUsage = 0;
        (void)OSTaskSuspend(OS_PRIO_SELF);
    }
    for (;;) {
        OS_ENTER_CRITICAL();
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
20009f0c:	d1204715 	stw	r4,-32484(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009f10:	1001703a 	wrctl	status,r2
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
20009f14:	d1603a17 	ldw	r5,-32536(gp)
20009f18:	0008c140 	call	20008c14 <__udivsi3>
20009f1c:	8085c83a 	sub	r2,r16,r2
20009f20:	d0a03c05 	stb	r2,-32528(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
20009f24:	000e2940 	call	2000e294 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
20009f28:	0009e100 	call	20009e10 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
20009f2c:	01001904 	movi	r4,100
20009f30:	000ce280 	call	2000ce28 <OSTimeDly>
    }
20009f34:	003ff006 	br	20009ef8 <OS_TaskStat+0x4c>

20009f38 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
20009f38:	defffc04 	addi	sp,sp,-16
20009f3c:	d8c00617 	ldw	r3,24(sp)
20009f40:	dfc00315 	stw	ra,12(sp)
20009f44:	dc800215 	stw	r18,8(sp)
20009f48:	dc400115 	stw	r17,4(sp)
20009f4c:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
20009f50:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
20009f54:	04bfff84 	movi	r18,-2
20009f58:	1490703a 	and	r8,r2,r18
20009f5c:	4001703a 	wrctl	status,r8
#endif



    OS_ENTER_CRITICAL();
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
20009f60:	d4203b17 	ldw	r16,-32532(gp)
    if (ptcb != (OS_TCB *)0) {
20009f64:	80004a26 	beq	r16,zero,2000a090 <OS_TCBInit+0x158>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
20009f68:	82000517 	ldw	r8,20(r16)
20009f6c:	d2203b15 	stw	r8,-32532(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
20009f70:	1001703a 	wrctl	status,r2
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
20009f74:	d8800517 	ldw	r2,20(sp)
#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
20009f78:	24403fcc 	andi	r17,r4,255

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
20009f7c:	80c0040d 	sth	r3,16(r16)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
20009f80:	80800115 	stw	r2,4(r16)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
20009f84:	d8800417 	ldw	r2,16(sp)
#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
20009f88:	8806d0fa 	srli	r3,r17,3
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    if (ptcb != (OS_TCB *)0) {
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
20009f8c:	81000c85 	stb	r4,50(r16)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
20009f90:	80800315 	stw	r2,12(r16)
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
20009f94:	210001cc 	andi	r4,r4,7
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
20009f98:	00800044 	movi	r2,1
#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
20009f9c:	80c00d05 	stb	r3,52(r16)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
20009fa0:	81000cc5 	stb	r4,51(r16)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
20009fa4:	10c6983a 	sll	r3,r2,r3
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
20009fa8:	1108983a 	sll	r4,r2,r4
        ptcb->OSTCBStkBase     = (OS_STK *)0;
        ptcb->OSTCBStkUsed     = 0L;
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
20009fac:	00800fc4 	movi	r2,63
    OS_ENTER_CRITICAL();
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    if (ptcb != (OS_TCB *)0) {
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
20009fb0:	81400015 	stw	r5,0(r16)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
20009fb4:	81800215 	stw	r6,8(r16)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
20009fb8:	81c0048d 	sth	r7,18(r16)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
20009fbc:	80c00d85 	stb	r3,54(r16)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
20009fc0:	81000d45 	stb	r4,53(r16)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
        ptcb->OSTCBStkUsed     = 0L;
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
20009fc4:	80801305 	stb	r2,76(r16)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif

        OSTCBInitHook(ptcb);
20009fc8:	8009883a 	mov	r4,r16
    if (ptcb != (OS_TCB *)0) {
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
20009fcc:	80000c05 	stb	zero,48(r16)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
20009fd0:	80000c45 	stb	zero,49(r16)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
20009fd4:	80000b8d 	sth	zero,46(r16)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
20009fd8:	80000dc5 	stb	zero,55(r16)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
20009fdc:	80000715 	stw	zero,28(r16)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
20009fe0:	80000815 	stw	zero,32(r16)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
20009fe4:	80000a15 	stw	zero,40(r16)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
20009fe8:	80000915 	stw	zero,36(r16)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
20009fec:	80000e15 	stw	zero,56(r16)
        ptcb->OSTCBCyclesStart = 0L;
20009ff0:	80001015 	stw	zero,64(r16)
        ptcb->OSTCBCyclesTot   = 0L;
20009ff4:	80000f15 	stw	zero,60(r16)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
20009ff8:	80001115 	stw	zero,68(r16)
        ptcb->OSTCBStkUsed     = 0L;
20009ffc:	80001215 	stw	zero,72(r16)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
2000a000:	80001345 	stb	zero,77(r16)
#endif

        OSTCBInitHook(ptcb);
2000a004:	000e2a80 	call	2000e2a8 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
2000a008:	8009883a 	mov	r4,r16
2000a00c:	000e2880 	call	2000e288 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000a010:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000a014:	24a4703a 	and	r18,r4,r18
2000a018:	9001703a 	wrctl	status,r18

        OS_ENTER_CRITICAL();
        OSTCBPrioTbl[prio] = ptcb;
2000a01c:	8c63883a 	add	r17,r17,r17
2000a020:	00800034 	movhi	r2,0
2000a024:	109e0004 	addi	r2,r2,30720
2000a028:	8c63883a 	add	r17,r17,r17
2000a02c:	1463883a 	add	r17,r2,r17
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
2000a030:	d0a03717 	ldw	r2,-32548(gp)
        OSTCBInitHook(ptcb);

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */

        OS_ENTER_CRITICAL();
        OSTCBPrioTbl[prio] = ptcb;
2000a034:	8c000015 	stw	r16,0(r17)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
        ptcb->OSTCBPrev    = (OS_TCB *)0;
2000a038:	80000615 	stw	zero,24(r16)

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */

        OS_ENTER_CRITICAL();
        OSTCBPrioTbl[prio] = ptcb;
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
2000a03c:	80800515 	stw	r2,20(r16)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
        if (OSTCBList != (OS_TCB *)0) {
2000a040:	10000126 	beq	r2,zero,2000a048 <OS_TCBInit+0x110>
            OSTCBList->OSTCBPrev = ptcb;
2000a044:	14000615 	stw	r16,24(r2)
        }
        OSTCBList               = ptcb;
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
2000a048:	80c00d83 	ldbu	r3,54(r16)
2000a04c:	d0a04003 	ldbu	r2,-32512(gp)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
        ptcb->OSTCBPrev    = (OS_TCB *)0;
        if (OSTCBList != (OS_TCB *)0) {
            OSTCBList->OSTCBPrev = ptcb;
        }
        OSTCBList               = ptcb;
2000a050:	d4203715 	stw	r16,-32548(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
2000a054:	1884b03a 	or	r2,r3,r2
2000a058:	d0a04005 	stb	r2,-32512(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
2000a05c:	80800d03 	ldbu	r2,52(r16)
2000a060:	d0e04044 	addi	r3,gp,-32511
2000a064:	1885883a 	add	r2,r3,r2
2000a068:	11400003 	ldbu	r5,0(r2)
2000a06c:	80c00d43 	ldbu	r3,53(r16)
2000a070:	28c6b03a 	or	r3,r5,r3
2000a074:	10c00005 	stb	r3,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
2000a078:	d0a03c43 	ldbu	r2,-32527(gp)
2000a07c:	10800044 	addi	r2,r2,1
2000a080:	d0a03c45 	stb	r2,-32527(gp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000a084:	2001703a 	wrctl	status,r4
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
2000a088:	0005883a 	mov	r2,zero
2000a08c:	00000206 	br	2000a098 <OS_TCBInit+0x160>
2000a090:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
2000a094:	00801084 	movi	r2,66
}
2000a098:	dfc00317 	ldw	ra,12(sp)
2000a09c:	dc800217 	ldw	r18,8(sp)
2000a0a0:	dc400117 	ldw	r17,4(sp)
2000a0a4:	dc000017 	ldw	r16,0(sp)
2000a0a8:	dec00404 	addi	sp,sp,16
2000a0ac:	f800283a 	ret

2000a0b0 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
2000a0b0:	f800283a 	ret

2000a0b4 <OS_FlagBlock>:
{
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
2000a0b4:	00800034 	movhi	r2,0
2000a0b8:	10818204 	addi	r2,r2,1544
2000a0bc:	10800017 	ldw	r2,0(r2)
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
2000a0c0:	da000017 	ldw	r8,0(sp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
2000a0c4:	10c00c03 	ldbu	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
2000a0c8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
2000a0cc:	12000b8d 	sth	r8,46(r2)
{
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
2000a0d0:	18c00814 	ori	r3,r3,32
2000a0d4:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
2000a0d8:	11400a15 	stw	r5,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
2000a0dc:	29c00485 	stb	r7,18(r5)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
2000a0e0:	20c00117 	ldw	r3,4(r4)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
2000a0e4:	2980040d 	sth	r6,16(r5)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
2000a0e8:	28800215 	stw	r2,8(r5)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
2000a0ec:	28c00015 	stw	r3,0(r5)
    pnode->OSFlagNodePrev     = (void *)0;
2000a0f0:	28000115 	stw	zero,4(r5)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
2000a0f4:	29000315 	stw	r4,12(r5)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
2000a0f8:	18000126 	beq	r3,zero,2000a100 <OS_FlagBlock+0x4c>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
2000a0fc:	19400115 	stw	r5,4(r3)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
2000a100:	21400115 	stw	r5,4(r4)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
2000a104:	10c00d03 	ldbu	r3,52(r2)
2000a108:	01000034 	movhi	r4,0
2000a10c:	21017f44 	addi	r4,r4,1533
2000a110:	20c9883a 	add	r4,r4,r3
2000a114:	10c00d43 	ldbu	r3,53(r2)
2000a118:	00ca303a 	nor	r5,zero,r3
2000a11c:	20c00003 	ldbu	r3,0(r4)
2000a120:	28c6703a 	and	r3,r5,r3
2000a124:	20c00005 	stb	r3,0(r4)
    if (OSRdyTbl[y] == 0x00) {
2000a128:	18c03fcc 	andi	r3,r3,255
2000a12c:	1800071e 	bne	r3,zero,2000a14c <OS_FlagBlock+0x98>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
2000a130:	10800d83 	ldbu	r2,54(r2)
2000a134:	01000034 	movhi	r4,0
2000a138:	21017f04 	addi	r4,r4,1532
2000a13c:	0086303a 	nor	r3,zero,r2
2000a140:	20800003 	ldbu	r2,0(r4)
2000a144:	1884703a 	and	r2,r3,r2
2000a148:	20800005 	stb	r2,0(r4)
2000a14c:	f800283a 	ret

2000a150 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
2000a150:	3011883a 	mov	r8,r6
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
2000a154:	38004a26 	beq	r7,zero,2000a280 <OSFlagAccept+0x130>
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
2000a158:	2000021e 	bne	r4,zero,2000a164 <OSFlagAccept+0x14>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
2000a15c:	00801b84 	movi	r2,110
2000a160:	00004606 	br	2000a27c <OSFlagAccept+0x12c>
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
2000a164:	20c00003 	ldbu	r3,0(r4)
2000a168:	00800144 	movi	r2,5
2000a16c:	18800226 	beq	r3,r2,2000a178 <OSFlagAccept+0x28>
        *perr = OS_ERR_EVENT_TYPE;
2000a170:	00800044 	movi	r2,1
2000a174:	00004106 	br	2000a27c <OSFlagAccept+0x12c>
        return ((OS_FLAGS)0);
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
2000a178:	00ffe004 	movi	r3,-128
2000a17c:	30c6703a 	and	r3,r6,r3
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
2000a180:	18c03fcc 	andi	r3,r3,255
2000a184:	18000326 	beq	r3,zero,2000a194 <OSFlagAccept+0x44>
        wait_type &= ~OS_FLAG_CONSUME;
2000a188:	32001fcc 	andi	r8,r6,127
        consume    = OS_TRUE;
2000a18c:	01800044 	movi	r6,1
2000a190:	00000106 	br	2000a198 <OSFlagAccept+0x48>
    } else {
        consume    = OS_FALSE;
2000a194:	000d883a 	mov	r6,zero
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
2000a198:	38000005 	stb	zero,0(r7)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000a19c:	0013303a 	rdctl	r9,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000a1a0:	00ffff84 	movi	r3,-2
2000a1a4:	48c6703a 	and	r3,r9,r3
2000a1a8:	1801703a 	wrctl	status,r3
    OS_ENTER_CRITICAL();
    switch (wait_type) {
2000a1ac:	42003fcc 	andi	r8,r8,255
2000a1b0:	02800044 	movi	r10,1
2000a1b4:	42802126 	beq	r8,r10,2000a23c <OSFlagAccept+0xec>
2000a1b8:	40001526 	beq	r8,zero,2000a210 <OSFlagAccept+0xc0>
2000a1bc:	00800084 	movi	r2,2
2000a1c0:	40800326 	beq	r8,r2,2000a1d0 <OSFlagAccept+0x80>
2000a1c4:	008000c4 	movi	r2,3
2000a1c8:	40800726 	beq	r8,r2,2000a1e8 <OSFlagAccept+0x98>
2000a1cc:	00002906 	br	2000a274 <OSFlagAccept+0x124>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
2000a1d0:	20c0020b 	ldhu	r3,8(r4)
2000a1d4:	28c4703a 	and	r2,r5,r3
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
2000a1d8:	123fffcc 	andi	r8,r2,65535
2000a1dc:	297fffcc 	andi	r5,r5,65535
2000a1e0:	4140201e 	bne	r8,r5,2000a264 <OSFlagAccept+0x114>
2000a1e4:	00000406 	br	2000a1f8 <OSFlagAccept+0xa8>
             }
             OS_EXIT_CRITICAL();
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
2000a1e8:	20c0020b 	ldhu	r3,8(r4)
2000a1ec:	28c4703a 	and	r2,r5,r3
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
2000a1f0:	117fffcc 	andi	r5,r2,65535
2000a1f4:	28001b26 	beq	r5,zero,2000a264 <OSFlagAccept+0x114>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
2000a1f8:	31803fcc 	andi	r6,r6,255
2000a1fc:	32801b1e 	bne	r6,r10,2000a26c <OSFlagAccept+0x11c>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
2000a200:	008a303a 	nor	r5,zero,r2
2000a204:	28c6703a 	and	r3,r5,r3
2000a208:	20c0020d 	sth	r3,8(r4)
2000a20c:	00001706 	br	2000a26c <OSFlagAccept+0x11c>
             OS_EXIT_CRITICAL();
             break;

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
2000a210:	2200020b 	ldhu	r8,8(r4)
2000a214:	0206303a 	nor	r3,zero,r8
2000a218:	28c4703a 	and	r2,r5,r3
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
2000a21c:	10ffffcc 	andi	r3,r2,65535
2000a220:	297fffcc 	andi	r5,r5,65535
2000a224:	19400f1e 	bne	r3,r5,2000a264 <OSFlagAccept+0x114>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
2000a228:	31803fcc 	andi	r6,r6,255
2000a22c:	32800f1e 	bne	r6,r10,2000a26c <OSFlagAccept+0x11c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
2000a230:	1210b03a 	or	r8,r2,r8
2000a234:	2200020d 	sth	r8,8(r4)
2000a238:	00000c06 	br	2000a26c <OSFlagAccept+0x11c>
             }
             OS_EXIT_CRITICAL();
             break;

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
2000a23c:	2280020b 	ldhu	r10,8(r4)
2000a240:	0286303a 	nor	r3,zero,r10
2000a244:	28c4703a 	and	r2,r5,r3
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
2000a248:	10ffffcc 	andi	r3,r2,65535
2000a24c:	18000526 	beq	r3,zero,2000a264 <OSFlagAccept+0x114>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
2000a250:	31803fcc 	andi	r6,r6,255
2000a254:	3200051e 	bne	r6,r8,2000a26c <OSFlagAccept+0x11c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
2000a258:	1294b03a 	or	r10,r2,r10
2000a25c:	2280020d 	sth	r10,8(r4)
2000a260:	00000206 	br	2000a26c <OSFlagAccept+0x11c>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
2000a264:	00c01c04 	movi	r3,112
2000a268:	38c00005 	stb	r3,0(r7)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000a26c:	4801703a 	wrctl	status,r9
2000a270:	f800283a 	ret
2000a274:	4801703a 	wrctl	status,r9
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
2000a278:	00801bc4 	movi	r2,111
2000a27c:	38800005 	stb	r2,0(r7)



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return ((OS_FLAGS)0);
2000a280:	0005883a 	mov	r2,zero
             flags_rdy = (OS_FLAGS)0;
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
             break;
    }
    return (flags_rdy);
}
2000a284:	f800283a 	ret

2000a288 <OSFlagCreate>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
2000a288:	28001d26 	beq	r5,zero,2000a300 <OSFlagCreate+0x78>
        return ((OS_FLAG_GRP *)0);
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
2000a28c:	00800034 	movhi	r2,0
2000a290:	10818104 	addi	r2,r2,1540
2000a294:	10800003 	ldbu	r2,0(r2)
2000a298:	10000226 	beq	r2,zero,2000a2a4 <OSFlagCreate+0x1c>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
2000a29c:	00800404 	movi	r2,16
2000a2a0:	00001606 	br	2000a2fc <OSFlagCreate+0x74>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000a2a4:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000a2a8:	00bfff84 	movi	r2,-2
2000a2ac:	1884703a 	and	r2,r3,r2
2000a2b0:	1001703a 	wrctl	status,r2
        return ((OS_FLAG_GRP *)0);
    }
    OS_ENTER_CRITICAL();
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
2000a2b4:	01800034 	movhi	r6,0
2000a2b8:	31818404 	addi	r6,r6,1552
2000a2bc:	30800017 	ldw	r2,0(r6)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
2000a2c0:	10000c26 	beq	r2,zero,2000a2f4 <OSFlagCreate+0x6c>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
2000a2c4:	11c00117 	ldw	r7,4(r2)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
2000a2c8:	1100020d 	sth	r4,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
2000a2cc:	01000fc4 	movi	r4,63
    }
    OS_ENTER_CRITICAL();
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
2000a2d0:	31c00015 	stw	r7,0(r6)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
2000a2d4:	01800144 	movi	r6,5
2000a2d8:	11800005 	stb	r6,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
2000a2dc:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
2000a2e0:	11000285 	stb	r4,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
2000a2e4:	100002c5 	stb	zero,11(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000a2e8:	1801703a 	wrctl	status,r3
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
2000a2ec:	28000005 	stb	zero,0(r5)
2000a2f0:	f800283a 	ret
2000a2f4:	1801703a 	wrctl	status,r3
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
2000a2f8:	00801c84 	movi	r2,114
2000a2fc:	28800005 	stb	r2,0(r5)



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
        return ((OS_FLAG_GRP *)0);
2000a300:	0005883a 	mov	r2,zero
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
}
2000a304:	f800283a 	ret

2000a308 <OSFlagNameGet>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
2000a308:	30002526 	beq	r6,zero,2000a3a0 <OSFlagNameGet+0x98>
2000a30c:	2007883a 	mov	r3,r4
        return (0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
2000a310:	2000021e 	bne	r4,zero,2000a31c <OSFlagNameGet+0x14>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
2000a314:	00801b84 	movi	r2,110
2000a318:	00000906 	br	2000a340 <OSFlagNameGet+0x38>
        return (0);
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
2000a31c:	2800021e 	bne	r5,zero,2000a328 <OSFlagNameGet+0x20>
        *perr = OS_ERR_PNAME_NULL;
2000a320:	00800304 	movi	r2,12
2000a324:	00000606 	br	2000a340 <OSFlagNameGet+0x38>
        return (0);
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
2000a328:	00800034 	movhi	r2,0
2000a32c:	10818104 	addi	r2,r2,1540
2000a330:	10800003 	ldbu	r2,0(r2)
2000a334:	11003fcc 	andi	r4,r2,255
2000a338:	20000326 	beq	r4,zero,2000a348 <OSFlagNameGet+0x40>
        *perr = OS_ERR_NAME_GET_ISR;
2000a33c:	00800444 	movi	r2,17
2000a340:	30800005 	stb	r2,0(r6)
2000a344:	00001606 	br	2000a3a0 <OSFlagNameGet+0x98>
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
2000a348:	defffd04 	addi	sp,sp,-12
2000a34c:	dfc00215 	stw	ra,8(sp)
2000a350:	dc400115 	stw	r17,4(sp)
2000a354:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000a358:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000a35c:	013fff84 	movi	r4,-2
2000a360:	8908703a 	and	r4,r17,r4
2000a364:	2001703a 	wrctl	status,r4
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        *perr = OS_ERR_NAME_GET_ISR;
        return (0);
    }
    OS_ENTER_CRITICAL();
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
2000a368:	19c00003 	ldbu	r7,0(r3)
2000a36c:	01000144 	movi	r4,5
2000a370:	39000426 	beq	r7,r4,2000a384 <OSFlagNameGet+0x7c>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000a374:	8801703a 	wrctl	status,r17
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
2000a378:	00c00044 	movi	r3,1
2000a37c:	30c00005 	stb	r3,0(r6)
        return (0);
2000a380:	00000906 	br	2000a3a8 <OSFlagNameGet+0xa0>
2000a384:	2809883a 	mov	r4,r5
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
2000a388:	19400284 	addi	r5,r3,10
2000a38c:	3021883a 	mov	r16,r6
2000a390:	0009c500 	call	20009c50 <OS_StrCopy>
2000a394:	8801703a 	wrctl	status,r17
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2000a398:	80000005 	stb	zero,0(r16)
    return (len);
2000a39c:	00000206 	br	2000a3a8 <OSFlagNameGet+0xa0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return (0);
2000a3a0:	0005883a 	mov	r2,zero
2000a3a4:	f800283a 	ret
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (len);
}
2000a3a8:	dfc00217 	ldw	ra,8(sp)
2000a3ac:	dc400117 	ldw	r17,4(sp)
2000a3b0:	dc000017 	ldw	r16,0(sp)
2000a3b4:	dec00304 	addi	sp,sp,12
2000a3b8:	f800283a 	ret

2000a3bc <OSFlagNameSet>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
2000a3bc:	30003526 	beq	r6,zero,2000a494 <OSFlagNameSet+0xd8>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
2000a3c0:	2000021e 	bne	r4,zero,2000a3cc <OSFlagNameSet+0x10>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
2000a3c4:	00801b84 	movi	r2,110
2000a3c8:	00000806 	br	2000a3ec <OSFlagNameSet+0x30>
        return;
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
2000a3cc:	2800021e 	bne	r5,zero,2000a3d8 <OSFlagNameSet+0x1c>
        *perr = OS_ERR_PNAME_NULL;
2000a3d0:	00800304 	movi	r2,12
2000a3d4:	00000506 	br	2000a3ec <OSFlagNameSet+0x30>
        return;
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
2000a3d8:	00800034 	movhi	r2,0
2000a3dc:	10818104 	addi	r2,r2,1540
2000a3e0:	10800003 	ldbu	r2,0(r2)
2000a3e4:	10000326 	beq	r2,zero,2000a3f4 <OSFlagNameSet+0x38>
        *perr = OS_ERR_NAME_SET_ISR;
2000a3e8:	00800484 	movi	r2,18
2000a3ec:	30800005 	stb	r2,0(r6)
        return;
2000a3f0:	f800283a 	ret
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
2000a3f4:	defffb04 	addi	sp,sp,-20
2000a3f8:	dfc00415 	stw	ra,16(sp)
2000a3fc:	dcc00315 	stw	r19,12(sp)
2000a400:	dc800215 	stw	r18,8(sp)
2000a404:	dc400115 	stw	r17,4(sp)
2000a408:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000a40c:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000a410:	00bfff84 	movi	r2,-2
2000a414:	9884703a 	and	r2,r19,r2
2000a418:	1001703a 	wrctl	status,r2
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        *perr = OS_ERR_NAME_SET_ISR;
        return;
    }
    OS_ENTER_CRITICAL();
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
2000a41c:	20c00003 	ldbu	r3,0(r4)
2000a420:	00800144 	movi	r2,5
2000a424:	18800426 	beq	r3,r2,2000a438 <OSFlagNameSet+0x7c>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000a428:	9801703a 	wrctl	status,r19
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
2000a42c:	00800044 	movi	r2,1
2000a430:	30800005 	stb	r2,0(r6)
        return;
2000a434:	00001106 	br	2000a47c <OSFlagNameSet+0xc0>
2000a438:	2025883a 	mov	r18,r4
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
2000a43c:	2809883a 	mov	r4,r5
2000a440:	3021883a 	mov	r16,r6
2000a444:	2823883a 	mov	r17,r5
2000a448:	0009d240 	call	20009d24 <OS_StrLen>
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
2000a44c:	10803fcc 	andi	r2,r2,255
2000a450:	00c007c4 	movi	r3,31
2000a454:	1880042e 	bgeu	r3,r2,2000a468 <OSFlagNameSet+0xac>
2000a458:	9801703a 	wrctl	status,r19
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
2000a45c:	00801cc4 	movi	r2,115
2000a460:	80800005 	stb	r2,0(r16)
        return;
2000a464:	00000506 	br	2000a47c <OSFlagNameSet+0xc0>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
2000a468:	91000284 	addi	r4,r18,10
2000a46c:	880b883a 	mov	r5,r17
2000a470:	0009c500 	call	20009c50 <OS_StrCopy>
2000a474:	9801703a 	wrctl	status,r19
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2000a478:	80000005 	stb	zero,0(r16)
    return;
}
2000a47c:	dfc00417 	ldw	ra,16(sp)
2000a480:	dcc00317 	ldw	r19,12(sp)
2000a484:	dc800217 	ldw	r18,8(sp)
2000a488:	dc400117 	ldw	r17,4(sp)
2000a48c:	dc000017 	ldw	r16,0(sp)
2000a490:	dec00504 	addi	sp,sp,20
2000a494:	f800283a 	ret

2000a498 <OSFlagPendGetFlagsRdy>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000a498:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000a49c:	00bfff84 	movi	r2,-2
2000a4a0:	1884703a 	and	r2,r3,r2
2000a4a4:	1001703a 	wrctl	status,r2
#endif



    OS_ENTER_CRITICAL();
    flags = OSTCBCur->OSTCBFlagsRdy;
2000a4a8:	00800034 	movhi	r2,0
2000a4ac:	10818204 	addi	r2,r2,1544
2000a4b0:	10800017 	ldw	r2,0(r2)
2000a4b4:	10800b0b 	ldhu	r2,44(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000a4b8:	1801703a 	wrctl	status,r3
    OS_EXIT_CRITICAL();
    return (flags);
}
2000a4bc:	f800283a 	ret

2000a4c0 <OSFlagQuery>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
2000a4c0:	28001126 	beq	r5,zero,2000a508 <OSFlagQuery+0x48>
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
2000a4c4:	2000021e 	bne	r4,zero,2000a4d0 <OSFlagQuery+0x10>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
2000a4c8:	00801b84 	movi	r2,110
2000a4cc:	00000406 	br	2000a4e0 <OSFlagQuery+0x20>
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
2000a4d0:	20c00003 	ldbu	r3,0(r4)
2000a4d4:	00800144 	movi	r2,5
2000a4d8:	18800326 	beq	r3,r2,2000a4e8 <OSFlagQuery+0x28>
        *perr = OS_ERR_EVENT_TYPE;
2000a4dc:	00800044 	movi	r2,1
2000a4e0:	28800005 	stb	r2,0(r5)
2000a4e4:	00000806 	br	2000a508 <OSFlagQuery+0x48>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000a4e8:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000a4ec:	00bfff84 	movi	r2,-2
2000a4f0:	1884703a 	and	r2,r3,r2
2000a4f4:	1001703a 	wrctl	status,r2
        return ((OS_FLAGS)0);
    }
    OS_ENTER_CRITICAL();
    flags = pgrp->OSFlagFlags;
2000a4f8:	2080020b 	ldhu	r2,8(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000a4fc:	1801703a 	wrctl	status,r3
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2000a500:	28000005 	stb	zero,0(r5)
    return (flags);                               /* Return the current value of the event flags       */
2000a504:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
        return ((OS_FLAGS)0);
2000a508:	0005883a 	mov	r2,zero
    OS_ENTER_CRITICAL();
    flags = pgrp->OSFlagFlags;
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (flags);                               /* Return the current value of the event flags       */
}
2000a50c:	f800283a 	ret

2000a510 <OS_FlagInit>:
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
2000a510:	01000034 	movhi	r4,0
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
2000a514:	deffff04 	addi	sp,sp,-4
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
2000a518:	21118c04 	addi	r4,r4,17968
2000a51c:	0140dc04 	movi	r5,880
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
2000a520:	dfc00015 	stw	ra,0(sp)
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
2000a524:	00095f00 	call	200095f0 <OS_MemClr>
2000a528:	00c00034 	movhi	r3,0
2000a52c:	18d18d04 	addi	r3,r3,17972
2000a530:	0005883a 	mov	r2,zero
2000a534:	19bfff04 	addi	r6,r3,-4
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
        pgrp1->OSFlagWaitList = (void *)pgrp2;
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
2000a538:	02000fc4 	movi	r8,63


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
2000a53c:	01c0d104 	movi	r7,836
2000a540:	11400b04 	addi	r5,r2,44
2000a544:	1185883a 	add	r2,r2,r6
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
2000a548:	10000005 	stb	zero,0(r2)
2000a54c:	2985883a 	add	r2,r5,r6
        pgrp1->OSFlagWaitList = (void *)pgrp2;
2000a550:	18800015 	stw	r2,0(r3)
2000a554:	01000034 	movhi	r4,0
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
2000a558:	1a000185 	stb	r8,6(r3)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
2000a55c:	180001c5 	stb	zero,7(r3)
2000a560:	21118c04 	addi	r4,r4,17968
2000a564:	18c00b04 	addi	r3,r3,44
2000a568:	2805883a 	mov	r2,r5


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
2000a56c:	29fff41e 	bne	r5,r7,2000a540 <OS_FlagInit+0x30>
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    pgrp1->OSFlagWaitList = (void *)0;
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
2000a570:	00800fc4 	movi	r2,63
2000a574:	2080d385 	stb	r2,846(r4)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
2000a578:	00800034 	movhi	r2,0
2000a57c:	10818404 	addi	r2,r2,1552
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
2000a580:	2000d105 	stb	zero,836(r4)
    pgrp1->OSFlagWaitList = (void *)0;
2000a584:	2000d215 	stw	zero,840(r4)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
2000a588:	2000d3c5 	stb	zero,847(r4)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
2000a58c:	11000015 	stw	r4,0(r2)
#endif
}
2000a590:	dfc00017 	ldw	ra,0(sp)
2000a594:	dec00104 	addi	sp,sp,4
2000a598:	f800283a 	ret

2000a59c <OS_FlagUnlink>:
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
2000a59c:	20c00117 	ldw	r3,4(r4)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
2000a5a0:	20800017 	ldw	r2,0(r4)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
2000a5a4:	1800051e 	bne	r3,zero,2000a5bc <OS_FlagUnlink+0x20>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
2000a5a8:	20c00317 	ldw	r3,12(r4)
2000a5ac:	18800115 	stw	r2,4(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {
2000a5b0:	10000526 	beq	r2,zero,2000a5c8 <OS_FlagUnlink+0x2c>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
2000a5b4:	10000115 	stw	zero,4(r2)
2000a5b8:	00000306 	br	2000a5c8 <OS_FlagUnlink+0x2c>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
2000a5bc:	18800015 	stw	r2,0(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
2000a5c0:	10000126 	beq	r2,zero,2000a5c8 <OS_FlagUnlink+0x2c>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
2000a5c4:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
2000a5c8:	20800217 	ldw	r2,8(r4)
2000a5cc:	10000a15 	stw	zero,40(r2)
2000a5d0:	f800283a 	ret

2000a5d4 <OS_FlagTaskRdy>:
{
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
2000a5d4:	20800217 	ldw	r2,8(r4)
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
2000a5d8:	defffe04 	addi	sp,sp,-8
2000a5dc:	dfc00115 	stw	ra,4(sp)
2000a5e0:	dc000015 	stw	r16,0(sp)
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
    ptcb->OSTCBDly       = 0;
    ptcb->OSTCBFlagsRdy  = flags_rdy;
2000a5e4:	11400b0d 	sth	r5,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
2000a5e8:	11400c03 	ldbu	r5,48(r2)
2000a5ec:	00fff7c4 	movi	r3,-33
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
    ptcb->OSTCBDly       = 0;
2000a5f0:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
2000a5f4:	28c6703a 	and	r3,r5,r3
2000a5f8:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
2000a5fc:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
2000a600:	18c03fcc 	andi	r3,r3,255
2000a604:	1800101e 	bne	r3,zero,2000a648 <OS_FlagTaskRdy+0x74>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
2000a608:	01400034 	movhi	r5,0
2000a60c:	29417f04 	addi	r5,r5,1532
2000a610:	28c00003 	ldbu	r3,0(r5)
2000a614:	11800d83 	ldbu	r6,54(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
        sched                   = OS_TRUE;
2000a618:	04000044 	movi	r16,1
    ptcb->OSTCBDly       = 0;
    ptcb->OSTCBFlagsRdy  = flags_rdy;
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
2000a61c:	30c6b03a 	or	r3,r6,r3
2000a620:	28c00005 	stb	r3,0(r5)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
2000a624:	10c00d03 	ldbu	r3,52(r2)
2000a628:	01400034 	movhi	r5,0
2000a62c:	29417f44 	addi	r5,r5,1533
2000a630:	28c7883a 	add	r3,r5,r3
2000a634:	19400003 	ldbu	r5,0(r3)
2000a638:	10800d43 	ldbu	r2,53(r2)
2000a63c:	2884b03a 	or	r2,r5,r2
2000a640:	18800005 	stb	r2,0(r3)
2000a644:	00000106 	br	2000a64c <OS_FlagTaskRdy+0x78>
        sched                   = OS_TRUE;
    } else {
        sched                   = OS_FALSE;
2000a648:	0021883a 	mov	r16,zero
    }
    OS_FlagUnlink(pnode);
2000a64c:	000a59c0 	call	2000a59c <OS_FlagUnlink>
    return (sched);
}
2000a650:	8005883a 	mov	r2,r16
2000a654:	dfc00117 	ldw	ra,4(sp)
2000a658:	dc000017 	ldw	r16,0(sp)
2000a65c:	dec00204 	addi	sp,sp,8
2000a660:	f800283a 	ret

2000a664 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
2000a664:	defffa04 	addi	sp,sp,-24
2000a668:	dc400115 	stw	r17,4(sp)
2000a66c:	dc000015 	stw	r16,0(sp)
2000a670:	dfc00515 	stw	ra,20(sp)
2000a674:	dd000415 	stw	r20,16(sp)
2000a678:	dcc00315 	stw	r19,12(sp)
2000a67c:	dc800215 	stw	r18,8(sp)
2000a680:	2021883a 	mov	r16,r4
2000a684:	3023883a 	mov	r17,r6
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
2000a688:	30004926 	beq	r6,zero,2000a7b0 <OSFlagDel+0x14c>
        return (pgrp);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
2000a68c:	2000021e 	bne	r4,zero,2000a698 <OSFlagDel+0x34>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
2000a690:	00801b84 	movi	r2,110
2000a694:	00001506 	br	2000a6ec <OSFlagDel+0x88>
        return (pgrp);
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
2000a698:	00800034 	movhi	r2,0
2000a69c:	10818104 	addi	r2,r2,1540
2000a6a0:	10800003 	ldbu	r2,0(r2)
2000a6a4:	10000226 	beq	r2,zero,2000a6b0 <OSFlagDel+0x4c>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
2000a6a8:	008003c4 	movi	r2,15
2000a6ac:	00000f06 	br	2000a6ec <OSFlagDel+0x88>
        return (pgrp);
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
2000a6b0:	20c00003 	ldbu	r3,0(r4)
2000a6b4:	00800144 	movi	r2,5
2000a6b8:	18800226 	beq	r3,r2,2000a6c4 <OSFlagDel+0x60>
        *perr = OS_ERR_EVENT_TYPE;
2000a6bc:	00800044 	movi	r2,1
2000a6c0:	00000a06 	br	2000a6ec <OSFlagDel+0x88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000a6c4:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000a6c8:	00bfff84 	movi	r2,-2
2000a6cc:	9884703a 	and	r2,r19,r2
2000a6d0:	1001703a 	wrctl	status,r2
        return (pgrp);
    }
    OS_ENTER_CRITICAL();
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
2000a6d4:	25000117 	ldw	r20,4(r4)
2000a6d8:	28803fcc 	andi	r2,r5,255
2000a6dc:	a0000526 	beq	r20,zero,2000a6f4 <OSFlagDel+0x90>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
2000a6e0:	1000271e 	bne	r2,zero,2000a780 <OSFlagDel+0x11c>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000a6e4:	9801703a 	wrctl	status,r19
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
2000a6e8:	00801244 	movi	r2,73
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
             break;

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
2000a6ec:	88800005 	stb	r2,0(r17)
             pgrp_return          = pgrp;
             break;
2000a6f0:	00002f06 	br	2000a7b0 <OSFlagDel+0x14c>
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
2000a6f4:	10001e1e 	bne	r2,zero,2000a770 <OSFlagDel+0x10c>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
2000a6f8:	00800fc4 	movi	r2,63
2000a6fc:	80800285 	stb	r2,10(r16)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
2000a700:	00800034 	movhi	r2,0
             if (tasks_waiting == OS_FALSE) {
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
2000a704:	80000005 	stb	zero,0(r16)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
2000a708:	10818404 	addi	r2,r2,1552
2000a70c:	10c00017 	ldw	r3,0(r2)
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
2000a710:	800002c5 	stb	zero,11(r16)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
2000a714:	8000020d 	sth	zero,8(r16)
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
2000a718:	80c00115 	stw	r3,4(r16)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
                 OSFlagFreeList       = pgrp;
2000a71c:	14000015 	stw	r16,0(r2)
2000a720:	9801703a 	wrctl	status,r19
2000a724:	00000f06 	br	2000a764 <OSFlagDel+0x100>
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
2000a728:	00800fc4 	movi	r2,63
2000a72c:	80800285 	stb	r2,10(r16)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
2000a730:	00800034 	movhi	r2,0
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
2000a734:	80000005 	stb	zero,0(r16)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
2000a738:	10818404 	addi	r2,r2,1552
2000a73c:	10c00017 	ldw	r3,0(r2)
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
2000a740:	800002c5 	stb	zero,11(r16)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
2000a744:	8000020d 	sth	zero,8(r16)
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
2000a748:	80c00115 	stw	r3,4(r16)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
             OSFlagFreeList       = pgrp;
2000a74c:	14000015 	stw	r16,0(r2)
2000a750:	9801703a 	wrctl	status,r19
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
2000a754:	94803fcc 	andi	r18,r18,255
2000a758:	00800044 	movi	r2,1
2000a75c:	9080011e 	bne	r18,r2,2000a764 <OSFlagDel+0x100>
                 OS_Sched();                               /* Find highest priority task ready to run  */
2000a760:	00098400 	call	20009840 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
2000a764:	88000005 	stb	zero,0(r17)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
2000a768:	0021883a 	mov	r16,zero
             break;
2000a76c:	00001006 	br	2000a7b0 <OSFlagDel+0x14c>
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
2000a770:	00c00044 	movi	r3,1
2000a774:	10c00b1e 	bne	r2,r3,2000a7a4 <OSFlagDel+0x140>
    }
    OS_ENTER_CRITICAL();
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
2000a778:	0025883a 	mov	r18,zero
2000a77c:	00000306 	br	2000a78c <OSFlagDel+0x128>
    }
    switch (opt) {
2000a780:	00c00044 	movi	r3,1
2000a784:	10c0071e 	bne	r2,r3,2000a7a4 <OSFlagDel+0x140>
        *perr = OS_ERR_EVENT_TYPE;
        return (pgrp);
    }
    OS_ENTER_CRITICAL();
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
2000a788:	2825883a 	mov	r18,r5
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
2000a78c:	a03fe626 	beq	r20,zero,2000a728 <OSFlagDel+0xc4>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
2000a790:	a009883a 	mov	r4,r20
2000a794:	000b883a 	mov	r5,zero
2000a798:	000a5d40 	call	2000a5d4 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
2000a79c:	a5000017 	ldw	r20,0(r20)
2000a7a0:	003ffa06 	br	2000a78c <OSFlagDel+0x128>
2000a7a4:	9801703a 	wrctl	status,r19
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
             break;

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
2000a7a8:	008001c4 	movi	r2,7
2000a7ac:	003fcf06 	br	2000a6ec <OSFlagDel+0x88>
             pgrp_return          = pgrp;
             break;
    }
    return (pgrp_return);
}
2000a7b0:	8005883a 	mov	r2,r16
2000a7b4:	dfc00517 	ldw	ra,20(sp)
2000a7b8:	dd000417 	ldw	r20,16(sp)
2000a7bc:	dcc00317 	ldw	r19,12(sp)
2000a7c0:	dc800217 	ldw	r18,8(sp)
2000a7c4:	dc400117 	ldw	r17,4(sp)
2000a7c8:	dc000017 	ldw	r16,0(sp)
2000a7cc:	dec00604 	addi	sp,sp,24
2000a7d0:	f800283a 	ret

2000a7d4 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
2000a7d4:	defff704 	addi	sp,sp,-36
2000a7d8:	dc800215 	stw	r18,8(sp)
2000a7dc:	dfc00815 	stw	ra,32(sp)
2000a7e0:	ddc00715 	stw	r23,28(sp)
2000a7e4:	dd800615 	stw	r22,24(sp)
2000a7e8:	dd400515 	stw	r21,20(sp)
2000a7ec:	dd000415 	stw	r20,16(sp)
2000a7f0:	dcc00315 	stw	r19,12(sp)
2000a7f4:	dc400115 	stw	r17,4(sp)
2000a7f8:	dc000015 	stw	r16,0(sp)
2000a7fc:	3825883a 	mov	r18,r7
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
2000a800:	38005326 	beq	r7,zero,2000a950 <OSFlagPost+0x17c>
2000a804:	2021883a 	mov	r16,r4
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
2000a808:	2000021e 	bne	r4,zero,2000a814 <OSFlagPost+0x40>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
2000a80c:	00801b84 	movi	r2,110
2000a810:	00001f06 	br	2000a890 <OSFlagPost+0xbc>
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
2000a814:	20c00003 	ldbu	r3,0(r4)
2000a818:	00800144 	movi	r2,5
2000a81c:	18800226 	beq	r3,r2,2000a828 <OSFlagPost+0x54>
        *perr = OS_ERR_EVENT_TYPE;
2000a820:	00800044 	movi	r2,1
2000a824:	00001a06 	br	2000a890 <OSFlagPost+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000a828:	002b303a 	rdctl	r21,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000a82c:	00bfff84 	movi	r2,-2
2000a830:	a884703a 	and	r2,r21,r2
2000a834:	1001703a 	wrctl	status,r2
        return ((OS_FLAGS)0);
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    switch (opt) {
2000a838:	31803fcc 	andi	r6,r6,255
2000a83c:	30000526 	beq	r6,zero,2000a854 <OSFlagPost+0x80>
2000a840:	00800044 	movi	r2,1
2000a844:	30800d1e 	bne	r6,r2,2000a87c <OSFlagPost+0xa8>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
             break;

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
2000a848:	2080020b 	ldhu	r2,8(r4)
2000a84c:	288ab03a 	or	r5,r5,r2
2000a850:	00000306 	br	2000a860 <OSFlagPost+0x8c>
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    switch (opt) {
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
2000a854:	2080020b 	ldhu	r2,8(r4)
2000a858:	014a303a 	nor	r5,zero,r5
2000a85c:	288a703a 	and	r5,r5,r2
             break;

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
2000a860:	8140020d 	sth	r5,8(r16)
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
2000a864:	84400117 	ldw	r17,4(r16)
        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
2000a868:	0029883a 	mov	r20,zero
2000a86c:	04c00044 	movi	r19,1
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
        switch (pnode->OSFlagNodeWaitType) {
2000a870:	05800084 	movi	r22,2
2000a874:	05c000c4 	movi	r23,3
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
2000a878:	00001106 	br	2000a8c0 <OSFlagPost+0xec>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000a87c:	a801703a 	wrctl	status,r21
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
             break;

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
2000a880:	00801c44 	movi	r2,113
2000a884:	00000206 	br	2000a890 <OSFlagPost+0xbc>
2000a888:	a801703a 	wrctl	status,r21
                 }
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
2000a88c:	00801bc4 	movi	r2,111
2000a890:	90800005 	stb	r2,0(r18)
2000a894:	00002e06 	br	2000a950 <OSFlagPost+0x17c>
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
        switch (pnode->OSFlagNodeWaitType) {
2000a898:	88800483 	ldbu	r2,18(r17)
2000a89c:	14c00e26 	beq	r2,r19,2000a8d8 <OSFlagPost+0x104>
2000a8a0:	10001826 	beq	r2,zero,2000a904 <OSFlagPost+0x130>
2000a8a4:	1580081e 	bne	r2,r22,2000a8c8 <OSFlagPost+0xf4>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
2000a8a8:	8880040b 	ldhu	r2,16(r17)
2000a8ac:	8140020b 	ldhu	r5,8(r16)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
2000a8b0:	114a703a 	and	r5,r2,r5
2000a8b4:	10bfffcc 	andi	r2,r2,65535
2000a8b8:	28800c26 	beq	r5,r2,2000a8ec <OSFlagPost+0x118>
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
2000a8bc:	8c400017 	ldw	r17,0(r17)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
2000a8c0:	883ff51e 	bne	r17,zero,2000a898 <OSFlagPost+0xc4>
2000a8c4:	00001506 	br	2000a91c <OSFlagPost+0x148>
        switch (pnode->OSFlagNodeWaitType) {
2000a8c8:	15ffef1e 	bne	r2,r23,2000a888 <OSFlagPost+0xb4>
                     }
                 }
                 break;

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
2000a8cc:	8080020b 	ldhu	r2,8(r16)
2000a8d0:	8940040b 	ldhu	r5,16(r17)
2000a8d4:	00000306 	br	2000a8e4 <OSFlagPost+0x110>
                     }
                 }
                 break;

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
2000a8d8:	8140020b 	ldhu	r5,8(r16)
2000a8dc:	8880040b 	ldhu	r2,16(r17)
2000a8e0:	014a303a 	nor	r5,zero,r5
                 if (flags_rdy != (OS_FLAGS)0) {
2000a8e4:	288a703a 	and	r5,r5,r2
2000a8e8:	283ff426 	beq	r5,zero,2000a8bc <OSFlagPost+0xe8>
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
        switch (pnode->OSFlagNodeWaitType) {
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
2000a8ec:	8809883a 	mov	r4,r17
2000a8f0:	000a5d40 	call	2000a5d4 <OS_FlagTaskRdy>
                     if (rdy == OS_TRUE) {
2000a8f4:	10803fcc 	andi	r2,r2,255
2000a8f8:	14fff01e 	bne	r2,r19,2000a8bc <OSFlagPost+0xe8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
2000a8fc:	05000044 	movi	r20,1
2000a900:	003fee06 	br	2000a8bc <OSFlagPost+0xe8>
                 }
                 break;

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
2000a904:	8140020b 	ldhu	r5,8(r16)
2000a908:	8880040b 	ldhu	r2,16(r17)
2000a90c:	014a303a 	nor	r5,zero,r5
2000a910:	288a703a 	and	r5,r5,r2
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
2000a914:	297fffcc 	andi	r5,r5,65535
2000a918:	003fe606 	br	2000a8b4 <OSFlagPost+0xe0>
2000a91c:	a801703a 	wrctl	status,r21
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
2000a920:	a5003fcc 	andi	r20,r20,255
2000a924:	00800044 	movi	r2,1
2000a928:	a080011e 	bne	r20,r2,2000a930 <OSFlagPost+0x15c>
        OS_Sched();
2000a92c:	00098400 	call	20009840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000a930:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000a934:	00bfff84 	movi	r2,-2
2000a938:	1884703a 	and	r2,r3,r2
2000a93c:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    flags_cur = pgrp->OSFlagFlags;
2000a940:	8080020b 	ldhu	r2,8(r16)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000a944:	1801703a 	wrctl	status,r3
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
2000a948:	90000005 	stb	zero,0(r18)
    return (flags_cur);
2000a94c:	00000106 	br	2000a954 <OSFlagPost+0x180>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return ((OS_FLAGS)0);
2000a950:	0005883a 	mov	r2,zero
    OS_ENTER_CRITICAL();
    flags_cur = pgrp->OSFlagFlags;
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
    return (flags_cur);
}
2000a954:	dfc00817 	ldw	ra,32(sp)
2000a958:	ddc00717 	ldw	r23,28(sp)
2000a95c:	dd800617 	ldw	r22,24(sp)
2000a960:	dd400517 	ldw	r21,20(sp)
2000a964:	dd000417 	ldw	r20,16(sp)
2000a968:	dcc00317 	ldw	r19,12(sp)
2000a96c:	dc800217 	ldw	r18,8(sp)
2000a970:	dc400117 	ldw	r17,4(sp)
2000a974:	dc000017 	ldw	r16,0(sp)
2000a978:	dec00904 	addi	sp,sp,36
2000a97c:	f800283a 	ret

2000a980 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
2000a980:	defff204 	addi	sp,sp,-56
2000a984:	dc800815 	stw	r18,32(sp)
2000a988:	dc800e17 	ldw	r18,56(sp)
2000a98c:	dfc00d15 	stw	ra,52(sp)
2000a990:	dd800c15 	stw	r22,48(sp)
2000a994:	dd400b15 	stw	r21,44(sp)
2000a998:	dd000a15 	stw	r20,40(sp)
2000a99c:	dcc00915 	stw	r19,36(sp)
2000a9a0:	dc400715 	stw	r17,28(sp)
2000a9a4:	dc000615 	stw	r16,24(sp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
2000a9a8:	90008f26 	beq	r18,zero,2000abe8 <OSFlagPend+0x268>
2000a9ac:	2021883a 	mov	r16,r4
        return ((OS_FLAGS)0);
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
2000a9b0:	2000021e 	bne	r4,zero,2000a9bc <OSFlagPend+0x3c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
2000a9b4:	00801b84 	movi	r2,110
2000a9b8:	00008606 	br	2000abd4 <OSFlagPend+0x254>
        return ((OS_FLAGS)0);
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
2000a9bc:	00800034 	movhi	r2,0
2000a9c0:	10818104 	addi	r2,r2,1540
2000a9c4:	10800003 	ldbu	r2,0(r2)
2000a9c8:	10000226 	beq	r2,zero,2000a9d4 <OSFlagPend+0x54>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
2000a9cc:	00800084 	movi	r2,2
2000a9d0:	00008006 	br	2000abd4 <OSFlagPend+0x254>
        return ((OS_FLAGS)0);
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
2000a9d4:	00800034 	movhi	r2,0
2000a9d8:	10817304 	addi	r2,r2,1484
2000a9dc:	10800003 	ldbu	r2,0(r2)
2000a9e0:	10000226 	beq	r2,zero,2000a9ec <OSFlagPend+0x6c>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
2000a9e4:	00800344 	movi	r2,13
2000a9e8:	00007a06 	br	2000abd4 <OSFlagPend+0x254>
        return ((OS_FLAGS)0);
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
2000a9ec:	21000003 	ldbu	r4,0(r4)
2000a9f0:	00800144 	movi	r2,5
2000a9f4:	20800226 	beq	r4,r2,2000aa00 <OSFlagPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
2000a9f8:	00800044 	movi	r2,1
2000a9fc:	00007506 	br	2000abd4 <OSFlagPend+0x254>
        return ((OS_FLAGS)0);
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
2000aa00:	00bfe004 	movi	r2,-128
2000aa04:	3084703a 	and	r2,r6,r2
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
2000aa08:	10803fcc 	andi	r2,r2,255
2000aa0c:	2807883a 	mov	r3,r5
2000aa10:	10000326 	beq	r2,zero,2000aa20 <OSFlagPend+0xa0>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
2000aa14:	34c01fcc 	andi	r19,r6,127
        consume    = OS_TRUE;
2000aa18:	04400044 	movi	r17,1
2000aa1c:	00000206 	br	2000aa28 <OSFlagPend+0xa8>
2000aa20:	3027883a 	mov	r19,r6
    } else {
        consume    = OS_FALSE;
2000aa24:	0023883a 	mov	r17,zero
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000aa28:	0029303a 	rdctl	r20,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000aa2c:	00bfff84 	movi	r2,-2
2000aa30:	a084703a 	and	r2,r20,r2
2000aa34:	1001703a 	wrctl	status,r2
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    switch (wait_type) {
2000aa38:	9cc03fcc 	andi	r19,r19,255
2000aa3c:	01400044 	movi	r5,1
2000aa40:	99402826 	beq	r19,r5,2000aae4 <OSFlagPend+0x164>
2000aa44:	98001826 	beq	r19,zero,2000aaa8 <OSFlagPend+0x128>
2000aa48:	00800084 	movi	r2,2
2000aa4c:	98800326 	beq	r19,r2,2000aa5c <OSFlagPend+0xdc>
2000aa50:	008000c4 	movi	r2,3
2000aa54:	98800b26 	beq	r19,r2,2000aa84 <OSFlagPend+0x104>
2000aa58:	00005c06 	br	2000abcc <OSFlagPend+0x24c>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
2000aa5c:	8100020b 	ldhu	r4,8(r16)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
2000aa60:	19bfffcc 	andi	r6,r3,65535
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    switch (wait_type) {
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
2000aa64:	1904703a 	and	r2,r3,r4
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
2000aa68:	123fffcc 	andi	r8,r2,65535
2000aa6c:	41800926 	beq	r8,r6,2000aa94 <OSFlagPend+0x114>
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
2000aa70:	39ffffcc 	andi	r7,r7,65535
2000aa74:	d9c00015 	stw	r7,0(sp)
2000aa78:	8009883a 	mov	r4,r16
2000aa7c:	d9400104 	addi	r5,sp,4
2000aa80:	00002b06 	br	2000ab30 <OSFlagPend+0x1b0>
                 OS_EXIT_CRITICAL();
             }
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
2000aa84:	8100020b 	ldhu	r4,8(r16)
2000aa88:	1904703a 	and	r2,r3,r4
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
2000aa8c:	11bfffcc 	andi	r6,r2,65535
2000aa90:	30002226 	beq	r6,zero,2000ab1c <OSFlagPend+0x19c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
2000aa94:	8c403fcc 	andi	r17,r17,255
2000aa98:	89401b1e 	bne	r17,r5,2000ab08 <OSFlagPend+0x188>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
2000aa9c:	0086303a 	nor	r3,zero,r2
2000aaa0:	1908703a 	and	r4,r3,r4
2000aaa4:	00001706 	br	2000ab04 <OSFlagPend+0x184>
             }
             break;

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
2000aaa8:	8100020b 	ldhu	r4,8(r16)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
2000aaac:	19bfffcc 	andi	r6,r3,65535
             }
             break;

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
2000aab0:	0104303a 	nor	r2,zero,r4
2000aab4:	1884703a 	and	r2,r3,r2
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
2000aab8:	123fffcc 	andi	r8,r2,65535
2000aabc:	4180031e 	bne	r8,r6,2000aacc <OSFlagPend+0x14c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
2000aac0:	8c403fcc 	andi	r17,r17,255
2000aac4:	8940101e 	bne	r17,r5,2000ab08 <OSFlagPend+0x188>
2000aac8:	00000d06 	br	2000ab00 <OSFlagPend+0x180>
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
2000aacc:	39ffffcc 	andi	r7,r7,65535
2000aad0:	d9c00015 	stw	r7,0(sp)
2000aad4:	8009883a 	mov	r4,r16
2000aad8:	d9400104 	addi	r5,sp,4
2000aadc:	000f883a 	mov	r7,zero
2000aae0:	00001406 	br	2000ab34 <OSFlagPend+0x1b4>
                 OS_EXIT_CRITICAL();
             }
             break;

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
2000aae4:	8100020b 	ldhu	r4,8(r16)
2000aae8:	0104303a 	nor	r2,zero,r4
2000aaec:	1884703a 	and	r2,r3,r2
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
2000aaf0:	117fffcc 	andi	r5,r2,65535
2000aaf4:	28000926 	beq	r5,zero,2000ab1c <OSFlagPend+0x19c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
2000aaf8:	8c403fcc 	andi	r17,r17,255
2000aafc:	8cc0021e 	bne	r17,r19,2000ab08 <OSFlagPend+0x188>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
2000ab00:	1108b03a 	or	r4,r2,r4
2000ab04:	8100020d 	sth	r4,8(r16)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
2000ab08:	00c00034 	movhi	r3,0
2000ab0c:	18c18204 	addi	r3,r3,1544
2000ab10:	18c00017 	ldw	r3,0(r3)
2000ab14:	18800b0d 	sth	r2,44(r3)
2000ab18:	00003006 	br	2000abdc <OSFlagPend+0x25c>
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
2000ab1c:	39ffffcc 	andi	r7,r7,65535
2000ab20:	d9c00015 	stw	r7,0(sp)
2000ab24:	8009883a 	mov	r4,r16
2000ab28:	d9400104 	addi	r5,sp,4
2000ab2c:	19bfffcc 	andi	r6,r3,65535
2000ab30:	980f883a 	mov	r7,r19
2000ab34:	000a0b40 	call	2000a0b4 <OS_FlagBlock>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000ab38:	a001703a 	wrctl	status,r20
             flags_rdy = (OS_FLAGS)0;
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
             return (flags_rdy);
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
2000ab3c:	00098400 	call	20009840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ab40:	0029303a 	rdctl	r20,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000ab44:	00bfff84 	movi	r2,-2
2000ab48:	a084703a 	and	r2,r20,r2
2000ab4c:	1001703a 	wrctl	status,r2
    OS_ENTER_CRITICAL();
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
2000ab50:	05800034 	movhi	r22,0
2000ab54:	b5818204 	addi	r22,r22,1544
2000ab58:	b0800017 	ldw	r2,0(r22)
2000ab5c:	15400c43 	ldbu	r21,49(r2)
2000ab60:	a8000c26 	beq	r21,zero,2000ab94 <OSFlagPend+0x214>
        pend_stat                = OSTCBCur->OSTCBStatPend;
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
2000ab64:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
2000ab68:	d9000104 	addi	r4,sp,4
2000ab6c:	000a59c0 	call	2000a59c <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
2000ab70:	b0800017 	ldw	r2,0(r22)
2000ab74:	10000c05 	stb	zero,48(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000ab78:	a001703a 	wrctl	status,r20
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
        switch (pend_stat) {
2000ab7c:	00800084 	movi	r2,2
2000ab80:	a880021e 	bne	r21,r2,2000ab8c <OSFlagPend+0x20c>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
2000ab84:	00800384 	movi	r2,14
2000ab88:	00001206 	br	2000abd4 <OSFlagPend+0x254>
                 break;

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
2000ab8c:	00800284 	movi	r2,10
2000ab90:	00001006 	br	2000abd4 <OSFlagPend+0x254>
                 break;
        }
        return (flags_rdy);
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
2000ab94:	8c403fcc 	andi	r17,r17,255
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
                 break;
        }
        return (flags_rdy);
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
2000ab98:	10800b0b 	ldhu	r2,44(r2)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
2000ab9c:	88000f26 	beq	r17,zero,2000abdc <OSFlagPend+0x25c>
        switch (wait_type) {
2000aba0:	8cc0062e 	bgeu	r17,r19,2000abbc <OSFlagPend+0x23c>
2000aba4:	00c000c4 	movi	r3,3
2000aba8:	1cc00836 	bltu	r3,r19,2000abcc <OSFlagPend+0x24c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
2000abac:	8100020b 	ldhu	r4,8(r16)
2000abb0:	0086303a 	nor	r3,zero,r2
2000abb4:	1906703a 	and	r3,r3,r4
2000abb8:	00000206 	br	2000abc4 <OSFlagPend+0x244>
                 break;

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
2000abbc:	80c0020b 	ldhu	r3,8(r16)
2000abc0:	1886b03a 	or	r3,r3,r2
2000abc4:	80c0020d 	sth	r3,8(r16)
                 break;
2000abc8:	00000406 	br	2000abdc <OSFlagPend+0x25c>
2000abcc:	a001703a 	wrctl	status,r20
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
2000abd0:	00801bc4 	movi	r2,111
2000abd4:	90800005 	stb	r2,0(r18)
2000abd8:	00000306 	br	2000abe8 <OSFlagPend+0x268>
2000abdc:	a001703a 	wrctl	status,r20
                 return ((OS_FLAGS)0);
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
2000abe0:	90000005 	stb	zero,0(r18)
    return (flags_rdy);
2000abe4:	00000106 	br	2000abec <OSFlagPend+0x26c>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return ((OS_FLAGS)0);
2000abe8:	0005883a 	mov	r2,zero
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
    return (flags_rdy);
}
2000abec:	dfc00d17 	ldw	ra,52(sp)
2000abf0:	dd800c17 	ldw	r22,48(sp)
2000abf4:	dd400b17 	ldw	r21,44(sp)
2000abf8:	dd000a17 	ldw	r20,40(sp)
2000abfc:	dcc00917 	ldw	r19,36(sp)
2000ac00:	dc800817 	ldw	r18,32(sp)
2000ac04:	dc400717 	ldw	r17,28(sp)
2000ac08:	dc000617 	ldw	r16,24(sp)
2000ac0c:	dec00e04 	addi	sp,sp,56
2000ac10:	f800283a 	ret

2000ac14 <OSMemCreate>:
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
2000ac14:	38002e26 	beq	r7,zero,2000acd0 <OSMemCreate+0xbc>
        return ((OS_MEM *)0);
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
2000ac18:	2000021e 	bne	r4,zero,2000ac24 <OSMemCreate+0x10>
        *perr = OS_ERR_MEM_INVALID_ADDR;
2000ac1c:	00801884 	movi	r2,98
2000ac20:	00001706 	br	2000ac80 <OSMemCreate+0x6c>
        return ((OS_MEM *)0);
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
2000ac24:	208000cc 	andi	r2,r4,3
2000ac28:	103ffc1e 	bne	r2,zero,2000ac1c <OSMemCreate+0x8>
        *perr = OS_ERR_MEM_INVALID_ADDR;
        return ((OS_MEM *)0);
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
2000ac2c:	00800044 	movi	r2,1
2000ac30:	11400236 	bltu	r2,r5,2000ac3c <OSMemCreate+0x28>
        *perr = OS_ERR_MEM_INVALID_BLKS;
2000ac34:	008016c4 	movi	r2,91
2000ac38:	00001106 	br	2000ac80 <OSMemCreate+0x6c>
        return ((OS_MEM *)0);
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
2000ac3c:	008000c4 	movi	r2,3
2000ac40:	11800236 	bltu	r2,r6,2000ac4c <OSMemCreate+0x38>
        *perr = OS_ERR_MEM_INVALID_SIZE;
2000ac44:	00801704 	movi	r2,92
2000ac48:	00000d06 	br	2000ac80 <OSMemCreate+0x6c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ac4c:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000ac50:	00bfff84 	movi	r2,-2
2000ac54:	1884703a 	and	r2,r3,r2
2000ac58:	1001703a 	wrctl	status,r2
        return ((OS_MEM *)0);
    }
#endif
    OS_ENTER_CRITICAL();
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
2000ac5c:	02000034 	movhi	r8,0
2000ac60:	42017c04 	addi	r8,r8,1520
2000ac64:	40800017 	ldw	r2,0(r8)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
2000ac68:	10000226 	beq	r2,zero,2000ac74 <OSMemCreate+0x60>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
2000ac6c:	12400117 	ldw	r9,4(r2)
2000ac70:	42400015 	stw	r9,0(r8)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000ac74:	1801703a 	wrctl	status,r3
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
2000ac78:	1000031e 	bne	r2,zero,2000ac88 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_PART;
2000ac7c:	00801684 	movi	r2,90
2000ac80:	38800005 	stb	r2,0(r7)
2000ac84:	00001206 	br	2000acd0 <OSMemCreate+0xbc>
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
2000ac88:	2187883a 	add	r3,r4,r6
    for (i = 0; i < (nblks - 1); i++) {
2000ac8c:	2011883a 	mov	r8,r4
2000ac90:	0013883a 	mov	r9,zero
2000ac94:	2abfffc4 	addi	r10,r5,-1
2000ac98:	4a80052e 	bgeu	r9,r10,2000acb0 <OSMemCreate+0x9c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
2000ac9c:	40c00015 	stw	r3,0(r8)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
2000aca0:	4a400044 	addi	r9,r9,1
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
2000aca4:	1811883a 	mov	r8,r3
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
2000aca8:	1987883a 	add	r3,r3,r6
2000acac:	003ffa06 	br	2000ac98 <OSMemCreate+0x84>
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
2000acb0:	40000015 	stw	zero,0(r8)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
2000acb4:	11000015 	stw	r4,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
2000acb8:	11000115 	stw	r4,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
2000acbc:	11400415 	stw	r5,16(r2)
    pmem->OSMemNBlks    = nblks;
2000acc0:	11400315 	stw	r5,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
2000acc4:	11800215 	stw	r6,8(r2)
    *perr               = OS_ERR_NONE;
2000acc8:	38000005 	stb	zero,0(r7)
    return (pmem);
2000accc:	f800283a 	ret



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return ((OS_MEM *)0);
2000acd0:	0005883a 	mov	r2,zero
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
    pmem->OSMemNBlks    = nblks;
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
    *perr               = OS_ERR_NONE;
    return (pmem);
}
2000acd4:	f800283a 	ret

2000acd8 <OSMemGet>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
2000acd8:	28001426 	beq	r5,zero,2000ad2c <OSMemGet+0x54>
        return ((void *)0);
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
2000acdc:	2000021e 	bne	r4,zero,2000ace8 <OSMemGet+0x10>
        *perr = OS_ERR_MEM_INVALID_PMEM;
2000ace0:	00801804 	movi	r2,96
2000ace4:	00001006 	br	2000ad28 <OSMemGet+0x50>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ace8:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000acec:	00bfff84 	movi	r2,-2
2000acf0:	3084703a 	and	r2,r6,r2
2000acf4:	1001703a 	wrctl	status,r2
        return ((void *)0);
    }
#endif
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
2000acf8:	20c00417 	ldw	r3,16(r4)
2000acfc:	18000826 	beq	r3,zero,2000ad20 <OSMemGet+0x48>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
2000ad00:	20800117 	ldw	r2,4(r4)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
2000ad04:	18ffffc4 	addi	r3,r3,-1
    }
#endif
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
2000ad08:	11c00017 	ldw	r7,0(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
2000ad0c:	20c00415 	stw	r3,16(r4)
    }
#endif
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
2000ad10:	21c00115 	stw	r7,4(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000ad14:	3001703a 	wrctl	status,r6
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
2000ad18:	28000005 	stb	zero,0(r5)
        return (pblk);                                /*      Return memory block to caller            */
2000ad1c:	f800283a 	ret
2000ad20:	3001703a 	wrctl	status,r6
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
2000ad24:	00801744 	movi	r2,93
2000ad28:	28800005 	stb	r2,0(r5)



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return ((void *)0);
2000ad2c:	0005883a 	mov	r2,zero
        return (pblk);                                /*      Return memory block to caller            */
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
    return ((void *)0);                               /*      Return NULL pointer to caller            */
}
2000ad30:	f800283a 	ret

2000ad34 <OSMemNameGet>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
2000ad34:	30002126 	beq	r6,zero,2000adbc <OSMemNameGet+0x88>
2000ad38:	2005883a 	mov	r2,r4
        return (0);
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
2000ad3c:	2000021e 	bne	r4,zero,2000ad48 <OSMemNameGet+0x14>
        *perr = OS_ERR_MEM_INVALID_PMEM;
2000ad40:	00801804 	movi	r2,96
2000ad44:	00000206 	br	2000ad50 <OSMemNameGet+0x1c>
        return (0);
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
2000ad48:	2800031e 	bne	r5,zero,2000ad58 <OSMemNameGet+0x24>
        *perr = OS_ERR_PNAME_NULL;
2000ad4c:	00800304 	movi	r2,12
2000ad50:	30800005 	stb	r2,0(r6)
2000ad54:	00001906 	br	2000adbc <OSMemNameGet+0x88>
        return (0);
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
2000ad58:	00c00034 	movhi	r3,0
2000ad5c:	18c18104 	addi	r3,r3,1540
2000ad60:	18c00003 	ldbu	r3,0(r3)
2000ad64:	18000226 	beq	r3,zero,2000ad70 <OSMemNameGet+0x3c>
        *perr = OS_ERR_NAME_GET_ISR;
2000ad68:	00800444 	movi	r2,17
2000ad6c:	003ff806 	br	2000ad50 <OSMemNameGet+0x1c>
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
2000ad70:	defffd04 	addi	sp,sp,-12
2000ad74:	dc000015 	stw	r16,0(sp)
2000ad78:	2809883a 	mov	r4,r5
2000ad7c:	3021883a 	mov	r16,r6
2000ad80:	dfc00215 	stw	ra,8(sp)
2000ad84:	dc400115 	stw	r17,4(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ad88:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000ad8c:	00ffff84 	movi	r3,-2
2000ad90:	88c6703a 	and	r3,r17,r3
2000ad94:	1801703a 	wrctl	status,r3
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        *perr = OS_ERR_NAME_GET_ISR;
        return (0);
    }
    OS_ENTER_CRITICAL();
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
2000ad98:	11400504 	addi	r5,r2,20
2000ad9c:	0009c500 	call	20009c50 <OS_StrCopy>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000ada0:	8801703a 	wrctl	status,r17
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2000ada4:	80000005 	stb	zero,0(r16)
    return (len);
}
2000ada8:	dfc00217 	ldw	ra,8(sp)
2000adac:	dc400117 	ldw	r17,4(sp)
2000adb0:	dc000017 	ldw	r16,0(sp)
2000adb4:	dec00304 	addi	sp,sp,12
2000adb8:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return (0);
2000adbc:	0005883a 	mov	r2,zero
2000adc0:	f800283a 	ret

2000adc4 <OSMemNameSet>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
2000adc4:	30002e26 	beq	r6,zero,2000ae80 <OSMemNameSet+0xbc>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
2000adc8:	2000021e 	bne	r4,zero,2000add4 <OSMemNameSet+0x10>
        *perr = OS_ERR_MEM_INVALID_PMEM;
2000adcc:	00801804 	movi	r2,96
2000add0:	00000806 	br	2000adf4 <OSMemNameSet+0x30>
        return;
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
2000add4:	2800021e 	bne	r5,zero,2000ade0 <OSMemNameSet+0x1c>
        *perr = OS_ERR_PNAME_NULL;
2000add8:	00800304 	movi	r2,12
2000addc:	00000506 	br	2000adf4 <OSMemNameSet+0x30>
        return;
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
2000ade0:	00800034 	movhi	r2,0
2000ade4:	10818104 	addi	r2,r2,1540
2000ade8:	10800003 	ldbu	r2,0(r2)
2000adec:	10000326 	beq	r2,zero,2000adfc <OSMemNameSet+0x38>
        *perr = OS_ERR_NAME_SET_ISR;
2000adf0:	00800484 	movi	r2,18
2000adf4:	30800005 	stb	r2,0(r6)
2000adf8:	f800283a 	ret
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
2000adfc:	defffb04 	addi	sp,sp,-20
2000ae00:	dc800215 	stw	r18,8(sp)
2000ae04:	dc400115 	stw	r17,4(sp)
2000ae08:	dc000015 	stw	r16,0(sp)
2000ae0c:	3023883a 	mov	r17,r6
2000ae10:	2821883a 	mov	r16,r5
2000ae14:	2025883a 	mov	r18,r4
2000ae18:	dfc00415 	stw	ra,16(sp)
2000ae1c:	dcc00315 	stw	r19,12(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ae20:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000ae24:	00bfff84 	movi	r2,-2
2000ae28:	9884703a 	and	r2,r19,r2
2000ae2c:	1001703a 	wrctl	status,r2
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        *perr = OS_ERR_NAME_SET_ISR;
        return;
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
2000ae30:	2809883a 	mov	r4,r5
2000ae34:	0009d240 	call	20009d24 <OS_StrLen>
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
2000ae38:	10803fcc 	andi	r2,r2,255
2000ae3c:	00c007c4 	movi	r3,31
2000ae40:	1880042e 	bgeu	r3,r2,2000ae54 <OSMemNameSet+0x90>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000ae44:	9801703a 	wrctl	status,r19
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
2000ae48:	008018c4 	movi	r2,99
2000ae4c:	88800005 	stb	r2,0(r17)
        return;
2000ae50:	00000506 	br	2000ae68 <OSMemNameSet+0xa4>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
2000ae54:	91000504 	addi	r4,r18,20
2000ae58:	800b883a 	mov	r5,r16
2000ae5c:	0009c500 	call	20009c50 <OS_StrCopy>
2000ae60:	9801703a 	wrctl	status,r19
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2000ae64:	88000005 	stb	zero,0(r17)
}
2000ae68:	dfc00417 	ldw	ra,16(sp)
2000ae6c:	dcc00317 	ldw	r19,12(sp)
2000ae70:	dc800217 	ldw	r18,8(sp)
2000ae74:	dc400117 	ldw	r17,4(sp)
2000ae78:	dc000017 	ldw	r16,0(sp)
2000ae7c:	dec00504 	addi	sp,sp,20
2000ae80:	f800283a 	ret

2000ae84 <OSMemPut>:
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
2000ae84:	20001326 	beq	r4,zero,2000aed4 <OSMemPut+0x50>
        return (OS_ERR_MEM_INVALID_PMEM);
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
2000ae88:	28001426 	beq	r5,zero,2000aedc <OSMemPut+0x58>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ae8c:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000ae90:	00bfff84 	movi	r2,-2
2000ae94:	1884703a 	and	r2,r3,r2
2000ae98:	1001703a 	wrctl	status,r2
        return (OS_ERR_MEM_INVALID_PBLK);
    }
#endif
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
2000ae9c:	20800417 	ldw	r2,16(r4)
2000aea0:	21800317 	ldw	r6,12(r4)
2000aea4:	11800336 	bltu	r2,r6,2000aeb4 <OSMemPut+0x30>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000aea8:	1801703a 	wrctl	status,r3
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
2000aeac:	00801784 	movi	r2,94
2000aeb0:	f800283a 	ret
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
2000aeb4:	21800117 	ldw	r6,4(r4)
    pmem->OSMemFreeList = pblk;
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
2000aeb8:	10800044 	addi	r2,r2,1
    OS_ENTER_CRITICAL();
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
2000aebc:	29800015 	stw	r6,0(r5)
    pmem->OSMemFreeList = pblk;
2000aec0:	21400115 	stw	r5,4(r4)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
2000aec4:	20800415 	stw	r2,16(r4)
2000aec8:	1801703a 	wrctl	status,r3
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
2000aecc:	0005883a 	mov	r2,zero
2000aed0:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
        return (OS_ERR_MEM_INVALID_PMEM);
2000aed4:	00801804 	movi	r2,96
2000aed8:	f800283a 	ret
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
        return (OS_ERR_MEM_INVALID_PBLK);
2000aedc:	008017c4 	movi	r2,95
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
    pmem->OSMemFreeList = pblk;
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
}
2000aee0:	f800283a 	ret

2000aee4 <OSMemQuery>:
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
2000aee4:	20001426 	beq	r4,zero,2000af38 <OSMemQuery+0x54>
        return (OS_ERR_MEM_INVALID_PMEM);
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
2000aee8:	28001526 	beq	r5,zero,2000af40 <OSMemQuery+0x5c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000aeec:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000aef0:	00bfff84 	movi	r2,-2
2000aef4:	3084703a 	and	r2,r6,r2
2000aef8:	1001703a 	wrctl	status,r2
        return (OS_ERR_MEM_INVALID_PDATA);
    }
#endif
    OS_ENTER_CRITICAL();
    p_mem_data->OSAddr     = pmem->OSMemAddr;
2000aefc:	20800017 	ldw	r2,0(r4)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
    p_mem_data->OSNFree    = pmem->OSMemNFree;
2000af00:	20c00417 	ldw	r3,16(r4)
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
        return (OS_ERR_MEM_INVALID_PDATA);
    }
#endif
    OS_ENTER_CRITICAL();
    p_mem_data->OSAddr     = pmem->OSMemAddr;
2000af04:	28800015 	stw	r2,0(r5)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
2000af08:	20800117 	ldw	r2,4(r4)
2000af0c:	28800115 	stw	r2,4(r5)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
2000af10:	20800217 	ldw	r2,8(r4)
2000af14:	28800215 	stw	r2,8(r5)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
2000af18:	20800317 	ldw	r2,12(r4)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
2000af1c:	28c00415 	stw	r3,16(r5)
#endif
    OS_ENTER_CRITICAL();
    p_mem_data->OSAddr     = pmem->OSMemAddr;
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
2000af20:	28800315 	stw	r2,12(r5)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000af24:	3001703a 	wrctl	status,r6
    p_mem_data->OSNFree    = pmem->OSMemNFree;
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
2000af28:	10c5c83a 	sub	r2,r2,r3
2000af2c:	28800515 	stw	r2,20(r5)
    return (OS_ERR_NONE);
2000af30:	0005883a 	mov	r2,zero
2000af34:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
        return (OS_ERR_MEM_INVALID_PMEM);
2000af38:	00801804 	movi	r2,96
2000af3c:	f800283a 	ret
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
        return (OS_ERR_MEM_INVALID_PDATA);
2000af40:	00801844 	movi	r2,97
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
    p_mem_data->OSNFree    = pmem->OSMemNFree;
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
    return (OS_ERR_NONE);
}
2000af44:	f800283a 	ret

2000af48 <OS_MemInit>:
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
2000af48:	01000034 	movhi	r4,0
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
2000af4c:	deffff04 	addi	sp,sp,-4
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
2000af50:	21126804 	addi	r4,r4,18848
2000af54:	01430c04 	movi	r5,3120
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
2000af58:	dfc00015 	stw	ra,0(sp)
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
2000af5c:	00095f00 	call	200095f0 <OS_MemClr>
2000af60:	00800034 	movhi	r2,0
2000af64:	10926904 	addi	r2,r2,18852
2000af68:	01000ec4 	movi	r4,59
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
2000af6c:	01400fc4 	movi	r5,63
2000af70:	10c00c04 	addi	r3,r2,48


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
2000af74:	10c00015 	stw	r3,0(r2)
2000af78:	20ffffc4 	addi	r3,r4,-1
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
2000af7c:	11400405 	stb	r5,16(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
2000af80:	10000445 	stb	zero,17(r2)
2000af84:	1809883a 	mov	r4,r3
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
2000af88:	18ffffcc 	andi	r3,r3,65535
2000af8c:	10800d04 	addi	r2,r2,52
2000af90:	183ff71e 	bne	r3,zero,2000af70 <OS_MemInit+0x28>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
2000af94:	00800034 	movhi	r2,0
2000af98:	10926804 	addi	r2,r2,18848
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
2000af9c:	00c00fc4 	movi	r3,63
2000afa0:	10c30405 	stb	r3,3088(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
2000afa4:	00c00034 	movhi	r3,0
2000afa8:	18c17c04 	addi	r3,r3,1520
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
2000afac:	10030015 	stw	zero,3072(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
    pmem->OSMemName[1]  = OS_ASCII_NUL;
2000afb0:	10030445 	stb	zero,3089(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
2000afb4:	18800015 	stw	r2,0(r3)
#endif
}
2000afb8:	dfc00017 	ldw	ra,0(sp)
2000afbc:	dec00104 	addi	sp,sp,4
2000afc0:	f800283a 	ret

2000afc4 <OSQAccept>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
2000afc4:	28002226 	beq	r5,zero,2000b050 <OSQAccept+0x8c>
        return ((void *)0);
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
2000afc8:	2000021e 	bne	r4,zero,2000afd4 <OSQAccept+0x10>
        *perr = OS_ERR_PEVENT_NULL;
2000afcc:	00800104 	movi	r2,4
2000afd0:	00000406 	br	2000afe4 <OSQAccept+0x20>
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
2000afd4:	20c00003 	ldbu	r3,0(r4)
2000afd8:	00800084 	movi	r2,2
2000afdc:	18800326 	beq	r3,r2,2000afec <OSQAccept+0x28>
        *perr = OS_ERR_EVENT_TYPE;
2000afe0:	00800044 	movi	r2,1
2000afe4:	28800005 	stb	r2,0(r5)
2000afe8:	00001906 	br	2000b050 <OSQAccept+0x8c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000afec:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000aff0:	00bfff84 	movi	r2,-2
2000aff4:	3084703a 	and	r2,r6,r2
2000aff8:	1001703a 	wrctl	status,r2
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
2000affc:	20c00117 	ldw	r3,4(r4)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
2000b000:	1900058b 	ldhu	r4,22(r3)
2000b004:	20bfffcc 	andi	r2,r4,65535
2000b008:	10000c26 	beq	r2,zero,2000b03c <OSQAccept+0x78>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
2000b00c:	18800417 	ldw	r2,16(r3)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
2000b010:	213fffc4 	addi	r4,r4,-1
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
2000b014:	11c00104 	addi	r7,r2,4
2000b018:	19c00415 	stw	r7,16(r3)
2000b01c:	10800017 	ldw	r2,0(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
2000b020:	1900058d 	sth	r4,22(r3)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
2000b024:	19000217 	ldw	r4,8(r3)
2000b028:	3900021e 	bne	r7,r4,2000b034 <OSQAccept+0x70>
            pq->OSQOut = pq->OSQStart;
2000b02c:	19000117 	ldw	r4,4(r3)
2000b030:	19000415 	stw	r4,16(r3)
        }
        *perr = OS_ERR_NONE;
2000b034:	28000005 	stb	zero,0(r5)
2000b038:	00000306 	br	2000b048 <OSQAccept+0x84>
    } else {
        *perr = OS_ERR_Q_EMPTY;
2000b03c:	008007c4 	movi	r2,31
2000b040:	28800005 	stb	r2,0(r5)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
2000b044:	0005883a 	mov	r2,zero
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b048:	3001703a 	wrctl	status,r6
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
2000b04c:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return ((void *)0);
2000b050:	0005883a 	mov	r2,zero
        *perr = OS_ERR_Q_EMPTY;
        pmsg  = (void *)0;                       /* Queue is empty                                     */
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
}
2000b054:	f800283a 	ret

2000b058 <OSQCreate>:
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
2000b058:	00800034 	movhi	r2,0
2000b05c:	10818104 	addi	r2,r2,1540
2000b060:	10800003 	ldbu	r2,0(r2)
2000b064:	1000371e 	bne	r2,zero,2000b144 <OSQCreate+0xec>
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
2000b068:	defffe04 	addi	sp,sp,-8
2000b06c:	dfc00115 	stw	ra,4(sp)
2000b070:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b074:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b078:	00bfff84 	movi	r2,-2
2000b07c:	3086703a 	and	r3,r6,r2
2000b080:	1801703a 	wrctl	status,r3

    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    }
    OS_ENTER_CRITICAL();
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
2000b084:	00c00034 	movhi	r3,0
2000b088:	18c18004 	addi	r3,r3,1536
2000b08c:	1c000017 	ldw	r16,0(r3)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
2000b090:	80000226 	beq	r16,zero,2000b09c <OSQCreate+0x44>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
2000b094:	81c00117 	ldw	r7,4(r16)
2000b098:	19c00015 	stw	r7,0(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b09c:	3001703a 	wrctl	status,r6
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
2000b0a0:	80002326 	beq	r16,zero,2000b130 <OSQCreate+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b0a4:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b0a8:	3084703a 	and	r2,r6,r2
2000b0ac:	1001703a 	wrctl	status,r2
        OS_ENTER_CRITICAL();
        pq = OSQFreeList;                        /* Get a free queue control block                     */
2000b0b0:	01c00034 	movhi	r7,0
2000b0b4:	39c17e04 	addi	r7,r7,1528
2000b0b8:	38800017 	ldw	r2,0(r7)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
2000b0bc:	10001826 	beq	r2,zero,2000b120 <OSQCreate+0xc8>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
2000b0c0:	10c00017 	ldw	r3,0(r2)
2000b0c4:	38c00015 	stw	r3,0(r7)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b0c8:	3001703a 	wrctl	status,r6
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
            pq->OSQEnd             = &start[size];
2000b0cc:	28ffffcc 	andi	r3,r5,65535
2000b0d0:	18c7883a 	add	r3,r3,r3
2000b0d4:	18c7883a 	add	r3,r3,r3
2000b0d8:	20c7883a 	add	r3,r4,r3
        OS_ENTER_CRITICAL();
        pq = OSQFreeList;                        /* Get a free queue control block                     */
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
2000b0dc:	11000115 	stw	r4,4(r2)
            pq->OSQEnd             = &start[size];
2000b0e0:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
2000b0e4:	11000315 	stw	r4,12(r2)
            pq->OSQOut             = start;
2000b0e8:	11000415 	stw	r4,16(r2)
            pq->OSQSize            = size;
2000b0ec:	1140050d 	sth	r5,20(r2)
            pq->OSQEntries         = 0;
2000b0f0:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
2000b0f4:	00c00084 	movi	r3,2
            pevent->OSEventCnt     = 0;
            pevent->OSEventPtr     = pq;
2000b0f8:	80800115 	stw	r2,4(r16)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
2000b0fc:	00800fc4 	movi	r2,63
2000b100:	80800385 	stb	r2,14(r16)
            pq->OSQEnd             = &start[size];
            pq->OSQIn              = start;
            pq->OSQOut             = start;
            pq->OSQSize            = size;
            pq->OSQEntries         = 0;
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
2000b104:	80c00005 	stb	r3,0(r16)
            pevent->OSEventCnt     = 0;
2000b108:	8000020d 	sth	zero,8(r16)
            pevent->OSEventPtr     = pq;
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
            pevent->OSEventName[1] = OS_ASCII_NUL;
2000b10c:	800003c5 	stb	zero,15(r16)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
2000b110:	8009883a 	mov	r4,r16
2000b114:	00095dc0 	call	200095dc <OS_EventWaitListInit>
2000b118:	8005883a 	mov	r2,r16
2000b11c:	00000506 	br	2000b134 <OSQCreate+0xdc>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
2000b120:	18800017 	ldw	r2,0(r3)
            OSEventFreeList    = pevent;
2000b124:	1c000015 	stw	r16,0(r3)
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
            pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
2000b128:	80800115 	stw	r2,4(r16)
2000b12c:	3001703a 	wrctl	status,r6
            OSEventFreeList    = pevent;
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
2000b130:	0005883a 	mov	r2,zero
        }
    }
    return (pevent);
}
2000b134:	dfc00117 	ldw	ra,4(sp)
2000b138:	dc000017 	ldw	r16,0(sp)
2000b13c:	dec00204 	addi	sp,sp,8
2000b140:	f800283a 	ret
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
2000b144:	0005883a 	mov	r2,zero
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
        }
    }
    return (pevent);
}
2000b148:	f800283a 	ret

2000b14c <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
2000b14c:	defffb04 	addi	sp,sp,-20
2000b150:	dc400115 	stw	r17,4(sp)
2000b154:	dc000015 	stw	r16,0(sp)
2000b158:	dfc00415 	stw	ra,16(sp)
2000b15c:	dcc00315 	stw	r19,12(sp)
2000b160:	dc800215 	stw	r18,8(sp)
2000b164:	2021883a 	mov	r16,r4
2000b168:	3023883a 	mov	r17,r6
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
2000b16c:	30005726 	beq	r6,zero,2000b2cc <OSQDel+0x180>
        return (pevent);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
2000b170:	2000021e 	bne	r4,zero,2000b17c <OSQDel+0x30>
        *perr = OS_ERR_PEVENT_NULL;
2000b174:	00800104 	movi	r2,4
2000b178:	00001506 	br	2000b1d0 <OSQDel+0x84>
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
2000b17c:	20c00003 	ldbu	r3,0(r4)
2000b180:	00800084 	movi	r2,2
2000b184:	18800226 	beq	r3,r2,2000b190 <OSQDel+0x44>
        *perr = OS_ERR_EVENT_TYPE;
2000b188:	00800044 	movi	r2,1
2000b18c:	00001006 	br	2000b1d0 <OSQDel+0x84>
        return (pevent);
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
2000b190:	00800034 	movhi	r2,0
2000b194:	10818104 	addi	r2,r2,1540
2000b198:	10800003 	ldbu	r2,0(r2)
2000b19c:	10000226 	beq	r2,zero,2000b1a8 <OSQDel+0x5c>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
2000b1a0:	008003c4 	movi	r2,15
2000b1a4:	00000a06 	br	2000b1d0 <OSQDel+0x84>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b1a8:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b1ac:	00bfff84 	movi	r2,-2
2000b1b0:	9884703a 	and	r2,r19,r2
2000b1b4:	1001703a 	wrctl	status,r2
        return (pevent);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
2000b1b8:	20c00283 	ldbu	r3,10(r4)
2000b1bc:	28803fcc 	andi	r2,r5,255
2000b1c0:	18000526 	beq	r3,zero,2000b1d8 <OSQDel+0x8c>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
2000b1c4:	1000331e 	bne	r2,zero,2000b294 <OSQDel+0x148>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b1c8:	9801703a 	wrctl	status,r19
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
2000b1cc:	00801244 	movi	r2,73
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
             break;

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
2000b1d0:	88800005 	stb	r2,0(r17)
             pevent_return          = pevent;
             break;
2000b1d4:	00003d06 	br	2000b2cc <OSQDel+0x180>
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
2000b1d8:	10002a1e 	bne	r2,zero,2000b284 <OSQDel+0x138>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
2000b1dc:	00800fc4 	movi	r2,63
2000b1e0:	80800385 	stb	r2,14(r16)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
                 pq->OSQPtr             = OSQFreeList;
2000b1e4:	00800034 	movhi	r2,0
2000b1e8:	10817e04 	addi	r2,r2,1528
2000b1ec:	11000017 	ldw	r4,0(r2)
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
2000b1f0:	80c00117 	ldw	r3,4(r16)
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
2000b1f4:	800003c5 	stb	zero,15(r16)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
                 pq->OSQPtr             = OSQFreeList;
2000b1f8:	19000015 	stw	r4,0(r3)
                 OSQFreeList            = pq;
2000b1fc:	10c00015 	stw	r3,0(r2)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
2000b200:	00800034 	movhi	r2,0
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
                 pq->OSQPtr             = OSQFreeList;
                 OSQFreeList            = pq;
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
2000b204:	80000005 	stb	zero,0(r16)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
2000b208:	10818004 	addi	r2,r2,1536
2000b20c:	10c00017 	ldw	r3,0(r2)
                 pevent->OSEventCnt     = 0;
2000b210:	8000020d 	sth	zero,8(r16)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
2000b214:	14000015 	stw	r16,0(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
                 pq->OSQPtr             = OSQFreeList;
                 OSQFreeList            = pq;
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
2000b218:	80c00115 	stw	r3,4(r16)
2000b21c:	9801703a 	wrctl	status,r19
2000b220:	00001506 	br	2000b278 <OSQDel+0x12c>
        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
2000b224:	00800fc4 	movi	r2,63
2000b228:	80800385 	stb	r2,14(r16)
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
             pq->OSQPtr             = OSQFreeList;
2000b22c:	00800034 	movhi	r2,0
2000b230:	10817e04 	addi	r2,r2,1528
2000b234:	11000017 	ldw	r4,0(r2)
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
2000b238:	80c00117 	ldw	r3,4(r16)
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
2000b23c:	800003c5 	stb	zero,15(r16)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
             pq->OSQPtr             = OSQFreeList;
2000b240:	19000015 	stw	r4,0(r3)
             OSQFreeList            = pq;
2000b244:	10c00015 	stw	r3,0(r2)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
2000b248:	00800034 	movhi	r2,0
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
             pq->OSQPtr             = OSQFreeList;
             OSQFreeList            = pq;
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
2000b24c:	80000005 	stb	zero,0(r16)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
2000b250:	10818004 	addi	r2,r2,1536
2000b254:	10c00017 	ldw	r3,0(r2)
             pevent->OSEventCnt     = 0;
2000b258:	8000020d 	sth	zero,8(r16)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
2000b25c:	14000015 	stw	r16,0(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
             pq->OSQPtr             = OSQFreeList;
             OSQFreeList            = pq;
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
2000b260:	80c00115 	stw	r3,4(r16)
2000b264:	9801703a 	wrctl	status,r19
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
2000b268:	94803fcc 	andi	r18,r18,255
2000b26c:	00800044 	movi	r2,1
2000b270:	9080011e 	bne	r18,r2,2000b278 <OSQDel+0x12c>
                 OS_Sched();                               /* Find highest priority task ready to run  */
2000b274:	00098400 	call	20009840 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
2000b278:	88000005 	stb	zero,0(r17)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
2000b27c:	0021883a 	mov	r16,zero
             break;
2000b280:	00001206 	br	2000b2cc <OSQDel+0x180>
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
2000b284:	00c00044 	movi	r3,1
2000b288:	10c00d1e 	bne	r2,r3,2000b2c0 <OSQDel+0x174>
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
2000b28c:	0025883a 	mov	r18,zero
2000b290:	00000306 	br	2000b2a0 <OSQDel+0x154>
    }
    switch (opt) {
2000b294:	00c00044 	movi	r3,1
2000b298:	10c0091e 	bne	r2,r3,2000b2c0 <OSQDel+0x174>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
2000b29c:	2825883a 	mov	r18,r5
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
2000b2a0:	80800283 	ldbu	r2,10(r16)
2000b2a4:	103fdf26 	beq	r2,zero,2000b224 <OSQDel+0xd8>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
2000b2a8:	8009883a 	mov	r4,r16
2000b2ac:	000b883a 	mov	r5,zero
2000b2b0:	01800104 	movi	r6,4
2000b2b4:	000f883a 	mov	r7,zero
2000b2b8:	00094f00 	call	200094f0 <OS_EventTaskRdy>
2000b2bc:	003ff806 	br	2000b2a0 <OSQDel+0x154>
2000b2c0:	9801703a 	wrctl	status,r19
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
             break;

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
2000b2c4:	008001c4 	movi	r2,7
2000b2c8:	003fc106 	br	2000b1d0 <OSQDel+0x84>
             pevent_return          = pevent;
             break;
    }
    return (pevent_return);
}
2000b2cc:	8005883a 	mov	r2,r16
2000b2d0:	dfc00417 	ldw	ra,16(sp)
2000b2d4:	dcc00317 	ldw	r19,12(sp)
2000b2d8:	dc800217 	ldw	r18,8(sp)
2000b2dc:	dc400117 	ldw	r17,4(sp)
2000b2e0:	dc000017 	ldw	r16,0(sp)
2000b2e4:	dec00504 	addi	sp,sp,20
2000b2e8:	f800283a 	ret

2000b2ec <OSQFlush>:
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
2000b2ec:	20000f26 	beq	r4,zero,2000b32c <OSQFlush+0x40>
        return (OS_ERR_PEVENT_NULL);
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
2000b2f0:	20c00003 	ldbu	r3,0(r4)
2000b2f4:	00800084 	movi	r2,2
2000b2f8:	18800e1e 	bne	r3,r2,2000b334 <OSQFlush+0x48>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b2fc:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b300:	00bfff84 	movi	r2,-2
2000b304:	1884703a 	and	r2,r3,r2
2000b308:	1001703a 	wrctl	status,r2
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
2000b30c:	20800117 	ldw	r2,4(r4)
    pq->OSQIn      = pq->OSQStart;
2000b310:	11000117 	ldw	r4,4(r2)
    pq->OSQOut     = pq->OSQStart;
    pq->OSQEntries = 0;
2000b314:	1000058d 	sth	zero,22(r2)
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
    pq->OSQIn      = pq->OSQStart;
2000b318:	11000315 	stw	r4,12(r2)
    pq->OSQOut     = pq->OSQStart;
2000b31c:	11000415 	stw	r4,16(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b320:	1801703a 	wrctl	status,r3
    pq->OSQEntries = 0;
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
2000b324:	0005883a 	mov	r2,zero
2000b328:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
2000b32c:	00800104 	movi	r2,4
2000b330:	f800283a 	ret
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
2000b334:	00800044 	movi	r2,1
    pq->OSQIn      = pq->OSQStart;
    pq->OSQOut     = pq->OSQStart;
    pq->OSQEntries = 0;
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
}
2000b338:	f800283a 	ret

2000b33c <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
2000b33c:	defff904 	addi	sp,sp,-28
2000b340:	dc000015 	stw	r16,0(sp)
2000b344:	dfc00615 	stw	ra,24(sp)
2000b348:	dd400515 	stw	r21,20(sp)
2000b34c:	dd000415 	stw	r20,16(sp)
2000b350:	dcc00315 	stw	r19,12(sp)
2000b354:	dc800215 	stw	r18,8(sp)
2000b358:	dc400115 	stw	r17,4(sp)
2000b35c:	3021883a 	mov	r16,r6
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
2000b360:	30004f26 	beq	r6,zero,2000b4a0 <OSQPend+0x164>
2000b364:	2025883a 	mov	r18,r4
        return ((void *)0);
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
2000b368:	2000021e 	bne	r4,zero,2000b374 <OSQPend+0x38>
        *perr = OS_ERR_PEVENT_NULL;
2000b36c:	00800104 	movi	r2,4
2000b370:	00000406 	br	2000b384 <OSQPend+0x48>
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
2000b374:	25000003 	ldbu	r20,0(r4)
2000b378:	00800084 	movi	r2,2
2000b37c:	a0800326 	beq	r20,r2,2000b38c <OSQPend+0x50>
        *perr = OS_ERR_EVENT_TYPE;
2000b380:	00800044 	movi	r2,1
2000b384:	80800005 	stb	r2,0(r16)
2000b388:	00004506 	br	2000b4a0 <OSQPend+0x164>
        return ((void *)0);
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
2000b38c:	00800034 	movhi	r2,0
2000b390:	10818104 	addi	r2,r2,1540
2000b394:	10800003 	ldbu	r2,0(r2)
2000b398:	10000226 	beq	r2,zero,2000b3a4 <OSQPend+0x68>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
2000b39c:	35000005 	stb	r20,0(r6)
2000b3a0:	00003f06 	br	2000b4a0 <OSQPend+0x164>
        return ((void *)0);
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
2000b3a4:	00800034 	movhi	r2,0
2000b3a8:	10817304 	addi	r2,r2,1484
2000b3ac:	10800003 	ldbu	r2,0(r2)
2000b3b0:	10000226 	beq	r2,zero,2000b3bc <OSQPend+0x80>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
2000b3b4:	00800344 	movi	r2,13
2000b3b8:	003ff206 	br	2000b384 <OSQPend+0x48>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b3bc:	002b303a 	rdctl	r21,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b3c0:	04ffff84 	movi	r19,-2
2000b3c4:	acc4703a 	and	r2,r21,r19
2000b3c8:	1001703a 	wrctl	status,r2
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
2000b3cc:	20c00117 	ldw	r3,4(r4)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
2000b3d0:	1980058b 	ldhu	r6,22(r3)
2000b3d4:	30bfffcc 	andi	r2,r6,65535
2000b3d8:	10000d26 	beq	r2,zero,2000b410 <OSQPend+0xd4>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
2000b3dc:	18800417 	ldw	r2,16(r3)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
2000b3e0:	19400217 	ldw	r5,8(r3)
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
2000b3e4:	31bfffc4 	addi	r6,r6,-1
        return ((void *)0);
    }
    OS_ENTER_CRITICAL();
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
2000b3e8:	11000104 	addi	r4,r2,4
2000b3ec:	19000415 	stw	r4,16(r3)
2000b3f0:	10800017 	ldw	r2,0(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
2000b3f4:	1980058d 	sth	r6,22(r3)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
2000b3f8:	2140021e 	bne	r4,r5,2000b404 <OSQPend+0xc8>
            pq->OSQOut = pq->OSQStart;
2000b3fc:	19000117 	ldw	r4,4(r3)
2000b400:	19000415 	stw	r4,16(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b404:	a801703a 	wrctl	status,r21
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
2000b408:	80000005 	stb	zero,0(r16)
        return (pmsg);                           /* Return message received                            */
2000b40c:	00002506 	br	2000b4a4 <OSQPend+0x168>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
2000b410:	04400034 	movhi	r17,0
2000b414:	8c418204 	addi	r17,r17,1544
2000b418:	88800017 	ldw	r2,0(r17)
2000b41c:	10c00c03 	ldbu	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
2000b420:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
2000b424:	11400b8d 	sth	r5,46(r2)
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
        return (pmsg);                           /* Return message received                            */
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
2000b428:	18c00114 	ori	r3,r3,4
2000b42c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
2000b430:	00093780 	call	20009378 <OS_EventTaskWait>
2000b434:	a801703a 	wrctl	status,r21
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
2000b438:	00098400 	call	20009840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b43c:	002b303a 	rdctl	r21,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b440:	ace6703a 	and	r19,r21,r19
2000b444:	9801703a 	wrctl	status,r19
    OS_ENTER_CRITICAL();
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
2000b448:	89000017 	ldw	r4,0(r17)
2000b44c:	20800c43 	ldbu	r2,49(r4)
2000b450:	10000326 	beq	r2,zero,2000b460 <OSQPend+0x124>
2000b454:	1500051e 	bne	r2,r20,2000b46c <OSQPend+0x130>
            *perr =  OS_ERR_NONE;
             break;

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
2000b458:	00800384 	movi	r2,14
2000b45c:	00000606 	br	2000b478 <OSQPend+0x13c>
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
    OS_ENTER_CRITICAL();
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
2000b460:	20800917 	ldw	r2,36(r4)
            *perr =  OS_ERR_NONE;
2000b464:	80000005 	stb	zero,0(r16)
             break;
2000b468:	00000506 	br	2000b480 <OSQPend+0x144>
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
             break;

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
2000b46c:	900b883a 	mov	r5,r18
2000b470:	00094640 	call	20009464 <OS_EventTaskRemove>
             pmsg = (void *)0;
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
2000b474:	00800284 	movi	r2,10
2000b478:	80800005 	stb	r2,0(r16)
             break;

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
             pmsg = (void *)0;
2000b47c:	0005883a 	mov	r2,zero
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
2000b480:	88c00017 	ldw	r3,0(r17)
2000b484:	18000c05 	stb	zero,48(r3)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
2000b488:	18000c45 	stb	zero,49(r3)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
2000b48c:	18000715 	stw	zero,28(r3)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
2000b490:	18000815 	stw	zero,32(r3)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
2000b494:	18000915 	stw	zero,36(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b498:	a801703a 	wrctl	status,r21
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
2000b49c:	00000106 	br	2000b4a4 <OSQPend+0x168>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return ((void *)0);
2000b4a0:	0005883a 	mov	r2,zero
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
}
2000b4a4:	dfc00617 	ldw	ra,24(sp)
2000b4a8:	dd400517 	ldw	r21,20(sp)
2000b4ac:	dd000417 	ldw	r20,16(sp)
2000b4b0:	dcc00317 	ldw	r19,12(sp)
2000b4b4:	dc800217 	ldw	r18,8(sp)
2000b4b8:	dc400117 	ldw	r17,4(sp)
2000b4bc:	dc000017 	ldw	r16,0(sp)
2000b4c0:	dec00704 	addi	sp,sp,28
2000b4c4:	f800283a 	ret

2000b4c8 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
2000b4c8:	defffb04 	addi	sp,sp,-20
2000b4cc:	dc400115 	stw	r17,4(sp)
2000b4d0:	dfc00415 	stw	ra,16(sp)
2000b4d4:	dcc00315 	stw	r19,12(sp)
2000b4d8:	dc800215 	stw	r18,8(sp)
2000b4dc:	dc000015 	stw	r16,0(sp)
2000b4e0:	3023883a 	mov	r17,r6
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
2000b4e4:	30002a26 	beq	r6,zero,2000b590 <OSQPendAbort+0xc8>
2000b4e8:	2025883a 	mov	r18,r4
        return (0);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
2000b4ec:	2000021e 	bne	r4,zero,2000b4f8 <OSQPendAbort+0x30>
        *perr = OS_ERR_PEVENT_NULL;
2000b4f0:	00800104 	movi	r2,4
2000b4f4:	00000406 	br	2000b508 <OSQPendAbort+0x40>
        return (0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
2000b4f8:	21c00003 	ldbu	r7,0(r4)
2000b4fc:	00800084 	movi	r2,2
2000b500:	38800326 	beq	r7,r2,2000b510 <OSQPendAbort+0x48>
        *perr = OS_ERR_EVENT_TYPE;
2000b504:	00800044 	movi	r2,1
2000b508:	88800005 	stb	r2,0(r17)
2000b50c:	00002006 	br	2000b590 <OSQPendAbort+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b510:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b514:	00bfff84 	movi	r2,-2
2000b518:	9884703a 	and	r2,r19,r2
2000b51c:	1001703a 	wrctl	status,r2
        return (0);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
2000b520:	20800283 	ldbu	r2,10(r4)
2000b524:	10c03fcc 	andi	r3,r2,255
2000b528:	18001626 	beq	r3,zero,2000b584 <OSQPendAbort+0xbc>
        nbr_tasks = 0;
        switch (opt) {
2000b52c:	29403fcc 	andi	r5,r5,255
2000b530:	04000044 	movi	r16,1
2000b534:	2c000a1e 	bne	r5,r16,2000b560 <OSQPendAbort+0x98>
2000b538:	0021883a 	mov	r16,zero
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
2000b53c:	90800283 	ldbu	r2,10(r18)
2000b540:	10000a26 	beq	r2,zero,2000b56c <OSQPendAbort+0xa4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
2000b544:	9009883a 	mov	r4,r18
2000b548:	000b883a 	mov	r5,zero
2000b54c:	01800104 	movi	r6,4
2000b550:	01c00084 	movi	r7,2
2000b554:	00094f00 	call	200094f0 <OS_EventTaskRdy>
                     nbr_tasks++;
2000b558:	84000044 	addi	r16,r16,1
2000b55c:	003ff706 	br	2000b53c <OSQPendAbort+0x74>
                 }
                 break;
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
2000b560:	000b883a 	mov	r5,zero
2000b564:	01800104 	movi	r6,4
2000b568:	00094f00 	call	200094f0 <OS_EventTaskRdy>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b56c:	9801703a 	wrctl	status,r19
                 nbr_tasks++;
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
2000b570:	00098400 	call	20009840 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
2000b574:	00800384 	movi	r2,14
2000b578:	88800005 	stb	r2,0(r17)
        return (nbr_tasks);
2000b57c:	8005883a 	mov	r2,r16
2000b580:	00000406 	br	2000b594 <OSQPendAbort+0xcc>
2000b584:	9801703a 	wrctl	status,r19
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2000b588:	30000005 	stb	zero,0(r6)
    return (0);                                            /* No tasks waiting on queue                */
2000b58c:	00000106 	br	2000b594 <OSQPendAbort+0xcc>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return (0);
2000b590:	0005883a 	mov	r2,zero
        return (nbr_tasks);
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (0);                                            /* No tasks waiting on queue                */
}
2000b594:	dfc00417 	ldw	ra,16(sp)
2000b598:	dcc00317 	ldw	r19,12(sp)
2000b59c:	dc800217 	ldw	r18,8(sp)
2000b5a0:	dc400117 	ldw	r17,4(sp)
2000b5a4:	dc000017 	ldw	r16,0(sp)
2000b5a8:	dec00504 	addi	sp,sp,20
2000b5ac:	f800283a 	ret

2000b5b0 <OSQPost>:
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
2000b5b0:	20002a26 	beq	r4,zero,2000b65c <OSQPost+0xac>
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
2000b5b4:	21800003 	ldbu	r6,0(r4)
2000b5b8:	00800084 	movi	r2,2
2000b5bc:	3080291e 	bne	r6,r2,2000b664 <OSQPost+0xb4>
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
2000b5c0:	defffe04 	addi	sp,sp,-8
2000b5c4:	dfc00115 	stw	ra,4(sp)
2000b5c8:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b5cc:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b5d0:	00bfff84 	movi	r2,-2
2000b5d4:	8084703a 	and	r2,r16,r2
2000b5d8:	1001703a 	wrctl	status,r2
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
2000b5dc:	20800283 	ldbu	r2,10(r4)
2000b5e0:	11803fcc 	andi	r6,r2,255
2000b5e4:	30000726 	beq	r6,zero,2000b604 <OSQPost+0x54>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
2000b5e8:	01800104 	movi	r6,4
2000b5ec:	000f883a 	mov	r7,zero
2000b5f0:	00094f00 	call	200094f0 <OS_EventTaskRdy>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b5f4:	8001703a 	wrctl	status,r16
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
2000b5f8:	00098400 	call	20009840 <OS_Sched>
        return (OS_ERR_NONE);
2000b5fc:	0005883a 	mov	r2,zero
2000b600:	00001a06 	br	2000b66c <OSQPost+0xbc>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
2000b604:	20c00117 	ldw	r3,4(r4)
2000b608:	280f883a 	mov	r7,r5
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
2000b60c:	1900058b 	ldhu	r4,22(r3)
2000b610:	1940050b 	ldhu	r5,20(r3)
2000b614:	21bfffcc 	andi	r6,r4,65535
2000b618:	31400336 	bltu	r6,r5,2000b628 <OSQPost+0x78>
2000b61c:	8001703a 	wrctl	status,r16
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
2000b620:	00800784 	movi	r2,30
2000b624:	00001106 	br	2000b66c <OSQPost+0xbc>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
2000b628:	19800317 	ldw	r6,12(r3)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
2000b62c:	21000044 	addi	r4,r4,1
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
2000b630:	31400104 	addi	r5,r6,4
2000b634:	19400315 	stw	r5,12(r3)
2000b638:	31c00015 	stw	r7,0(r6)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
2000b63c:	1900058d 	sth	r4,22(r3)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
2000b640:	19400317 	ldw	r5,12(r3)
2000b644:	19000217 	ldw	r4,8(r3)
2000b648:	2900021e 	bne	r5,r4,2000b654 <OSQPost+0xa4>
        pq->OSQIn = pq->OSQStart;
2000b64c:	19000117 	ldw	r4,4(r3)
2000b650:	19000315 	stw	r4,12(r3)
2000b654:	8001703a 	wrctl	status,r16
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
2000b658:	00000406 	br	2000b66c <OSQPost+0xbc>



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
        return (OS_ERR_PEVENT_NULL);
2000b65c:	00800104 	movi	r2,4
2000b660:	f800283a 	ret
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
2000b664:	00800044 	movi	r2,1
2000b668:	f800283a 	ret
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
        pq->OSQIn = pq->OSQStart;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
}
2000b66c:	dfc00117 	ldw	ra,4(sp)
2000b670:	dc000017 	ldw	r16,0(sp)
2000b674:	dec00204 	addi	sp,sp,8
2000b678:	f800283a 	ret

2000b67c <OSQPostFront>:
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
2000b67c:	20002a26 	beq	r4,zero,2000b728 <OSQPostFront+0xac>
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
2000b680:	21800003 	ldbu	r6,0(r4)
2000b684:	00800084 	movi	r2,2
2000b688:	3080291e 	bne	r6,r2,2000b730 <OSQPostFront+0xb4>
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
2000b68c:	defffe04 	addi	sp,sp,-8
2000b690:	dfc00115 	stw	ra,4(sp)
2000b694:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b698:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b69c:	00bfff84 	movi	r2,-2
2000b6a0:	8084703a 	and	r2,r16,r2
2000b6a4:	1001703a 	wrctl	status,r2
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
2000b6a8:	20800283 	ldbu	r2,10(r4)
2000b6ac:	11803fcc 	andi	r6,r2,255
2000b6b0:	30000726 	beq	r6,zero,2000b6d0 <OSQPostFront+0x54>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
2000b6b4:	01800104 	movi	r6,4
2000b6b8:	000f883a 	mov	r7,zero
2000b6bc:	00094f00 	call	200094f0 <OS_EventTaskRdy>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b6c0:	8001703a 	wrctl	status,r16
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
2000b6c4:	00098400 	call	20009840 <OS_Sched>
        return (OS_ERR_NONE);
2000b6c8:	0005883a 	mov	r2,zero
2000b6cc:	00001a06 	br	2000b738 <OSQPostFront+0xbc>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
2000b6d0:	20c00117 	ldw	r3,4(r4)
2000b6d4:	280f883a 	mov	r7,r5
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
2000b6d8:	1900058b 	ldhu	r4,22(r3)
2000b6dc:	1940050b 	ldhu	r5,20(r3)
2000b6e0:	21bfffcc 	andi	r6,r4,65535
2000b6e4:	31400336 	bltu	r6,r5,2000b6f4 <OSQPostFront+0x78>
2000b6e8:	8001703a 	wrctl	status,r16
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
2000b6ec:	00800784 	movi	r2,30
2000b6f0:	00001106 	br	2000b738 <OSQPostFront+0xbc>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
2000b6f4:	19800417 	ldw	r6,16(r3)
2000b6f8:	19400117 	ldw	r5,4(r3)
2000b6fc:	3140021e 	bne	r6,r5,2000b708 <OSQPostFront+0x8c>
        pq->OSQOut = pq->OSQEnd;
2000b700:	19400217 	ldw	r5,8(r3)
2000b704:	19400415 	stw	r5,16(r3)
    }
    pq->OSQOut--;
2000b708:	19800417 	ldw	r6,16(r3)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
2000b70c:	21000044 	addi	r4,r4,1
        return (OS_ERR_Q_FULL);
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
        pq->OSQOut = pq->OSQEnd;
    }
    pq->OSQOut--;
2000b710:	317fff04 	addi	r5,r6,-4
2000b714:	19400415 	stw	r5,16(r3)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
2000b718:	31ffff15 	stw	r7,-4(r6)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
2000b71c:	1900058d 	sth	r4,22(r3)
2000b720:	8001703a 	wrctl	status,r16
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
2000b724:	00000406 	br	2000b738 <OSQPostFront+0xbc>



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
2000b728:	00800104 	movi	r2,4
2000b72c:	f800283a 	ret
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
2000b730:	00800044 	movi	r2,1
2000b734:	f800283a 	ret
    pq->OSQOut--;
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
}
2000b738:	dfc00117 	ldw	ra,4(sp)
2000b73c:	dc000017 	ldw	r16,0(sp)
2000b740:	dec00204 	addi	sp,sp,8
2000b744:	f800283a 	ret

2000b748 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
2000b748:	defffb04 	addi	sp,sp,-20
2000b74c:	dfc00415 	stw	ra,16(sp)
2000b750:	dcc00315 	stw	r19,12(sp)
2000b754:	dc800215 	stw	r18,8(sp)
2000b758:	dc400115 	stw	r17,4(sp)
2000b75c:	dc000015 	stw	r16,0(sp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
2000b760:	20004226 	beq	r4,zero,2000b86c <OSQPostOpt+0x124>
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
2000b764:	22000003 	ldbu	r8,0(r4)
2000b768:	01c00084 	movi	r7,2
2000b76c:	41c0411e 	bne	r8,r7,2000b874 <OSQPostOpt+0x12c>
2000b770:	2805883a 	mov	r2,r5
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b774:	0025303a 	rdctl	r18,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b778:	01ffff84 	movi	r7,-2
2000b77c:	91ce703a 	and	r7,r18,r7
2000b780:	3801703a 	wrctl	status,r7
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
2000b784:	24400283 	ldbu	r17,10(r4)
2000b788:	89c03fcc 	andi	r7,r17,255
2000b78c:	38001626 	beq	r7,zero,2000b7e8 <OSQPostOpt+0xa0>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
2000b790:	3080004c 	andi	r2,r6,1
2000b794:	3021883a 	mov	r16,r6
2000b798:	2827883a 	mov	r19,r5
2000b79c:	2023883a 	mov	r17,r4
2000b7a0:	10000826 	beq	r2,zero,2000b7c4 <OSQPostOpt+0x7c>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
2000b7a4:	88c00283 	ldbu	r3,10(r17)
2000b7a8:	18000926 	beq	r3,zero,2000b7d0 <OSQPostOpt+0x88>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
2000b7ac:	8809883a 	mov	r4,r17
2000b7b0:	980b883a 	mov	r5,r19
2000b7b4:	01800104 	movi	r6,4
2000b7b8:	000f883a 	mov	r7,zero
2000b7bc:	00094f00 	call	200094f0 <OS_EventTaskRdy>
2000b7c0:	003ff806 	br	2000b7a4 <OSQPostOpt+0x5c>
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
2000b7c4:	01800104 	movi	r6,4
2000b7c8:	000f883a 	mov	r7,zero
2000b7cc:	00094f00 	call	200094f0 <OS_EventTaskRdy>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b7d0:	9001703a 	wrctl	status,r18
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
2000b7d4:	8400010c 	andi	r16,r16,4
2000b7d8:	8023883a 	mov	r17,r16
2000b7dc:	8000271e 	bne	r16,zero,2000b87c <OSQPostOpt+0x134>
            OS_Sched();                               /* Find highest priority task ready to run       */
2000b7e0:	00098400 	call	20009840 <OS_Sched>
2000b7e4:	00002606 	br	2000b880 <OSQPostOpt+0x138>
        }
        return (OS_ERR_NONE);
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
2000b7e8:	20c00117 	ldw	r3,4(r4)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
2000b7ec:	1900058b 	ldhu	r4,22(r3)
2000b7f0:	1940050b 	ldhu	r5,20(r3)
2000b7f4:	21ffffcc 	andi	r7,r4,65535
2000b7f8:	39400336 	bltu	r7,r5,2000b808 <OSQPostOpt+0xc0>
2000b7fc:	9001703a 	wrctl	status,r18
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
2000b800:	04400784 	movi	r17,30
2000b804:	00001e06 	br	2000b880 <OSQPostOpt+0x138>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
2000b808:	3180008c 	andi	r6,r6,2
2000b80c:	30000a26 	beq	r6,zero,2000b838 <OSQPostOpt+0xf0>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
2000b810:	19800417 	ldw	r6,16(r3)
2000b814:	19400117 	ldw	r5,4(r3)
2000b818:	3140021e 	bne	r6,r5,2000b824 <OSQPostOpt+0xdc>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
2000b81c:	19400217 	ldw	r5,8(r3)
2000b820:	19400415 	stw	r5,16(r3)
        }
        pq->OSQOut--;
2000b824:	19400417 	ldw	r5,16(r3)
2000b828:	29bfff04 	addi	r6,r5,-4
2000b82c:	19800415 	stw	r6,16(r3)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
2000b830:	28bfff15 	stw	r2,-4(r5)
2000b834:	00000906 	br	2000b85c <OSQPostOpt+0x114>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
2000b838:	19400317 	ldw	r5,12(r3)
2000b83c:	29800104 	addi	r6,r5,4
2000b840:	19800315 	stw	r6,12(r3)
2000b844:	28800015 	stw	r2,0(r5)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
2000b848:	19400317 	ldw	r5,12(r3)
2000b84c:	18800217 	ldw	r2,8(r3)
2000b850:	2880021e 	bne	r5,r2,2000b85c <OSQPostOpt+0x114>
            pq->OSQIn = pq->OSQStart;
2000b854:	18800117 	ldw	r2,4(r3)
2000b858:	18800315 	stw	r2,12(r3)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
2000b85c:	21000044 	addi	r4,r4,1
2000b860:	1900058d 	sth	r4,22(r3)
2000b864:	9001703a 	wrctl	status,r18
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
2000b868:	00000506 	br	2000b880 <OSQPostOpt+0x138>



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
2000b86c:	04400104 	movi	r17,4
2000b870:	00000306 	br	2000b880 <OSQPostOpt+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
2000b874:	04400044 	movi	r17,1
2000b878:	00000106 	br	2000b880 <OSQPostOpt+0x138>
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
            OS_Sched();                               /* Find highest priority task ready to run       */
        }
        return (OS_ERR_NONE);
2000b87c:	0023883a 	mov	r17,zero
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
}
2000b880:	8805883a 	mov	r2,r17
2000b884:	dfc00417 	ldw	ra,16(sp)
2000b888:	dcc00317 	ldw	r19,12(sp)
2000b88c:	dc800217 	ldw	r18,8(sp)
2000b890:	dc400117 	ldw	r17,4(sp)
2000b894:	dc000017 	ldw	r16,0(sp)
2000b898:	dec00504 	addi	sp,sp,20
2000b89c:	f800283a 	ret

2000b8a0 <OSQQuery>:
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
2000b8a0:	20002326 	beq	r4,zero,2000b930 <OSQQuery+0x90>
        return (OS_ERR_PEVENT_NULL);
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
2000b8a4:	28002426 	beq	r5,zero,2000b938 <OSQQuery+0x98>
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
2000b8a8:	20c00003 	ldbu	r3,0(r4)
2000b8ac:	00800084 	movi	r2,2
2000b8b0:	1880231e 	bne	r3,r2,2000b940 <OSQQuery+0xa0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b8b4:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b8b8:	00bfff84 	movi	r2,-2
2000b8bc:	1884703a 	and	r2,r3,r2
2000b8c0:	1001703a 	wrctl	status,r2
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
2000b8c4:	20800283 	ldbu	r2,10(r4)
    psrc                 = &pevent->OSEventTbl[0];
2000b8c8:	228002c4 	addi	r10,r4,11
    pdest                = &p_q_data->OSEventTbl[0];
2000b8cc:	2a400204 	addi	r9,r5,8
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
2000b8d0:	288002c5 	stb	r2,11(r5)
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
2000b8d4:	018000c4 	movi	r6,3
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
2000b8d8:	0005883a 	mov	r2,zero
2000b8dc:	508f883a 	add	r7,r10,r2
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
2000b8e0:	3a000003 	ldbu	r8,0(r7)
2000b8e4:	488f883a 	add	r7,r9,r2
2000b8e8:	10800044 	addi	r2,r2,1
2000b8ec:	3a000005 	stb	r8,0(r7)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
2000b8f0:	11bffa1e 	bne	r2,r6,2000b8dc <OSQQuery+0x3c>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
2000b8f4:	20800117 	ldw	r2,4(r4)
    if (pq->OSQEntries > 0) {
2000b8f8:	1100058b 	ldhu	r4,22(r2)
2000b8fc:	21bfffcc 	andi	r6,r4,65535
2000b900:	30000426 	beq	r6,zero,2000b914 <OSQQuery+0x74>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
2000b904:	11800417 	ldw	r6,16(r2)
2000b908:	31800017 	ldw	r6,0(r6)
2000b90c:	29800015 	stw	r6,0(r5)
2000b910:	00000106 	br	2000b918 <OSQQuery+0x78>
    } else {
        p_q_data->OSMsg = (void *)0;
2000b914:	28000015 	stw	zero,0(r5)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
    p_q_data->OSQSize = pq->OSQSize;
2000b918:	1080050b 	ldhu	r2,20(r2)
    if (pq->OSQEntries > 0) {
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
    } else {
        p_q_data->OSMsg = (void *)0;
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
2000b91c:	2900010d 	sth	r4,4(r5)
    p_q_data->OSQSize = pq->OSQSize;
2000b920:	2880018d 	sth	r2,6(r5)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b924:	1801703a 	wrctl	status,r3
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
2000b928:	0005883a 	mov	r2,zero
2000b92c:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
        return (OS_ERR_PEVENT_NULL);
2000b930:	00800104 	movi	r2,4
2000b934:	f800283a 	ret
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
        return (OS_ERR_PDATA_NULL);
2000b938:	00800244 	movi	r2,9
2000b93c:	f800283a 	ret
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
        return (OS_ERR_EVENT_TYPE);
2000b940:	00800044 	movi	r2,1
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
    p_q_data->OSQSize = pq->OSQSize;
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
}
2000b944:	f800283a 	ret

2000b948 <OS_QInit>:
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
2000b948:	01000034 	movhi	r4,0
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
2000b94c:	deffff04 	addi	sp,sp,-4
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
2000b950:	01407804 	movi	r5,480
2000b954:	21177404 	addi	r4,r4,24016
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
2000b958:	dfc00015 	stw	ra,0(sp)
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
2000b95c:	00095f00 	call	200095f0 <OS_MemClr>
2000b960:	01400034 	movhi	r5,0
2000b964:	0005883a 	mov	r2,zero
2000b968:	29577404 	addi	r5,r5,24016
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
2000b96c:	01807204 	movi	r6,456
2000b970:	11000604 	addi	r4,r2,24
2000b974:	214f883a 	add	r7,r4,r5
2000b978:	1145883a 	add	r2,r2,r5
2000b97c:	00c00034 	movhi	r3,0
        pq1->OSQPtr = pq2;
2000b980:	11c00015 	stw	r7,0(r2)
2000b984:	18d77404 	addi	r3,r3,24016
2000b988:	2005883a 	mov	r2,r4


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
2000b98c:	21bff81e 	bne	r4,r6,2000b970 <OS_QInit+0x28>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
    OSQFreeList = &OSQTbl[0];
2000b990:	00800034 	movhi	r2,0
2000b994:	10817e04 	addi	r2,r2,1528
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
2000b998:	18007215 	stw	zero,456(r3)
    OSQFreeList = &OSQTbl[0];
2000b99c:	10c00015 	stw	r3,0(r2)
#endif
}
2000b9a0:	dfc00017 	ldw	ra,0(sp)
2000b9a4:	dec00104 	addi	sp,sp,4
2000b9a8:	f800283a 	ret

2000b9ac <OSSemAccept>:
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
2000b9ac:	20000e26 	beq	r4,zero,2000b9e8 <OSSemAccept+0x3c>
        return (0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
2000b9b0:	20c00003 	ldbu	r3,0(r4)
2000b9b4:	008000c4 	movi	r2,3
2000b9b8:	18800b1e 	bne	r3,r2,2000b9e8 <OSSemAccept+0x3c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000b9bc:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000b9c0:	00bfff84 	movi	r2,-2
2000b9c4:	1884703a 	and	r2,r3,r2
2000b9c8:	1001703a 	wrctl	status,r2
        return (0);
    }
    OS_ENTER_CRITICAL();
    cnt = pevent->OSEventCnt;
2000b9cc:	2080020b 	ldhu	r2,8(r4)
    if (cnt > 0) {                                    /* See if resource is available                  */
2000b9d0:	117fffcc 	andi	r5,r2,65535
2000b9d4:	28000226 	beq	r5,zero,2000b9e0 <OSSemAccept+0x34>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
2000b9d8:	117fffc4 	addi	r5,r2,-1
2000b9dc:	2140020d 	sth	r5,8(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000b9e0:	1801703a 	wrctl	status,r3
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
2000b9e4:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (0);
2000b9e8:	0005883a 	mov	r2,zero
    if (cnt > 0) {                                    /* See if resource is available                  */
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
}
2000b9ec:	f800283a 	ret

2000b9f0 <OSSemCreate>:
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
2000b9f0:	00800034 	movhi	r2,0
2000b9f4:	10818104 	addi	r2,r2,1540
2000b9f8:	10800003 	ldbu	r2,0(r2)
2000b9fc:	10001a1e 	bne	r2,zero,2000ba68 <OSSemCreate+0x78>
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
2000ba00:	defffe04 	addi	sp,sp,-8
2000ba04:	dfc00115 	stw	ra,4(sp)
2000ba08:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ba0c:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000ba10:	00bfff84 	movi	r2,-2
2000ba14:	1884703a 	and	r2,r3,r2
2000ba18:	1001703a 	wrctl	status,r2

    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
    }
    OS_ENTER_CRITICAL();
    pevent = OSEventFreeList;                              /* Get next free event control block        */
2000ba1c:	00800034 	movhi	r2,0
2000ba20:	10818004 	addi	r2,r2,1536
2000ba24:	14000017 	ldw	r16,0(r2)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
2000ba28:	80000226 	beq	r16,zero,2000ba34 <OSSemCreate+0x44>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
2000ba2c:	81400117 	ldw	r5,4(r16)
2000ba30:	11400015 	stw	r5,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000ba34:	1801703a 	wrctl	status,r3
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
2000ba38:	80000d26 	beq	r16,zero,2000ba70 <OSSemCreate+0x80>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
2000ba3c:	008000c4 	movi	r2,3
2000ba40:	80800005 	stb	r2,0(r16)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
2000ba44:	00800fc4 	movi	r2,63
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
2000ba48:	8100020d 	sth	r4,8(r16)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
2000ba4c:	80800385 	stb	r2,14(r16)
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
2000ba50:	80000115 	stw	zero,4(r16)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
        pevent->OSEventName[1] = OS_ASCII_NUL;
2000ba54:	800003c5 	stb	zero,15(r16)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
2000ba58:	8009883a 	mov	r4,r16
2000ba5c:	00095dc0 	call	200095dc <OS_EventWaitListInit>
2000ba60:	8005883a 	mov	r2,r16
2000ba64:	00000306 	br	2000ba74 <OSSemCreate+0x84>
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
2000ba68:	0005883a 	mov	r2,zero
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
    }
    return (pevent);
}
2000ba6c:	f800283a 	ret
2000ba70:	0005883a 	mov	r2,zero
2000ba74:	dfc00117 	ldw	ra,4(sp)
2000ba78:	dc000017 	ldw	r16,0(sp)
2000ba7c:	dec00204 	addi	sp,sp,8
2000ba80:	f800283a 	ret

2000ba84 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
2000ba84:	defffb04 	addi	sp,sp,-20
2000ba88:	dc400115 	stw	r17,4(sp)
2000ba8c:	dc000015 	stw	r16,0(sp)
2000ba90:	dfc00415 	stw	ra,16(sp)
2000ba94:	dcc00315 	stw	r19,12(sp)
2000ba98:	dc800215 	stw	r18,8(sp)
2000ba9c:	2021883a 	mov	r16,r4
2000baa0:	3023883a 	mov	r17,r6
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
2000baa4:	30004b26 	beq	r6,zero,2000bbd4 <OSSemDel+0x150>
        return (pevent);
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
2000baa8:	2000021e 	bne	r4,zero,2000bab4 <OSSemDel+0x30>
        *perr = OS_ERR_PEVENT_NULL;
2000baac:	00800104 	movi	r2,4
2000bab0:	00001506 	br	2000bb08 <OSSemDel+0x84>
        return (pevent);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
2000bab4:	20c00003 	ldbu	r3,0(r4)
2000bab8:	008000c4 	movi	r2,3
2000babc:	18800226 	beq	r3,r2,2000bac8 <OSSemDel+0x44>
        *perr = OS_ERR_EVENT_TYPE;
2000bac0:	00800044 	movi	r2,1
2000bac4:	00001006 	br	2000bb08 <OSSemDel+0x84>
        return (pevent);
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
2000bac8:	00800034 	movhi	r2,0
2000bacc:	10818104 	addi	r2,r2,1540
2000bad0:	10800003 	ldbu	r2,0(r2)
2000bad4:	10000226 	beq	r2,zero,2000bae0 <OSSemDel+0x5c>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
2000bad8:	008003c4 	movi	r2,15
2000badc:	00000a06 	br	2000bb08 <OSSemDel+0x84>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000bae0:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000bae4:	00bfff84 	movi	r2,-2
2000bae8:	9884703a 	and	r2,r19,r2
2000baec:	1001703a 	wrctl	status,r2
        return (pevent);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
2000baf0:	20c00283 	ldbu	r3,10(r4)
2000baf4:	28803fcc 	andi	r2,r5,255
2000baf8:	18000526 	beq	r3,zero,2000bb10 <OSSemDel+0x8c>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
2000bafc:	1000271e 	bne	r2,zero,2000bb9c <OSSemDel+0x118>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000bb00:	9801703a 	wrctl	status,r19
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
2000bb04:	00801244 	movi	r2,73
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
             break;

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
2000bb08:	88800005 	stb	r2,0(r17)
             pevent_return          = pevent;
             break;
2000bb0c:	00003106 	br	2000bbd4 <OSSemDel+0x150>
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
2000bb10:	10001e1e 	bne	r2,zero,2000bb8c <OSSemDel+0x108>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
2000bb14:	00800fc4 	movi	r2,63
2000bb18:	80800385 	stb	r2,14(r16)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
2000bb1c:	00800034 	movhi	r2,0
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
2000bb20:	80000005 	stb	zero,0(r16)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
2000bb24:	10818004 	addi	r2,r2,1536
2000bb28:	10c00017 	ldw	r3,0(r2)
    switch (opt) {
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
2000bb2c:	800003c5 	stb	zero,15(r16)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
                 pevent->OSEventCnt     = 0;
2000bb30:	8000020d 	sth	zero,8(r16)
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
                 pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
2000bb34:	80c00115 	stw	r3,4(r16)
                 pevent->OSEventCnt     = 0;
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
2000bb38:	14000015 	stw	r16,0(r2)
2000bb3c:	9801703a 	wrctl	status,r19
2000bb40:	00000f06 	br	2000bb80 <OSSemDel+0xfc>
        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
2000bb44:	00800fc4 	movi	r2,63
2000bb48:	80800385 	stb	r2,14(r16)
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
2000bb4c:	00800034 	movhi	r2,0
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
2000bb50:	80000005 	stb	zero,0(r16)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
2000bb54:	10818004 	addi	r2,r2,1536
2000bb58:	10c00017 	ldw	r3,0(r2)
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
2000bb5c:	800003c5 	stb	zero,15(r16)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
             pevent->OSEventCnt     = 0;
2000bb60:	8000020d 	sth	zero,8(r16)
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
             pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
2000bb64:	80c00115 	stw	r3,4(r16)
             pevent->OSEventCnt     = 0;
             OSEventFreeList        = pevent;              /* Get next free event control block        */
2000bb68:	14000015 	stw	r16,0(r2)
2000bb6c:	9801703a 	wrctl	status,r19
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
2000bb70:	94803fcc 	andi	r18,r18,255
2000bb74:	00800044 	movi	r2,1
2000bb78:	9080011e 	bne	r18,r2,2000bb80 <OSSemDel+0xfc>
                 OS_Sched();                               /* Find highest priority task ready to run  */
2000bb7c:	00098400 	call	20009840 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
2000bb80:	88000005 	stb	zero,0(r17)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
2000bb84:	0021883a 	mov	r16,zero
             break;
2000bb88:	00001206 	br	2000bbd4 <OSSemDel+0x150>
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
    }
    switch (opt) {
2000bb8c:	00c00044 	movi	r3,1
2000bb90:	10c00d1e 	bne	r2,r3,2000bbc8 <OSSemDel+0x144>
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
2000bb94:	0025883a 	mov	r18,zero
2000bb98:	00000306 	br	2000bba8 <OSSemDel+0x124>
    }
    switch (opt) {
2000bb9c:	00c00044 	movi	r3,1
2000bba0:	10c0091e 	bne	r2,r3,2000bbc8 <OSSemDel+0x144>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
        return (pevent);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
2000bba4:	2825883a 	mov	r18,r5
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
2000bba8:	80800283 	ldbu	r2,10(r16)
2000bbac:	103fe526 	beq	r2,zero,2000bb44 <OSSemDel+0xc0>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
2000bbb0:	8009883a 	mov	r4,r16
2000bbb4:	000b883a 	mov	r5,zero
2000bbb8:	01800044 	movi	r6,1
2000bbbc:	000f883a 	mov	r7,zero
2000bbc0:	00094f00 	call	200094f0 <OS_EventTaskRdy>
2000bbc4:	003ff806 	br	2000bba8 <OSSemDel+0x124>
2000bbc8:	9801703a 	wrctl	status,r19
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
             break;

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
2000bbcc:	008001c4 	movi	r2,7
2000bbd0:	003fcd06 	br	2000bb08 <OSSemDel+0x84>
             pevent_return          = pevent;
             break;
    }
    return (pevent_return);
}
2000bbd4:	8005883a 	mov	r2,r16
2000bbd8:	dfc00417 	ldw	ra,16(sp)
2000bbdc:	dcc00317 	ldw	r19,12(sp)
2000bbe0:	dc800217 	ldw	r18,8(sp)
2000bbe4:	dc400117 	ldw	r17,4(sp)
2000bbe8:	dc000017 	ldw	r16,0(sp)
2000bbec:	dec00504 	addi	sp,sp,20
2000bbf0:	f800283a 	ret

2000bbf4 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
2000bbf4:	defffa04 	addi	sp,sp,-24
2000bbf8:	dc000015 	stw	r16,0(sp)
2000bbfc:	dfc00515 	stw	ra,20(sp)
2000bc00:	dd000415 	stw	r20,16(sp)
2000bc04:	dcc00315 	stw	r19,12(sp)
2000bc08:	dc800215 	stw	r18,8(sp)
2000bc0c:	dc400115 	stw	r17,4(sp)
2000bc10:	3021883a 	mov	r16,r6
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
2000bc14:	30004326 	beq	r6,zero,2000bd24 <OSSemPend+0x130>
2000bc18:	2025883a 	mov	r18,r4
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
2000bc1c:	2000021e 	bne	r4,zero,2000bc28 <OSSemPend+0x34>
        *perr = OS_ERR_PEVENT_NULL;
2000bc20:	00800104 	movi	r2,4
2000bc24:	00001006 	br	2000bc68 <OSSemPend+0x74>
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
2000bc28:	20c00003 	ldbu	r3,0(r4)
2000bc2c:	008000c4 	movi	r2,3
2000bc30:	18800226 	beq	r3,r2,2000bc3c <OSSemPend+0x48>
        *perr = OS_ERR_EVENT_TYPE;
2000bc34:	00800044 	movi	r2,1
2000bc38:	00000b06 	br	2000bc68 <OSSemPend+0x74>
        return;
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
2000bc3c:	00800034 	movhi	r2,0
2000bc40:	10818104 	addi	r2,r2,1540
2000bc44:	10800003 	ldbu	r2,0(r2)
2000bc48:	10000226 	beq	r2,zero,2000bc54 <OSSemPend+0x60>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
2000bc4c:	00800084 	movi	r2,2
2000bc50:	00000506 	br	2000bc68 <OSSemPend+0x74>
        return;
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
2000bc54:	00800034 	movhi	r2,0
2000bc58:	10817304 	addi	r2,r2,1484
2000bc5c:	10800003 	ldbu	r2,0(r2)
2000bc60:	10000326 	beq	r2,zero,2000bc70 <OSSemPend+0x7c>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
2000bc64:	00800344 	movi	r2,13
2000bc68:	80800005 	stb	r2,0(r16)
        return;
2000bc6c:	00002d06 	br	2000bd24 <OSSemPend+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000bc70:	0029303a 	rdctl	r20,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000bc74:	04ffff84 	movi	r19,-2
2000bc78:	a4c4703a 	and	r2,r20,r19
2000bc7c:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
2000bc80:	2080020b 	ldhu	r2,8(r4)
2000bc84:	10ffffcc 	andi	r3,r2,65535
2000bc88:	18000526 	beq	r3,zero,2000bca0 <OSSemPend+0xac>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
2000bc8c:	10bfffc4 	addi	r2,r2,-1
2000bc90:	2080020d 	sth	r2,8(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000bc94:	a001703a 	wrctl	status,r20
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
2000bc98:	30000005 	stb	zero,0(r6)
        return;
2000bc9c:	00002106 	br	2000bd24 <OSSemPend+0x130>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
2000bca0:	04400034 	movhi	r17,0
2000bca4:	8c418204 	addi	r17,r17,1544
2000bca8:	88800017 	ldw	r2,0(r17)
2000bcac:	10c00c03 	ldbu	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
2000bcb0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
2000bcb4:	11400b8d 	sth	r5,46(r2)
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
        return;
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
2000bcb8:	18c00054 	ori	r3,r3,1
2000bcbc:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
2000bcc0:	00093780 	call	20009378 <OS_EventTaskWait>
2000bcc4:	a001703a 	wrctl	status,r20
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
2000bcc8:	00098400 	call	20009840 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000bccc:	0029303a 	rdctl	r20,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000bcd0:	a4e6703a 	and	r19,r20,r19
2000bcd4:	9801703a 	wrctl	status,r19
    OS_ENTER_CRITICAL();
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
2000bcd8:	89000017 	ldw	r4,0(r17)
2000bcdc:	20800c43 	ldbu	r2,49(r4)
2000bce0:	10000426 	beq	r2,zero,2000bcf4 <OSSemPend+0x100>
2000bce4:	00c00084 	movi	r3,2
2000bce8:	10c0041e 	bne	r2,r3,2000bcfc <OSSemPend+0x108>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
             break;

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
2000bcec:	00800384 	movi	r2,14
2000bcf0:	00000506 	br	2000bd08 <OSSemPend+0x114>
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
    OS_ENTER_CRITICAL();
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
2000bcf4:	80000005 	stb	zero,0(r16)
             break;
2000bcf8:	00000406 	br	2000bd0c <OSSemPend+0x118>
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
             break;

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
2000bcfc:	900b883a 	mov	r5,r18
2000bd00:	00094640 	call	20009464 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
2000bd04:	00800284 	movi	r2,10
2000bd08:	80800005 	stb	r2,0(r16)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
2000bd0c:	88800017 	ldw	r2,0(r17)
2000bd10:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
2000bd14:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
2000bd18:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
2000bd1c:	10000815 	stw	zero,32(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000bd20:	a001703a 	wrctl	status,r20
#endif
    OS_EXIT_CRITICAL();
}
2000bd24:	dfc00517 	ldw	ra,20(sp)
2000bd28:	dd000417 	ldw	r20,16(sp)
2000bd2c:	dcc00317 	ldw	r19,12(sp)
2000bd30:	dc800217 	ldw	r18,8(sp)
2000bd34:	dc400117 	ldw	r17,4(sp)
2000bd38:	dc000017 	ldw	r16,0(sp)
2000bd3c:	dec00604 	addi	sp,sp,24
2000bd40:	f800283a 	ret

2000bd44 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
2000bd44:	defffb04 	addi	sp,sp,-20
2000bd48:	dc400115 	stw	r17,4(sp)
2000bd4c:	dfc00415 	stw	ra,16(sp)
2000bd50:	dcc00315 	stw	r19,12(sp)
2000bd54:	dc800215 	stw	r18,8(sp)
2000bd58:	dc000015 	stw	r16,0(sp)
2000bd5c:	3023883a 	mov	r17,r6
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
2000bd60:	30002b26 	beq	r6,zero,2000be10 <OSSemPendAbort+0xcc>
2000bd64:	2025883a 	mov	r18,r4
        return (0);
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
2000bd68:	2000021e 	bne	r4,zero,2000bd74 <OSSemPendAbort+0x30>
        *perr = OS_ERR_PEVENT_NULL;
2000bd6c:	00800104 	movi	r2,4
2000bd70:	00000406 	br	2000bd84 <OSSemPendAbort+0x40>
        return (0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
2000bd74:	20c00003 	ldbu	r3,0(r4)
2000bd78:	008000c4 	movi	r2,3
2000bd7c:	18800326 	beq	r3,r2,2000bd8c <OSSemPendAbort+0x48>
        *perr = OS_ERR_EVENT_TYPE;
2000bd80:	00800044 	movi	r2,1
2000bd84:	88800005 	stb	r2,0(r17)
2000bd88:	00002106 	br	2000be10 <OSSemPendAbort+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000bd8c:	0027303a 	rdctl	r19,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000bd90:	00bfff84 	movi	r2,-2
2000bd94:	9884703a 	and	r2,r19,r2
2000bd98:	1001703a 	wrctl	status,r2
        return (0);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
2000bd9c:	20800283 	ldbu	r2,10(r4)
2000bda0:	10c03fcc 	andi	r3,r2,255
2000bda4:	18001726 	beq	r3,zero,2000be04 <OSSemPendAbort+0xc0>
        nbr_tasks = 0;
        switch (opt) {
2000bda8:	29403fcc 	andi	r5,r5,255
2000bdac:	04000044 	movi	r16,1
2000bdb0:	2c000a1e 	bne	r5,r16,2000bddc <OSSemPendAbort+0x98>
2000bdb4:	0021883a 	mov	r16,zero
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
2000bdb8:	90800283 	ldbu	r2,10(r18)
2000bdbc:	10000b26 	beq	r2,zero,2000bdec <OSSemPendAbort+0xa8>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
2000bdc0:	9009883a 	mov	r4,r18
2000bdc4:	000b883a 	mov	r5,zero
2000bdc8:	01800044 	movi	r6,1
2000bdcc:	01c00084 	movi	r7,2
2000bdd0:	00094f00 	call	200094f0 <OS_EventTaskRdy>
                     nbr_tasks++;
2000bdd4:	84000044 	addi	r16,r16,1
2000bdd8:	003ff706 	br	2000bdb8 <OSSemPendAbort+0x74>
                 }
                 break;
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
2000bddc:	000b883a 	mov	r5,zero
2000bde0:	800d883a 	mov	r6,r16
2000bde4:	01c00084 	movi	r7,2
2000bde8:	00094f00 	call	200094f0 <OS_EventTaskRdy>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000bdec:	9801703a 	wrctl	status,r19
                 nbr_tasks++;
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
2000bdf0:	00098400 	call	20009840 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
2000bdf4:	00800384 	movi	r2,14
2000bdf8:	88800005 	stb	r2,0(r17)
        return (nbr_tasks);
2000bdfc:	8005883a 	mov	r2,r16
2000be00:	00000406 	br	2000be14 <OSSemPendAbort+0xd0>
2000be04:	9801703a 	wrctl	status,r19
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2000be08:	30000005 	stb	zero,0(r6)
    return (0);                                       /* No tasks waiting on semaphore                 */
2000be0c:	00000106 	br	2000be14 <OSSemPendAbort+0xd0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return (0);
2000be10:	0005883a 	mov	r2,zero
        return (nbr_tasks);
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (0);                                       /* No tasks waiting on semaphore                 */
}
2000be14:	dfc00417 	ldw	ra,16(sp)
2000be18:	dcc00317 	ldw	r19,12(sp)
2000be1c:	dc800217 	ldw	r18,8(sp)
2000be20:	dc400117 	ldw	r17,4(sp)
2000be24:	dc000017 	ldw	r16,0(sp)
2000be28:	dec00504 	addi	sp,sp,20
2000be2c:	f800283a 	ret

2000be30 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
2000be30:	2007883a 	mov	r3,r4
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
2000be34:	20002026 	beq	r4,zero,2000beb8 <OSSemPost+0x88>
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
2000be38:	21400003 	ldbu	r5,0(r4)
2000be3c:	008000c4 	movi	r2,3
2000be40:	28801f1e 	bne	r5,r2,2000bec0 <OSSemPost+0x90>
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
2000be44:	defffe04 	addi	sp,sp,-8
2000be48:	dfc00115 	stw	ra,4(sp)
2000be4c:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000be50:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000be54:	00bfff84 	movi	r2,-2
2000be58:	8084703a 	and	r2,r16,r2
2000be5c:	1001703a 	wrctl	status,r2
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
2000be60:	20800283 	ldbu	r2,10(r4)
2000be64:	11403fcc 	andi	r5,r2,255
2000be68:	28000826 	beq	r5,zero,2000be8c <OSSemPost+0x5c>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
2000be6c:	000b883a 	mov	r5,zero
2000be70:	01800044 	movi	r6,1
2000be74:	000f883a 	mov	r7,zero
2000be78:	00094f00 	call	200094f0 <OS_EventTaskRdy>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000be7c:	8001703a 	wrctl	status,r16
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
2000be80:	00098400 	call	20009840 <OS_Sched>
        return (OS_ERR_NONE);
2000be84:	0005883a 	mov	r2,zero
2000be88:	00000f06 	br	2000bec8 <OSSemPost+0x98>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
2000be8c:	2100020b 	ldhu	r4,8(r4)
2000be90:	017fffd4 	movui	r5,65535
2000be94:	21bfffcc 	andi	r6,r4,65535
2000be98:	31400426 	beq	r6,r5,2000beac <OSSemPost+0x7c>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
2000be9c:	21000044 	addi	r4,r4,1
2000bea0:	1900020d 	sth	r4,8(r3)
2000bea4:	8001703a 	wrctl	status,r16
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
2000bea8:	00000706 	br	2000bec8 <OSSemPost+0x98>
2000beac:	8001703a 	wrctl	status,r16
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
2000beb0:	00800c84 	movi	r2,50
2000beb4:	00000406 	br	2000bec8 <OSSemPost+0x98>



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
2000beb8:	00800104 	movi	r2,4
2000bebc:	f800283a 	ret
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
2000bec0:	00800044 	movi	r2,1
2000bec4:	f800283a 	ret
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
}
2000bec8:	dfc00117 	ldw	ra,4(sp)
2000becc:	dc000017 	ldw	r16,0(sp)
2000bed0:	dec00204 	addi	sp,sp,8
2000bed4:	f800283a 	ret

2000bed8 <OSSemQuery>:
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
2000bed8:	20001826 	beq	r4,zero,2000bf3c <OSSemQuery+0x64>
        return (OS_ERR_PEVENT_NULL);
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
2000bedc:	28001926 	beq	r5,zero,2000bf44 <OSSemQuery+0x6c>
        return (OS_ERR_PDATA_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
2000bee0:	20c00003 	ldbu	r3,0(r4)
2000bee4:	008000c4 	movi	r2,3
2000bee8:	1880181e 	bne	r3,r2,2000bf4c <OSSemQuery+0x74>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000beec:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000bef0:	00bfff84 	movi	r2,-2
2000bef4:	3084703a 	and	r2,r6,r2
2000bef8:	1001703a 	wrctl	status,r2
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
2000befc:	20800283 	ldbu	r2,10(r4)
    psrc                   = &pevent->OSEventTbl[0];
2000bf00:	228002c4 	addi	r10,r4,11
    pdest                  = &p_sem_data->OSEventTbl[0];
2000bf04:	2a400084 	addi	r9,r5,2
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
2000bf08:	28800145 	stb	r2,5(r5)
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
2000bf0c:	0005883a 	mov	r2,zero
2000bf10:	508f883a 	add	r7,r10,r2
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
        *pdest++ = *psrc++;
2000bf14:	3a000003 	ldbu	r8,0(r7)
2000bf18:	488f883a 	add	r7,r9,r2
2000bf1c:	10800044 	addi	r2,r2,1
2000bf20:	3a000005 	stb	r8,0(r7)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
2000bf24:	10fffa1e 	bne	r2,r3,2000bf10 <OSSemQuery+0x38>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
2000bf28:	2080020b 	ldhu	r2,8(r4)
2000bf2c:	2880000d 	sth	r2,0(r5)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000bf30:	3001703a 	wrctl	status,r6
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
2000bf34:	0005883a 	mov	r2,zero
2000bf38:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        return (OS_ERR_PEVENT_NULL);
2000bf3c:	00800104 	movi	r2,4
2000bf40:	f800283a 	ret
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
        return (OS_ERR_PDATA_NULL);
2000bf44:	00800244 	movi	r2,9
2000bf48:	f800283a 	ret
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
        return (OS_ERR_EVENT_TYPE);
2000bf4c:	00800044 	movi	r2,1
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
}
2000bf50:	f800283a 	ret

2000bf54 <OSSemSet>:
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
2000bf54:	30001726 	beq	r6,zero,2000bfb4 <OSSemSet+0x60>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
2000bf58:	2000021e 	bne	r4,zero,2000bf64 <OSSemSet+0x10>
        *perr = OS_ERR_PEVENT_NULL;
2000bf5c:	00800104 	movi	r2,4
2000bf60:	00000406 	br	2000bf74 <OSSemSet+0x20>
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
2000bf64:	20c00003 	ldbu	r3,0(r4)
2000bf68:	008000c4 	movi	r2,3
2000bf6c:	18800326 	beq	r3,r2,2000bf7c <OSSemSet+0x28>
        *perr = OS_ERR_EVENT_TYPE;
2000bf70:	00800044 	movi	r2,1
2000bf74:	30800005 	stb	r2,0(r6)
        return;
2000bf78:	f800283a 	ret
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000bf7c:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000bf80:	00bfff84 	movi	r2,-2
2000bf84:	1884703a 	and	r2,r3,r2
2000bf88:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    *perr = OS_ERR_NONE;
2000bf8c:	30000005 	stb	zero,0(r6)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
2000bf90:	2080020b 	ldhu	r2,8(r4)
2000bf94:	10000226 	beq	r2,zero,2000bfa0 <OSSemSet+0x4c>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
2000bf98:	2140020d 	sth	r5,8(r4)
2000bf9c:	00000406 	br	2000bfb0 <OSSemSet+0x5c>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
2000bfa0:	20800283 	ldbu	r2,10(r4)
2000bfa4:	103ffc26 	beq	r2,zero,2000bf98 <OSSemSet+0x44>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
        } else {
            *perr              = OS_ERR_TASK_WAITING;
2000bfa8:	00801244 	movi	r2,73
2000bfac:	30800005 	stb	r2,0(r6)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000bfb0:	1801703a 	wrctl	status,r3
2000bfb4:	f800283a 	ret

2000bfb8 <OSTaskChangePrio>:
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
2000bfb8:	20fffb04 	addi	r3,r4,-20
2000bfbc:	18c03fcc 	andi	r3,r3,255
2000bfc0:	01803a84 	movi	r6,234
2000bfc4:	30c0962e 	bgeu	r6,r3,2000c220 <OSTaskChangePrio+0x268>
        if (oldprio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
2000bfc8:	29c03fcc 	andi	r7,r5,255
2000bfcc:	00c004c4 	movi	r3,19
2000bfd0:	19c09336 	bltu	r3,r7,2000c220 <OSTaskChangePrio+0x268>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000bfd4:	0011303a 	rdctl	r8,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000bfd8:	00ffff84 	movi	r3,-2
2000bfdc:	40c6703a 	and	r3,r8,r3
2000bfe0:	1801703a 	wrctl	status,r3
        return (OS_ERR_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
2000bfe4:	00c00034 	movhi	r3,0
2000bfe8:	39cd883a 	add	r6,r7,r7
2000bfec:	18de0004 	addi	r3,r3,30720
2000bff0:	3193883a 	add	r9,r6,r6
2000bff4:	1a53883a 	add	r9,r3,r9
2000bff8:	4a400017 	ldw	r9,0(r9)
2000bffc:	48000326 	beq	r9,zero,2000c00c <OSTaskChangePrio+0x54>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c000:	4001703a 	wrctl	status,r8
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
2000c004:	00800a04 	movi	r2,40
2000c008:	f800283a 	ret
2000c00c:	2005883a 	mov	r2,r4
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
2000c010:	02403fc4 	movi	r9,255
2000c014:	21003fcc 	andi	r4,r4,255
2000c018:	2240041e 	bne	r4,r9,2000c02c <OSTaskChangePrio+0x74>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
2000c01c:	00800034 	movhi	r2,0
2000c020:	10818204 	addi	r2,r2,1544
2000c024:	10800017 	ldw	r2,0(r2)
2000c028:	10800c83 	ldbu	r2,50(r2)
    }
    ptcb = OSTCBPrioTbl[oldprio];
2000c02c:	10803fcc 	andi	r2,r2,255
2000c030:	1085883a 	add	r2,r2,r2
2000c034:	1085883a 	add	r2,r2,r2
2000c038:	1887883a 	add	r3,r3,r2
2000c03c:	18800017 	ldw	r2,0(r3)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
2000c040:	1000031e 	bne	r2,zero,2000c050 <OSTaskChangePrio+0x98>
2000c044:	4001703a 	wrctl	status,r8
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
2000c048:	00800a44 	movi	r2,41
2000c04c:	f800283a 	ret
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
2000c050:	01000044 	movi	r4,1
2000c054:	1100031e 	bne	r2,r4,2000c064 <OSTaskChangePrio+0xac>
2000c058:	4001703a 	wrctl	status,r8
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
2000c05c:	008010c4 	movi	r2,67
2000c060:	f800283a 	ret
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
2000c064:	defffc04 	addi	sp,sp,-16
2000c068:	dc800215 	stw	r18,8(sp)
2000c06c:	dfc00315 	stw	ra,12(sp)
2000c070:	dc400115 	stw	r17,4(sp)
2000c074:	dc000015 	stw	r16,0(sp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
2000c078:	18000015 	stw	zero,0(r3)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
2000c07c:	00c00034 	movhi	r3,0
2000c080:	18de0004 	addi	r3,r3,30720
2000c084:	318d883a 	add	r6,r6,r6
2000c088:	198d883a 	add	r6,r3,r6
2000c08c:	30800015 	stw	r2,0(r6)
    y_old                 =  ptcb->OSTCBY;
    bity_old              =  ptcb->OSTCBBitY;
    bitx_old              =  ptcb->OSTCBBitX;
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
2000c090:	13c00d03 	ldbu	r15,52(r2)
2000c094:	01800034 	movhi	r6,0
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
2000c098:	380ed0fa 	srli	r7,r7,3
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
    y_old                 =  ptcb->OSTCBY;
    bity_old              =  ptcb->OSTCBBitY;
    bitx_old              =  ptcb->OSTCBBitX;
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
2000c09c:	31817f44 	addi	r6,r6,1533
2000c0a0:	33e5883a 	add	r18,r6,r15

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
    y_old                 =  ptcb->OSTCBY;
    bity_old              =  ptcb->OSTCBBitY;
    bitx_old              =  ptcb->OSTCBBitX;
2000c0a4:	14000d43 	ldbu	r16,53(r2)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
2000c0a8:	90c00003 	ldbu	r3,0(r18)
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
    x_new                 = (INT8U)(newprio & 0x07);
2000c0ac:	2ac001cc 	andi	r11,r5,7
    bity_new              = (INT8U)(1 << y_new);
2000c0b0:	3a803fcc 	andi	r10,r7,255
2000c0b4:	2292983a 	sll	r9,r4,r10
    bitx_new              = (INT8U)(1 << x_new);
2000c0b8:	22c8983a 	sll	r4,r4,r11
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
    y_old                 =  ptcb->OSTCBY;
    bity_old              =  ptcb->OSTCBBitY;
    bitx_old              =  ptcb->OSTCBBitX;
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
2000c0bc:	1c1c703a 	and	r14,r3,r16
2000c0c0:	73803fcc 	andi	r14,r14,255
        return (OS_ERR_TASK_NOT_EXIST);
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
    x_new                 = (INT8U)(newprio & 0x07);
    bity_new              = (INT8U)(1 << y_new);
2000c0c4:	4819883a 	mov	r12,r9
    bitx_new              = (INT8U)(1 << x_new);
2000c0c8:	201b883a 	mov	r13,r4
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
    y_old                 =  ptcb->OSTCBY;
    bity_old              =  ptcb->OSTCBBitY;
2000c0cc:	14400d83 	ldbu	r17,54(r2)
    bitx_old              =  ptcb->OSTCBBitX;
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
2000c0d0:	70001226 	beq	r14,zero,2000c11c <OSTaskChangePrio+0x164>
         OSRdyTbl[y_old] &= ~bitx_old;
2000c0d4:	041c303a 	nor	r14,zero,r16
2000c0d8:	70c6703a 	and	r3,r14,r3
2000c0dc:	90c00005 	stb	r3,0(r18)
2000c0e0:	03800034 	movhi	r14,0
         if (OSRdyTbl[y_old] == 0) {
2000c0e4:	18c03fcc 	andi	r3,r3,255
2000c0e8:	73817f04 	addi	r14,r14,1532
2000c0ec:	1800041e 	bne	r3,zero,2000c100 <OSTaskChangePrio+0x148>
             OSRdyGrp &= ~bity_old;
2000c0f0:	74800003 	ldbu	r18,0(r14)
2000c0f4:	0446303a 	nor	r3,zero,r17
2000c0f8:	1c86703a 	and	r3,r3,r18
2000c0fc:	70c00005 	stb	r3,0(r14)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
2000c100:	70c00003 	ldbu	r3,0(r14)
2000c104:	48c6b03a 	or	r3,r9,r3
2000c108:	70c00005 	stb	r3,0(r14)
         OSRdyTbl[y_new] |= bitx_new;
2000c10c:	3287883a 	add	r3,r6,r10
2000c110:	19800003 	ldbu	r6,0(r3)
2000c114:	218cb03a 	or	r6,r4,r6
2000c118:	19800005 	stb	r6,0(r3)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
2000c11c:	10c00717 	ldw	r3,28(r2)
    if (pevent != (OS_EVENT *)0) {
2000c120:	18001226 	beq	r3,zero,2000c16c <OSTaskChangePrio+0x1b4>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
2000c124:	1be5883a 	add	r18,r3,r15
2000c128:	938002c3 	ldbu	r14,11(r18)
2000c12c:	040c303a 	nor	r6,zero,r16
2000c130:	338c703a 	and	r6,r6,r14
2000c134:	918002c5 	stb	r6,11(r18)
        if (pevent->OSEventTbl[y_old] == 0) {
2000c138:	31803fcc 	andi	r6,r6,255
2000c13c:	3000041e 	bne	r6,zero,2000c150 <OSTaskChangePrio+0x198>
            pevent->OSEventGrp    &= ~bity_old;
2000c140:	1b800283 	ldbu	r14,10(r3)
2000c144:	044c303a 	nor	r6,zero,r17
2000c148:	338c703a 	and	r6,r6,r14
2000c14c:	19800285 	stb	r6,10(r3)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
2000c150:	19800283 	ldbu	r6,10(r3)
2000c154:	498cb03a 	or	r6,r9,r6
2000c158:	19800285 	stb	r6,10(r3)
        pevent->OSEventTbl[y_new] |= bitx_new;
2000c15c:	1a87883a 	add	r3,r3,r10
2000c160:	198002c3 	ldbu	r6,11(r3)
2000c164:	218cb03a 	or	r6,r4,r6
2000c168:	198002c5 	stb	r6,11(r3)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
2000c16c:	14800817 	ldw	r18,32(r2)
2000c170:	90000d1e 	bne	r18,zero,2000c1a8 <OSTaskChangePrio+0x1f0>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
2000c174:	11400c85 	stb	r5,50(r2)
    ptcb->OSTCBY    = y_new;
2000c178:	11c00d05 	stb	r7,52(r2)
    ptcb->OSTCBX    = x_new;
2000c17c:	12c00cc5 	stb	r11,51(r2)
    ptcb->OSTCBBitY = bity_new;
2000c180:	12400d85 	stb	r9,54(r2)
    ptcb->OSTCBBitX = bitx_new;
2000c184:	11000d45 	stb	r4,53(r2)
2000c188:	4001703a 	wrctl	status,r8
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
2000c18c:	00800034 	movhi	r2,0
2000c190:	10817344 	addi	r2,r2,1485
2000c194:	10c00003 	ldbu	r3,0(r2)
2000c198:	00800044 	movi	r2,1
2000c19c:	1880191e 	bne	r3,r2,2000c204 <OSTaskChangePrio+0x24c>
        OS_Sched();                                         /* Find new highest priority task          */
2000c1a0:	00098400 	call	20009840 <OS_Sched>
2000c1a4:	00001706 	br	2000c204 <OSTaskChangePrio+0x24c>
        pevent->OSEventTbl[y_new] |= bitx_new;
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
2000c1a8:	90c00017 	ldw	r3,0(r18)
        while (pevent != (OS_EVENT *)0) {
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
2000c1ac:	0420303a 	nor	r16,zero,r16
            if (pevent->OSEventTbl[y_old] == 0) {
                pevent->OSEventGrp    &= ~bity_old;
2000c1b0:	0462303a 	nor	r17,zero,r17
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
2000c1b4:	183fef26 	beq	r3,zero,2000c174 <OSTaskChangePrio+0x1bc>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
2000c1b8:	1bdd883a 	add	r14,r3,r15
2000c1bc:	718002c3 	ldbu	r6,11(r14)
2000c1c0:	818c703a 	and	r6,r16,r6
2000c1c4:	718002c5 	stb	r6,11(r14)
            if (pevent->OSEventTbl[y_old] == 0) {
2000c1c8:	31803fcc 	andi	r6,r6,255
2000c1cc:	3000031e 	bne	r6,zero,2000c1dc <OSTaskChangePrio+0x224>
                pevent->OSEventGrp    &= ~bity_old;
2000c1d0:	19800283 	ldbu	r6,10(r3)
2000c1d4:	898c703a 	and	r6,r17,r6
2000c1d8:	19800285 	stb	r6,10(r3)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
2000c1dc:	19800283 	ldbu	r6,10(r3)
            pevent->OSEventTbl[y_new] |= bitx_new;
            pevents++;
2000c1e0:	94800104 	addi	r18,r18,4
        while (pevent != (OS_EVENT *)0) {
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
            if (pevent->OSEventTbl[y_old] == 0) {
                pevent->OSEventGrp    &= ~bity_old;
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
2000c1e4:	618cb03a 	or	r6,r12,r6
2000c1e8:	19800285 	stb	r6,10(r3)
            pevent->OSEventTbl[y_new] |= bitx_new;
2000c1ec:	1a87883a 	add	r3,r3,r10
2000c1f0:	198002c3 	ldbu	r6,11(r3)
2000c1f4:	698cb03a 	or	r6,r13,r6
2000c1f8:	198002c5 	stb	r6,11(r3)
            pevents++;
            pevent                     = *pevents;
2000c1fc:	90c00017 	ldw	r3,0(r18)
2000c200:	003fec06 	br	2000c1b4 <OSTaskChangePrio+0x1fc>
    ptcb->OSTCBBitX = bitx_new;
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
        OS_Sched();                                         /* Find new highest priority task          */
    }
    return (OS_ERR_NONE);
2000c204:	0005883a 	mov	r2,zero
}
2000c208:	dfc00317 	ldw	ra,12(sp)
2000c20c:	dc800217 	ldw	r18,8(sp)
2000c210:	dc400117 	ldw	r17,4(sp)
2000c214:	dc000017 	ldw	r16,0(sp)
2000c218:	dec00404 	addi	sp,sp,16
2000c21c:	f800283a 	ret

/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
        if (oldprio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
2000c220:	00800a84 	movi	r2,42
2000c224:	f800283a 	ret

2000c228 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
2000c228:	defff704 	addi	sp,sp,-36
2000c22c:	dcc00615 	stw	r19,24(sp)
2000c230:	dfc00815 	stw	ra,32(sp)
2000c234:	dd000715 	stw	r20,28(sp)
2000c238:	dc800515 	stw	r18,20(sp)
2000c23c:	dc400415 	stw	r17,16(sp)
2000c240:	dc000315 	stw	r16,12(sp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
2000c244:	3cc03fcc 	andi	r19,r7,255
2000c248:	00800504 	movi	r2,20
2000c24c:	14c03236 	bltu	r2,r19,2000c318 <OSTaskCreate+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000c250:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000c254:	04bfff84 	movi	r18,-2
2000c258:	1486703a 	and	r3,r2,r18
2000c25c:	1801703a 	wrctl	status,r3
        return (OS_ERR_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
2000c260:	00c00034 	movhi	r3,0
2000c264:	18c18104 	addi	r3,r3,1540
2000c268:	1c400003 	ldbu	r17,0(r3)
2000c26c:	88c03fcc 	andi	r3,r17,255
2000c270:	18000326 	beq	r3,zero,2000c280 <OSTaskCreate+0x58>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c274:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
2000c278:	04400f04 	movi	r17,60
2000c27c:	00002706 	br	2000c31c <OSTaskCreate+0xf4>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
2000c280:	9ce1883a 	add	r16,r19,r19
2000c284:	00c00034 	movhi	r3,0
2000c288:	18de0004 	addi	r3,r3,30720
2000c28c:	8421883a 	add	r16,r16,r16
2000c290:	1c21883a 	add	r16,r3,r16
2000c294:	80c00017 	ldw	r3,0(r16)
2000c298:	18001c1e 	bne	r3,zero,2000c30c <OSTaskCreate+0xe4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
2000c29c:	05000044 	movi	r20,1
2000c2a0:	85000015 	stw	r20,0(r16)
2000c2a4:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
2000c2a8:	000f883a 	mov	r7,zero
2000c2ac:	000e1b00 	call	2000e1b0 <OSTaskStkInit>
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
2000c2b0:	9809883a 	mov	r4,r19
2000c2b4:	d8000015 	stw	zero,0(sp)
2000c2b8:	d8000115 	stw	zero,4(sp)
2000c2bc:	d8000215 	stw	zero,8(sp)
2000c2c0:	100b883a 	mov	r5,r2
2000c2c4:	000d883a 	mov	r6,zero
2000c2c8:	000f883a 	mov	r7,zero
2000c2cc:	0009f380 	call	20009f38 <OS_TCBInit>
        if (err == OS_ERR_NONE) {
2000c2d0:	10c03fcc 	andi	r3,r2,255
2000c2d4:	1800061e 	bne	r3,zero,2000c2f0 <OSTaskCreate+0xc8>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
2000c2d8:	00800034 	movhi	r2,0
2000c2dc:	10817344 	addi	r2,r2,1485
2000c2e0:	10800003 	ldbu	r2,0(r2)
2000c2e4:	15000d1e 	bne	r2,r20,2000c31c <OSTaskCreate+0xf4>
                OS_Sched();
2000c2e8:	00098400 	call	20009840 <OS_Sched>
2000c2ec:	00000b06 	br	2000c31c <OSTaskCreate+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000c2f0:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000c2f4:	1ca4703a 	and	r18,r3,r18
2000c2f8:	9001703a 	wrctl	status,r18
            }
        } else {
            OS_ENTER_CRITICAL();
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
2000c2fc:	80000015 	stw	zero,0(r16)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c300:	1801703a 	wrctl	status,r3
2000c304:	1023883a 	mov	r17,r2
2000c308:	00000406 	br	2000c31c <OSTaskCreate+0xf4>
2000c30c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
2000c310:	04400a04 	movi	r17,40
2000c314:	00000106 	br	2000c31c <OSTaskCreate+0xf4>



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_ERR_PRIO_INVALID);
2000c318:	04400a84 	movi	r17,42
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
}
2000c31c:	8805883a 	mov	r2,r17
2000c320:	dfc00817 	ldw	ra,32(sp)
2000c324:	dd000717 	ldw	r20,28(sp)
2000c328:	dcc00617 	ldw	r19,24(sp)
2000c32c:	dc800517 	ldw	r18,20(sp)
2000c330:	dc400417 	ldw	r17,16(sp)
2000c334:	dc000317 	ldw	r16,12(sp)
2000c338:	dec00904 	addi	sp,sp,36
2000c33c:	f800283a 	ret

2000c340 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
2000c340:	defff904 	addi	sp,sp,-28
    OS_CPU_SR     cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
2000c344:	00800034 	movhi	r2,0
2000c348:	10818104 	addi	r2,r2,1540
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
2000c34c:	dfc00615 	stw	ra,24(sp)
2000c350:	dd400515 	stw	r21,20(sp)
2000c354:	dd000415 	stw	r20,16(sp)
2000c358:	dcc00315 	stw	r19,12(sp)
2000c35c:	dc800215 	stw	r18,8(sp)
2000c360:	dc400115 	stw	r17,4(sp)
2000c364:	dc000015 	stw	r16,0(sp)
    OS_CPU_SR     cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
2000c368:	14800003 	ldbu	r18,0(r2)
2000c36c:	90803fcc 	andi	r2,r18,255
2000c370:	10007c1e 	bne	r2,zero,2000c564 <OSTaskDel+0x224>
        return (OS_ERR_TASK_DEL_ISR);
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
2000c374:	20c03fcc 	andi	r3,r4,255
2000c378:	00800504 	movi	r2,20
2000c37c:	18807b26 	beq	r3,r2,2000c56c <OSTaskDel+0x22c>
2000c380:	2023883a 	mov	r17,r4
        return (OS_ERR_TASK_DEL_IDLE);
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
2000c384:	213ffb04 	addi	r4,r4,-20
2000c388:	21003fcc 	andi	r4,r4,255
2000c38c:	00803a84 	movi	r2,234
2000c390:	1100782e 	bgeu	r2,r4,2000c574 <OSTaskDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000c394:	002b303a 	rdctl	r21,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000c398:	00bfff84 	movi	r2,-2
2000c39c:	a884703a 	and	r2,r21,r2
2000c3a0:	1001703a 	wrctl	status,r2
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
2000c3a4:	00803fc4 	movi	r2,255
2000c3a8:	1880041e 	bne	r3,r2,2000c3bc <OSTaskDel+0x7c>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
2000c3ac:	00800034 	movhi	r2,0
2000c3b0:	10818204 	addi	r2,r2,1544
2000c3b4:	10800017 	ldw	r2,0(r2)
2000c3b8:	14400c83 	ldbu	r17,50(r2)
    }
    ptcb = OSTCBPrioTbl[prio];
2000c3bc:	88803fcc 	andi	r2,r17,255
2000c3c0:	05000034 	movhi	r20,0
2000c3c4:	10a3883a 	add	r17,r2,r2
2000c3c8:	a51e0004 	addi	r20,r20,30720
2000c3cc:	8c45883a 	add	r2,r17,r17
2000c3d0:	a085883a 	add	r2,r20,r2
2000c3d4:	14000017 	ldw	r16,0(r2)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
2000c3d8:	8000031e 	bne	r16,zero,2000c3e8 <OSTaskDel+0xa8>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c3dc:	a801703a 	wrctl	status,r21
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
2000c3e0:	048010c4 	movi	r18,67
2000c3e4:	00006406 	br	2000c578 <OSTaskDel+0x238>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
2000c3e8:	00800044 	movi	r2,1
2000c3ec:	8080031e 	bne	r16,r2,2000c3fc <OSTaskDel+0xbc>
2000c3f0:	a801703a 	wrctl	status,r21
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
2000c3f4:	04800f44 	movi	r18,61
2000c3f8:	00005f06 	br	2000c578 <OSTaskDel+0x238>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
2000c3fc:	80800d03 	ldbu	r2,52(r16)
2000c400:	00c00034 	movhi	r3,0
2000c404:	18c17f44 	addi	r3,r3,1533
2000c408:	1887883a 	add	r3,r3,r2
2000c40c:	80800d43 	ldbu	r2,53(r16)
2000c410:	0088303a 	nor	r4,zero,r2
2000c414:	18800003 	ldbu	r2,0(r3)
2000c418:	2084703a 	and	r2,r4,r2
2000c41c:	18800005 	stb	r2,0(r3)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
2000c420:	10803fcc 	andi	r2,r2,255
2000c424:	1000071e 	bne	r2,zero,2000c444 <OSTaskDel+0x104>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
2000c428:	80800d83 	ldbu	r2,54(r16)
2000c42c:	01000034 	movhi	r4,0
2000c430:	21017f04 	addi	r4,r4,1532
2000c434:	0086303a 	nor	r3,zero,r2
2000c438:	20800003 	ldbu	r2,0(r4)
2000c43c:	1884703a 	and	r2,r3,r2
2000c440:	20800005 	stb	r2,0(r4)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
2000c444:	81400717 	ldw	r5,28(r16)
2000c448:	28000226 	beq	r5,zero,2000c454 <OSTaskDel+0x114>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
2000c44c:	8009883a 	mov	r4,r16
2000c450:	00094640 	call	20009464 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
2000c454:	81400817 	ldw	r5,32(r16)
2000c458:	28000226 	beq	r5,zero,2000c464 <OSTaskDel+0x124>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
2000c45c:	8009883a 	mov	r4,r16
2000c460:	00094a00 	call	200094a0 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
2000c464:	81000a17 	ldw	r4,40(r16)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
2000c468:	20000126 	beq	r4,zero,2000c470 <OSTaskDel+0x130>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
2000c46c:	000a59c0 	call	2000a59c <OS_FlagUnlink>
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
2000c470:	04c00034 	movhi	r19,0
2000c474:	9cc17304 	addi	r19,r19,1484
2000c478:	98800003 	ldbu	r2,0(r19)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
2000c47c:	80000b8d 	sth	zero,46(r16)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
2000c480:	80000c05 	stb	zero,48(r16)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
2000c484:	80000c45 	stb	zero,49(r16)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
2000c488:	11003fcc 	andi	r4,r2,255
2000c48c:	00c03fc4 	movi	r3,255
2000c490:	20c00226 	beq	r4,r3,2000c49c <OSTaskDel+0x15c>
        OSLockNesting++;
2000c494:	10800044 	addi	r2,r2,1
2000c498:	98800005 	stb	r2,0(r19)
2000c49c:	a801703a 	wrctl	status,r21
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
2000c4a0:	00093740 	call	20009374 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000c4a4:	002b303a 	rdctl	r21,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000c4a8:	00bfff84 	movi	r2,-2
2000c4ac:	a884703a 	and	r2,r21,r2
2000c4b0:	1001703a 	wrctl	status,r2
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
2000c4b4:	98800003 	ldbu	r2,0(r19)
2000c4b8:	10c03fcc 	andi	r3,r2,255
2000c4bc:	18000426 	beq	r3,zero,2000c4d0 <OSTaskDel+0x190>
        OSLockNesting--;
2000c4c0:	00c00034 	movhi	r3,0
2000c4c4:	10bfffc4 	addi	r2,r2,-1
2000c4c8:	18c17304 	addi	r3,r3,1484
2000c4cc:	18800005 	stb	r2,0(r3)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
2000c4d0:	8009883a 	mov	r4,r16
2000c4d4:	000e28c0 	call	2000e28c <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
2000c4d8:	00c00034 	movhi	r3,0
2000c4dc:	18c17b44 	addi	r3,r3,1517
2000c4e0:	18800003 	ldbu	r2,0(r3)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
2000c4e4:	8c63883a 	add	r17,r17,r17
2000c4e8:	a463883a 	add	r17,r20,r17
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
        OSLockNesting--;
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
    OSTaskCtr--;                                        /* One less task being managed                 */
2000c4ec:	10bfffc4 	addi	r2,r2,-1
2000c4f0:	18800005 	stb	r2,0(r3)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
2000c4f4:	80800617 	ldw	r2,24(r16)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
        OSLockNesting--;
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
    OSTaskCtr--;                                        /* One less task being managed                 */
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
2000c4f8:	88000015 	stw	zero,0(r17)
2000c4fc:	80c00517 	ldw	r3,20(r16)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
2000c500:	1000051e 	bne	r2,zero,2000c518 <OSTaskDel+0x1d8>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
        OSTCBList                  = ptcb->OSTCBNext;
2000c504:	00800034 	movhi	r2,0
2000c508:	10817604 	addi	r2,r2,1496
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
    OSTaskCtr--;                                        /* One less task being managed                 */
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
2000c50c:	18000615 	stw	zero,24(r3)
        OSTCBList                  = ptcb->OSTCBNext;
2000c510:	10c00015 	stw	r3,0(r2)
2000c514:	00000306 	br	2000c524 <OSTaskDel+0x1e4>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
2000c518:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
2000c51c:	80c00517 	ldw	r3,20(r16)
2000c520:	18800615 	stw	r2,24(r3)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
2000c524:	00800034 	movhi	r2,0
2000c528:	10817a04 	addi	r2,r2,1512
2000c52c:	10c00017 	ldw	r3,0(r2)
    OSTCBFreeList     = ptcb;
2000c530:	14000015 	stw	r16,0(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
2000c534:	00800fc4 	movi	r2,63
        OSTCBList                  = ptcb->OSTCBNext;
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
2000c538:	80c00515 	stw	r3,20(r16)
    OSTCBFreeList     = ptcb;
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
2000c53c:	80801305 	stb	r2,76(r16)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
2000c540:	80001345 	stb	zero,77(r16)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c544:	a801703a 	wrctl	status,r21
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
2000c548:	00800034 	movhi	r2,0
2000c54c:	10817344 	addi	r2,r2,1485
2000c550:	10c00003 	ldbu	r3,0(r2)
2000c554:	00800044 	movi	r2,1
2000c558:	1880071e 	bne	r3,r2,2000c578 <OSTaskDel+0x238>
        OS_Sched();                                     /* Find new highest priority task              */
2000c55c:	00098400 	call	20009840 <OS_Sched>
2000c560:	00000506 	br	2000c578 <OSTaskDel+0x238>
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
        return (OS_ERR_TASK_DEL_ISR);
2000c564:	04801004 	movi	r18,64
2000c568:	00000306 	br	2000c578 <OSTaskDel+0x238>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
        return (OS_ERR_TASK_DEL_IDLE);
2000c56c:	04800f84 	movi	r18,62
2000c570:	00000106 	br	2000c578 <OSTaskDel+0x238>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
        if (prio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
2000c574:	04800a84 	movi	r18,42
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
        OS_Sched();                                     /* Find new highest priority task              */
    }
    return (OS_ERR_NONE);
}
2000c578:	9005883a 	mov	r2,r18
2000c57c:	dfc00617 	ldw	ra,24(sp)
2000c580:	dd400517 	ldw	r21,20(sp)
2000c584:	dd000417 	ldw	r20,16(sp)
2000c588:	dcc00317 	ldw	r19,12(sp)
2000c58c:	dc800217 	ldw	r18,8(sp)
2000c590:	dc400117 	ldw	r17,4(sp)
2000c594:	dc000017 	ldw	r16,0(sp)
2000c598:	dec00704 	addi	sp,sp,28
2000c59c:	f800283a 	ret

2000c5a0 <OSTaskDelReq>:
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
2000c5a0:	21003fcc 	andi	r4,r4,255
2000c5a4:	00800504 	movi	r2,20
2000c5a8:	20802626 	beq	r4,r2,2000c644 <OSTaskDelReq+0xa4>
        return (OS_ERR_TASK_DEL_IDLE);
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
2000c5ac:	008004c4 	movi	r2,19
2000c5b0:	11000c2e 	bgeu	r2,r4,2000c5e4 <OSTaskDelReq+0x44>
        if (prio != OS_PRIO_SELF) {
2000c5b4:	00803fc4 	movi	r2,255
2000c5b8:	2080241e 	bne	r4,r2,2000c64c <OSTaskDelReq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000c5bc:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000c5c0:	00bfff84 	movi	r2,-2
2000c5c4:	1884703a 	and	r2,r3,r2
2000c5c8:	1001703a 	wrctl	status,r2
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
2000c5cc:	00800034 	movhi	r2,0
2000c5d0:	10818204 	addi	r2,r2,1544
2000c5d4:	10800017 	ldw	r2,0(r2)
2000c5d8:	10800dc3 	ldbu	r2,55(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c5dc:	1801703a 	wrctl	status,r3
        OS_EXIT_CRITICAL();
        return (stat);
2000c5e0:	f800283a 	ret
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000c5e4:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000c5e8:	00ffff84 	movi	r3,-2
2000c5ec:	10c6703a 	and	r3,r2,r3
2000c5f0:	1801703a 	wrctl	status,r3
    }
    OS_ENTER_CRITICAL();
    ptcb = OSTCBPrioTbl[prio];
2000c5f4:	2109883a 	add	r4,r4,r4
2000c5f8:	00c00034 	movhi	r3,0
2000c5fc:	18de0004 	addi	r3,r3,30720
2000c600:	2109883a 	add	r4,r4,r4
2000c604:	1909883a 	add	r4,r3,r4
2000c608:	20c00017 	ldw	r3,0(r4)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
2000c60c:	1800031e 	bne	r3,zero,2000c61c <OSTaskDelReq+0x7c>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c610:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
2000c614:	008010c4 	movi	r2,67
2000c618:	f800283a 	ret
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
2000c61c:	01000044 	movi	r4,1
2000c620:	1900031e 	bne	r3,r4,2000c630 <OSTaskDelReq+0x90>
2000c624:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
2000c628:	00800f44 	movi	r2,61
2000c62c:	f800283a 	ret
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
2000c630:	01000fc4 	movi	r4,63
2000c634:	19000dc5 	stb	r4,55(r3)
2000c638:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
2000c63c:	0005883a 	mov	r2,zero
2000c640:	f800283a 	ret
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
        return (OS_ERR_TASK_DEL_IDLE);
2000c644:	00800f84 	movi	r2,62
2000c648:	f800283a 	ret
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
        if (prio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
2000c64c:	00800a84 	movi	r2,42
        return (OS_ERR_TASK_DEL);
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
}
2000c650:	f800283a 	ret

2000c654 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
2000c654:	defffd04 	addi	sp,sp,-12
2000c658:	dc000015 	stw	r16,0(sp)
2000c65c:	dfc00215 	stw	ra,8(sp)
2000c660:	dc400115 	stw	r17,4(sp)
2000c664:	3021883a 	mov	r16,r6
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
2000c668:	30003126 	beq	r6,zero,2000c730 <OSTaskNameGet+0xdc>
        return (0);
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
2000c66c:	20bffac4 	addi	r2,r4,-21
2000c670:	10803fcc 	andi	r2,r2,255
2000c674:	01803a44 	movi	r6,233
2000c678:	30800236 	bltu	r6,r2,2000c684 <OSTaskNameGet+0x30>
        if (prio != OS_PRIO_SELF) {
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
2000c67c:	00800a84 	movi	r2,42
2000c680:	00000206 	br	2000c68c <OSTaskNameGet+0x38>
            return (0);
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
2000c684:	2800031e 	bne	r5,zero,2000c694 <OSTaskNameGet+0x40>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
2000c688:	00800304 	movi	r2,12
2000c68c:	80800005 	stb	r2,0(r16)
2000c690:	00002706 	br	2000c730 <OSTaskNameGet+0xdc>
        return (0);
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
2000c694:	00800034 	movhi	r2,0
2000c698:	10818104 	addi	r2,r2,1540
2000c69c:	10800003 	ldbu	r2,0(r2)
2000c6a0:	11803fcc 	andi	r6,r2,255
2000c6a4:	30000226 	beq	r6,zero,2000c6b0 <OSTaskNameGet+0x5c>
        *perr = OS_ERR_NAME_GET_ISR;
2000c6a8:	00800444 	movi	r2,17
2000c6ac:	003ff706 	br	2000c68c <OSTaskNameGet+0x38>
2000c6b0:	2007883a 	mov	r3,r4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000c6b4:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000c6b8:	01bfff84 	movi	r6,-2
2000c6bc:	898c703a 	and	r6,r17,r6
2000c6c0:	3001703a 	wrctl	status,r6
        return (0);
    }
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
2000c6c4:	21803fcc 	andi	r6,r4,255
2000c6c8:	01003fc4 	movi	r4,255
2000c6cc:	3100041e 	bne	r6,r4,2000c6e0 <OSTaskNameGet+0x8c>
        prio = OSTCBCur->OSTCBPrio;
2000c6d0:	00c00034 	movhi	r3,0
2000c6d4:	18c18204 	addi	r3,r3,1544
2000c6d8:	18c00017 	ldw	r3,0(r3)
2000c6dc:	18c00c83 	ldbu	r3,50(r3)
    }
    ptcb = OSTCBPrioTbl[prio];
2000c6e0:	18c03fcc 	andi	r3,r3,255
2000c6e4:	18c7883a 	add	r3,r3,r3
2000c6e8:	01000034 	movhi	r4,0
2000c6ec:	18c7883a 	add	r3,r3,r3
2000c6f0:	211e0004 	addi	r4,r4,30720
2000c6f4:	20c7883a 	add	r3,r4,r3
2000c6f8:	18c00017 	ldw	r3,0(r3)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
2000c6fc:	18000226 	beq	r3,zero,2000c708 <OSTaskNameGet+0xb4>
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
        return (0);
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
2000c700:	01000044 	movi	r4,1
2000c704:	1900041e 	bne	r3,r4,2000c718 <OSTaskNameGet+0xc4>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c708:	8801703a 	wrctl	status,r17
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
2000c70c:	00c010c4 	movi	r3,67
2000c710:	80c00005 	stb	r3,0(r16)
        return (0);
2000c714:	00000706 	br	2000c734 <OSTaskNameGet+0xe0>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
2000c718:	2809883a 	mov	r4,r5
2000c71c:	19401304 	addi	r5,r3,76
2000c720:	0009c500 	call	20009c50 <OS_StrCopy>
2000c724:	8801703a 	wrctl	status,r17
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2000c728:	80000005 	stb	zero,0(r16)
    return (len);
2000c72c:	00000106 	br	2000c734 <OSTaskNameGet+0xe0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
        return (0);
2000c730:	0005883a 	mov	r2,zero
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (len);
}
2000c734:	dfc00217 	ldw	ra,8(sp)
2000c738:	dc400117 	ldw	r17,4(sp)
2000c73c:	dc000017 	ldw	r16,0(sp)
2000c740:	dec00304 	addi	sp,sp,12
2000c744:	f800283a 	ret

2000c748 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
2000c748:	defffb04 	addi	sp,sp,-20
2000c74c:	dc000115 	stw	r16,4(sp)
2000c750:	dfc00415 	stw	ra,16(sp)
2000c754:	dc800315 	stw	r18,12(sp)
2000c758:	dc400215 	stw	r17,8(sp)
2000c75c:	3021883a 	mov	r16,r6
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
2000c760:	30003726 	beq	r6,zero,2000c840 <OSTaskNameSet+0xf8>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
2000c764:	20fffac4 	addi	r3,r4,-21
2000c768:	18c03fcc 	andi	r3,r3,255
2000c76c:	01803a44 	movi	r6,233
2000c770:	30c00236 	bltu	r6,r3,2000c77c <OSTaskNameSet+0x34>
        if (prio != OS_PRIO_SELF) {
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
2000c774:	00800a84 	movi	r2,42
2000c778:	00002b06 	br	2000c828 <OSTaskNameSet+0xe0>
            return;
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
2000c77c:	2800021e 	bne	r5,zero,2000c788 <OSTaskNameSet+0x40>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
2000c780:	00800304 	movi	r2,12
2000c784:	00002806 	br	2000c828 <OSTaskNameSet+0xe0>
        return;
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
2000c788:	00c00034 	movhi	r3,0
2000c78c:	18c18104 	addi	r3,r3,1540
2000c790:	18c00003 	ldbu	r3,0(r3)
2000c794:	18000226 	beq	r3,zero,2000c7a0 <OSTaskNameSet+0x58>
        *perr = OS_ERR_NAME_SET_ISR;
2000c798:	00800484 	movi	r2,18
2000c79c:	00002206 	br	2000c828 <OSTaskNameSet+0xe0>
2000c7a0:	2005883a 	mov	r2,r4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000c7a4:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000c7a8:	00ffff84 	movi	r3,-2
2000c7ac:	88c6703a 	and	r3,r17,r3
2000c7b0:	1801703a 	wrctl	status,r3
        return;
    }
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
2000c7b4:	20c03fcc 	andi	r3,r4,255
2000c7b8:	01003fc4 	movi	r4,255
2000c7bc:	1900041e 	bne	r3,r4,2000c7d0 <OSTaskNameSet+0x88>
        prio = OSTCBCur->OSTCBPrio;
2000c7c0:	00800034 	movhi	r2,0
2000c7c4:	10818204 	addi	r2,r2,1544
2000c7c8:	10800017 	ldw	r2,0(r2)
2000c7cc:	10800c83 	ldbu	r2,50(r2)
    }
    ptcb = OSTCBPrioTbl[prio];
2000c7d0:	10803fcc 	andi	r2,r2,255
2000c7d4:	1085883a 	add	r2,r2,r2
2000c7d8:	00c00034 	movhi	r3,0
2000c7dc:	1085883a 	add	r2,r2,r2
2000c7e0:	18de0004 	addi	r3,r3,30720
2000c7e4:	1885883a 	add	r2,r3,r2
2000c7e8:	14800017 	ldw	r18,0(r2)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
2000c7ec:	90000226 	beq	r18,zero,2000c7f8 <OSTaskNameSet+0xb0>
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
        return;
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
2000c7f0:	00800044 	movi	r2,1
2000c7f4:	9080031e 	bne	r18,r2,2000c804 <OSTaskNameSet+0xbc>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c7f8:	8801703a 	wrctl	status,r17
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
2000c7fc:	008010c4 	movi	r2,67
2000c800:	00000906 	br	2000c828 <OSTaskNameSet+0xe0>
        return;
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
2000c804:	2809883a 	mov	r4,r5
2000c808:	d9400015 	stw	r5,0(sp)
2000c80c:	0009d240 	call	20009d24 <OS_StrLen>
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
2000c810:	10803fcc 	andi	r2,r2,255
2000c814:	00c007c4 	movi	r3,31
2000c818:	d9400017 	ldw	r5,0(sp)
2000c81c:	1880042e 	bgeu	r3,r2,2000c830 <OSTaskNameSet+0xe8>
2000c820:	8801703a 	wrctl	status,r17
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
2000c824:	00801044 	movi	r2,65
2000c828:	80800005 	stb	r2,0(r16)
        return;
2000c82c:	00000406 	br	2000c840 <OSTaskNameSet+0xf8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
2000c830:	91001304 	addi	r4,r18,76
2000c834:	0009c500 	call	20009c50 <OS_StrCopy>
2000c838:	8801703a 	wrctl	status,r17
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
2000c83c:	80000005 	stb	zero,0(r16)
}
2000c840:	dfc00417 	ldw	ra,16(sp)
2000c844:	dc800317 	ldw	r18,12(sp)
2000c848:	dc400217 	ldw	r17,8(sp)
2000c84c:	dc000117 	ldw	r16,4(sp)
2000c850:	dec00504 	addi	sp,sp,20
2000c854:	f800283a 	ret

2000c858 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
2000c858:	defffe04 	addi	sp,sp,-8
2000c85c:	dfc00115 	stw	ra,4(sp)
2000c860:	dc000015 	stw	r16,0(sp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
2000c864:	21003fcc 	andi	r4,r4,255
2000c868:	008004c4 	movi	r2,19
2000c86c:	11003b36 	bltu	r2,r4,2000c95c <OSTaskResume+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000c870:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000c874:	00bfff84 	movi	r2,-2
2000c878:	2884703a 	and	r2,r5,r2
2000c87c:	1001703a 	wrctl	status,r2
        return (OS_ERR_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    ptcb = OSTCBPrioTbl[prio];
2000c880:	2109883a 	add	r4,r4,r4
2000c884:	00800034 	movhi	r2,0
2000c888:	2109883a 	add	r4,r4,r4
2000c88c:	109e0004 	addi	r2,r2,30720
2000c890:	1109883a 	add	r4,r2,r4
2000c894:	20c00017 	ldw	r3,0(r4)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
2000c898:	1800031e 	bne	r3,zero,2000c8a8 <OSTaskResume+0x50>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c89c:	2801703a 	wrctl	status,r5
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
2000c8a0:	04001184 	movi	r16,70
2000c8a4:	00002e06 	br	2000c960 <OSTaskResume+0x108>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
2000c8a8:	01800044 	movi	r6,1
2000c8ac:	1980031e 	bne	r3,r6,2000c8bc <OSTaskResume+0x64>
2000c8b0:	2801703a 	wrctl	status,r5
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
2000c8b4:	040010c4 	movi	r16,67
2000c8b8:	00002906 	br	2000c960 <OSTaskResume+0x108>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
2000c8bc:	19000c03 	ldbu	r4,48(r3)
2000c8c0:	2080020c 	andi	r2,r4,8
2000c8c4:	10002226 	beq	r2,zero,2000c950 <OSTaskResume+0xf8>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
2000c8c8:	00bffdc4 	movi	r2,-9
2000c8cc:	2088703a 	and	r4,r4,r2
2000c8d0:	2021883a 	mov	r16,r4
2000c8d4:	19000c05 	stb	r4,48(r3)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
2000c8d8:	21003fcc 	andi	r4,r4,255
2000c8dc:	2000191e 	bne	r4,zero,2000c944 <OSTaskResume+0xec>
            if (ptcb->OSTCBDly == 0) {
2000c8e0:	18800b8b 	ldhu	r2,46(r3)
2000c8e4:	1000151e 	bne	r2,zero,2000c93c <OSTaskResume+0xe4>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
2000c8e8:	01000034 	movhi	r4,0
2000c8ec:	21017f04 	addi	r4,r4,1532
2000c8f0:	20800003 	ldbu	r2,0(r4)
2000c8f4:	19c00d83 	ldbu	r7,54(r3)
2000c8f8:	3884b03a 	or	r2,r7,r2
2000c8fc:	20800005 	stb	r2,0(r4)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
2000c900:	18800d03 	ldbu	r2,52(r3)
2000c904:	01000034 	movhi	r4,0
2000c908:	21017f44 	addi	r4,r4,1533
2000c90c:	2085883a 	add	r2,r4,r2
2000c910:	11000003 	ldbu	r4,0(r2)
2000c914:	18c00d43 	ldbu	r3,53(r3)
2000c918:	20c6b03a 	or	r3,r4,r3
2000c91c:	10c00005 	stb	r3,0(r2)
2000c920:	2801703a 	wrctl	status,r5
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
2000c924:	00800034 	movhi	r2,0
2000c928:	10817344 	addi	r2,r2,1485
2000c92c:	10800003 	ldbu	r2,0(r2)
2000c930:	11800b1e 	bne	r2,r6,2000c960 <OSTaskResume+0x108>
                    OS_Sched();                               /* Find new highest priority task        */
2000c934:	00098400 	call	20009840 <OS_Sched>
2000c938:	00000906 	br	2000c960 <OSTaskResume+0x108>
2000c93c:	2801703a 	wrctl	status,r5
2000c940:	00000706 	br	2000c960 <OSTaskResume+0x108>
2000c944:	2801703a 	wrctl	status,r5
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
2000c948:	0021883a 	mov	r16,zero
2000c94c:	00000406 	br	2000c960 <OSTaskResume+0x108>
2000c950:	2801703a 	wrctl	status,r5
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
2000c954:	04001104 	movi	r16,68
2000c958:	00000106 	br	2000c960 <OSTaskResume+0x108>



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
        return (OS_ERR_PRIO_INVALID);
2000c95c:	04000a84 	movi	r16,42
        }
        return (OS_ERR_NONE);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
}
2000c960:	8005883a 	mov	r2,r16
2000c964:	dfc00117 	ldw	ra,4(sp)
2000c968:	dc000017 	ldw	r16,0(sp)
2000c96c:	dec00204 	addi	sp,sp,8
2000c970:	f800283a 	ret

2000c974 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
2000c974:	2005883a 	mov	r2,r4
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
2000c978:	00c00504 	movi	r3,20
2000c97c:	21003fcc 	andi	r4,r4,255
2000c980:	1900042e 	bgeu	r3,r4,2000c994 <OSTaskStkChk+0x20>
        if (prio != OS_PRIO_SELF) {
2000c984:	00803fc4 	movi	r2,255
2000c988:	20803026 	beq	r4,r2,2000ca4c <OSTaskStkChk+0xd8>
            return (OS_ERR_PRIO_INVALID);
2000c98c:	00800a84 	movi	r2,42
2000c990:	f800283a 	ret
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
2000c994:	28002b26 	beq	r5,zero,2000ca44 <OSTaskStkChk+0xd0>
        return (OS_ERR_PDATA_NULL);
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
2000c998:	28000015 	stw	zero,0(r5)
    p_stk_data->OSUsed = 0;
2000c99c:	28000115 	stw	zero,4(r5)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000c9a0:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000c9a4:	013fff84 	movi	r4,-2
2000c9a8:	1908703a 	and	r4,r3,r4
2000c9ac:	2001703a 	wrctl	status,r4
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
        prio = OSTCBCur->OSTCBPrio;
    }
    ptcb = OSTCBPrioTbl[prio];
2000c9b0:	10803fcc 	andi	r2,r2,255
2000c9b4:	1085883a 	add	r2,r2,r2
2000c9b8:	01000034 	movhi	r4,0
2000c9bc:	211e0004 	addi	r4,r4,30720
2000c9c0:	1085883a 	add	r2,r2,r2
2000c9c4:	2085883a 	add	r2,r4,r2
2000c9c8:	11000017 	ldw	r4,0(r2)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
2000c9cc:	20000226 	beq	r4,zero,2000c9d8 <OSTaskStkChk+0x64>
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
    }
    if (ptcb == OS_TCB_RESERVED) {
2000c9d0:	00800044 	movi	r2,1
2000c9d4:	2080031e 	bne	r4,r2,2000c9e4 <OSTaskStkChk+0x70>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000c9d8:	1801703a 	wrctl	status,r3
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
2000c9dc:	008010c4 	movi	r2,67
2000c9e0:	f800283a 	ret
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
2000c9e4:	2080040b 	ldhu	r2,16(r4)
2000c9e8:	1080004c 	andi	r2,r2,1
2000c9ec:	1000031e 	bne	r2,zero,2000c9fc <OSTaskStkChk+0x88>
2000c9f0:	1801703a 	wrctl	status,r3
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
2000c9f4:	00801144 	movi	r2,69
2000c9f8:	f800283a 	ret
    }
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
2000c9fc:	20800317 	ldw	r2,12(r4)
    pchk  = ptcb->OSTCBStkBottom;
2000ca00:	21c00217 	ldw	r7,8(r4)
2000ca04:	1801703a 	wrctl	status,r3
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
    }
    nfree = 0;
2000ca08:	0007883a 	mov	r3,zero
2000ca0c:	18c9883a 	add	r4,r3,r3
2000ca10:	2109883a 	add	r4,r4,r4
2000ca14:	390d883a 	add	r6,r7,r4
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
2000ca18:	31800017 	ldw	r6,0(r6)
2000ca1c:	3000021e 	bne	r6,zero,2000ca28 <OSTaskStkChk+0xb4>
        nfree++;
2000ca20:	18c00044 	addi	r3,r3,1
2000ca24:	003ff906 	br	2000ca0c <OSTaskStkChk+0x98>
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
2000ca28:	10c5c83a 	sub	r2,r2,r3
2000ca2c:	1085883a 	add	r2,r2,r2
2000ca30:	1085883a 	add	r2,r2,r2
2000ca34:	28800115 	stw	r2,4(r5)
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
2000ca38:	29000015 	stw	r4,0(r5)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
    return (OS_ERR_NONE);
2000ca3c:	0005883a 	mov	r2,zero
2000ca40:	f800283a 	ret
        if (prio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
        return (OS_ERR_PDATA_NULL);
2000ca44:	00800244 	movi	r2,9
2000ca48:	f800283a 	ret
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
        if (prio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
2000ca4c:	283ffd26 	beq	r5,zero,2000ca44 <OSTaskStkChk+0xd0>
        return (OS_ERR_PDATA_NULL);
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
2000ca50:	28000015 	stw	zero,0(r5)
    p_stk_data->OSUsed = 0;
2000ca54:	28000115 	stw	zero,4(r5)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ca58:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000ca5c:	00bfff84 	movi	r2,-2
2000ca60:	1884703a 	and	r2,r3,r2
2000ca64:	1001703a 	wrctl	status,r2
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
        prio = OSTCBCur->OSTCBPrio;
2000ca68:	00800034 	movhi	r2,0
2000ca6c:	10818204 	addi	r2,r2,1544
2000ca70:	10800017 	ldw	r2,0(r2)
2000ca74:	10800c83 	ldbu	r2,50(r2)
2000ca78:	003fcd06 	br	2000c9b0 <OSTaskStkChk+0x3c>

2000ca7c <OSTaskSuspend>:
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
2000ca7c:	21403fcc 	andi	r5,r4,255
2000ca80:	00c00504 	movi	r3,20
2000ca84:	28c04326 	beq	r5,r3,2000cb94 <OSTaskSuspend+0x118>
2000ca88:	2005883a 	mov	r2,r4
        return (OS_ERR_TASK_SUSPEND_IDLE);
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
2000ca8c:	213ffb04 	addi	r4,r4,-20
2000ca90:	21003fcc 	andi	r4,r4,255
2000ca94:	00c03a84 	movi	r3,234
2000ca98:	1900402e 	bgeu	r3,r4,2000cb9c <OSTaskSuspend+0x120>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ca9c:	000f303a 	rdctl	r7,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000caa0:	00ffff84 	movi	r3,-2
2000caa4:	38c6703a 	and	r3,r7,r3
2000caa8:	1801703a 	wrctl	status,r3
2000caac:	00c00034 	movhi	r3,0
            return (OS_ERR_PRIO_INVALID);
        }
    }
#endif
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
2000cab0:	01003fc4 	movi	r4,255
2000cab4:	18c18204 	addi	r3,r3,1544
2000cab8:	2900041e 	bne	r5,r4,2000cacc <OSTaskSuspend+0x50>
        prio = OSTCBCur->OSTCBPrio;
2000cabc:	18800017 	ldw	r2,0(r3)
        self = OS_TRUE;
2000cac0:	00c00044 	movi	r3,1
        }
    }
#endif
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
        prio = OSTCBCur->OSTCBPrio;
2000cac4:	10800c83 	ldbu	r2,50(r2)
2000cac8:	00000306 	br	2000cad8 <OSTaskSuspend+0x5c>
        self = OS_TRUE;
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
2000cacc:	18c00017 	ldw	r3,0(r3)
2000cad0:	18c00c83 	ldbu	r3,50(r3)
2000cad4:	28c7003a 	cmpeq	r3,r5,r3
        self = OS_TRUE;
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
    }
    ptcb = OSTCBPrioTbl[prio];
2000cad8:	10803fcc 	andi	r2,r2,255
2000cadc:	1085883a 	add	r2,r2,r2
2000cae0:	01000034 	movhi	r4,0
2000cae4:	1085883a 	add	r2,r2,r2
2000cae8:	211e0004 	addi	r4,r4,30720
2000caec:	2085883a 	add	r2,r4,r2
2000caf0:	10800017 	ldw	r2,0(r2)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
2000caf4:	1000031e 	bne	r2,zero,2000cb04 <OSTaskSuspend+0x88>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000caf8:	3801703a 	wrctl	status,r7
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
2000cafc:	00801204 	movi	r2,72
2000cb00:	f800283a 	ret
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
2000cb04:	01000044 	movi	r4,1
2000cb08:	1100031e 	bne	r2,r4,2000cb18 <OSTaskSuspend+0x9c>
2000cb0c:	3801703a 	wrctl	status,r7
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
2000cb10:	008010c4 	movi	r2,67
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
        OS_Sched();                                             /* Find new highest priority task      */
    }
    return (OS_ERR_NONE);
}
2000cb14:	f800283a 	ret
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
    }
    y            = ptcb->OSTCBY;
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
2000cb18:	11000d03 	ldbu	r4,52(r2)
2000cb1c:	01400034 	movhi	r5,0
2000cb20:	29417f44 	addi	r5,r5,1533
2000cb24:	290b883a 	add	r5,r5,r4
2000cb28:	11000d43 	ldbu	r4,53(r2)
2000cb2c:	010c303a 	nor	r6,zero,r4
2000cb30:	29000003 	ldbu	r4,0(r5)
2000cb34:	3108703a 	and	r4,r6,r4
2000cb38:	29000005 	stb	r4,0(r5)
    if (OSRdyTbl[y] == 0) {
2000cb3c:	21003fcc 	andi	r4,r4,255
2000cb40:	2000071e 	bne	r4,zero,2000cb60 <OSTaskSuspend+0xe4>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
2000cb44:	11000d83 	ldbu	r4,54(r2)
2000cb48:	01800034 	movhi	r6,0
2000cb4c:	31817f04 	addi	r6,r6,1532
2000cb50:	010a303a 	nor	r5,zero,r4
2000cb54:	31000003 	ldbu	r4,0(r6)
2000cb58:	2908703a 	and	r4,r5,r4
2000cb5c:	31000005 	stb	r4,0(r6)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
2000cb60:	11000c03 	ldbu	r4,48(r2)
2000cb64:	21000214 	ori	r4,r4,8
2000cb68:	11000c05 	stb	r4,48(r2)
2000cb6c:	3801703a 	wrctl	status,r7
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
2000cb70:	18c03fcc 	andi	r3,r3,255
2000cb74:	18000b26 	beq	r3,zero,2000cba4 <OSTaskSuspend+0x128>
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
2000cb78:	deffff04 	addi	sp,sp,-4
2000cb7c:	dfc00015 	stw	ra,0(sp)
        OSRdyGrp &= ~ptcb->OSTCBBitY;
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
        OS_Sched();                                             /* Find new highest priority task      */
2000cb80:	00098400 	call	20009840 <OS_Sched>
    }
    return (OS_ERR_NONE);
2000cb84:	0005883a 	mov	r2,zero
}
2000cb88:	dfc00017 	ldw	ra,0(sp)
2000cb8c:	dec00104 	addi	sp,sp,4
2000cb90:	f800283a 	ret



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
        return (OS_ERR_TASK_SUSPEND_IDLE);
2000cb94:	008011c4 	movi	r2,71
2000cb98:	f800283a 	ret
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
        if (prio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
2000cb9c:	00800a84 	movi	r2,42
2000cba0:	f800283a 	ret
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
        OS_Sched();                                             /* Find new highest priority task      */
    }
    return (OS_ERR_NONE);
2000cba4:	0005883a 	mov	r2,zero
2000cba8:	f800283a 	ret

2000cbac <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
2000cbac:	2007883a 	mov	r3,r4
2000cbb0:	defffe04 	addi	sp,sp,-8
2000cbb4:	2809883a 	mov	r4,r5
2000cbb8:	1805883a 	mov	r2,r3
2000cbbc:	dfc00115 	stw	ra,4(sp)
2000cbc0:	dc000015 	stw	r16,0(sp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
2000cbc4:	18c03fcc 	andi	r3,r3,255
2000cbc8:	01400504 	movi	r5,20
2000cbcc:	28c0042e 	bgeu	r5,r3,2000cbe0 <OSTaskQuery+0x34>
        if (prio != OS_PRIO_SELF) {
2000cbd0:	00803fc4 	movi	r2,255
2000cbd4:	18801e26 	beq	r3,r2,2000cc50 <OSTaskQuery+0xa4>
            return (OS_ERR_PRIO_INVALID);
2000cbd8:	00800a84 	movi	r2,42
2000cbdc:	00002606 	br	2000cc78 <OSTaskQuery+0xcc>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
2000cbe0:	20001926 	beq	r4,zero,2000cc48 <OSTaskQuery+0x9c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000cbe4:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000cbe8:	00ffff84 	movi	r3,-2
2000cbec:	80c6703a 	and	r3,r16,r3
2000cbf0:	1801703a 	wrctl	status,r3
#endif
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
        prio = OSTCBCur->OSTCBPrio;
    }
    ptcb = OSTCBPrioTbl[prio];
2000cbf4:	10803fcc 	andi	r2,r2,255
2000cbf8:	1085883a 	add	r2,r2,r2
2000cbfc:	00c00034 	movhi	r3,0
2000cc00:	1085883a 	add	r2,r2,r2
2000cc04:	18de0004 	addi	r3,r3,30720
2000cc08:	1885883a 	add	r2,r3,r2
2000cc0c:	11400017 	ldw	r5,0(r2)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
2000cc10:	2800031e 	bne	r5,zero,2000cc20 <OSTaskQuery+0x74>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000cc14:	8001703a 	wrctl	status,r16
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
2000cc18:	00800a44 	movi	r2,41
2000cc1c:	00001606 	br	2000cc78 <OSTaskQuery+0xcc>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
2000cc20:	00800044 	movi	r2,1
2000cc24:	2880031e 	bne	r5,r2,2000cc34 <OSTaskQuery+0x88>
2000cc28:	8001703a 	wrctl	status,r16
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
2000cc2c:	008010c4 	movi	r2,67
2000cc30:	00001106 	br	2000cc78 <OSTaskQuery+0xcc>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
2000cc34:	01801b04 	movi	r6,108
2000cc38:	00098180 	call	20009818 <OS_MemCopy>
2000cc3c:	8001703a 	wrctl	status,r16
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
2000cc40:	0005883a 	mov	r2,zero
2000cc44:	00000c06 	br	2000cc78 <OSTaskQuery+0xcc>
        if (prio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
        return (OS_ERR_PDATA_NULL);
2000cc48:	00800244 	movi	r2,9
2000cc4c:	00000a06 	br	2000cc78 <OSTaskQuery+0xcc>
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
        if (prio != OS_PRIO_SELF) {
            return (OS_ERR_PRIO_INVALID);
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
2000cc50:	203ffd26 	beq	r4,zero,2000cc48 <OSTaskQuery+0x9c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000cc54:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000cc58:	00bfff84 	movi	r2,-2
2000cc5c:	8084703a 	and	r2,r16,r2
2000cc60:	1001703a 	wrctl	status,r2
        return (OS_ERR_PDATA_NULL);
    }
#endif
    OS_ENTER_CRITICAL();
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
        prio = OSTCBCur->OSTCBPrio;
2000cc64:	00800034 	movhi	r2,0
2000cc68:	10818204 	addi	r2,r2,1544
2000cc6c:	10800017 	ldw	r2,0(r2)
2000cc70:	10800c83 	ldbu	r2,50(r2)
2000cc74:	003fdf06 	br	2000cbf4 <OSTaskQuery+0x48>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
}
2000cc78:	dfc00117 	ldw	ra,4(sp)
2000cc7c:	dc000017 	ldw	r16,0(sp)
2000cc80:	dec00204 	addi	sp,sp,8
2000cc84:	f800283a 	ret

2000cc88 <OS_TaskStkClr>:
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
2000cc88:	318000cc 	andi	r6,r6,3
2000cc8c:	008000c4 	movi	r2,3
2000cc90:	3080051e 	bne	r6,r2,2000cca8 <OS_TaskStkClr+0x20>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
2000cc94:	28000426 	beq	r5,zero,2000cca8 <OS_TaskStkClr+0x20>
                size--;
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
2000cc98:	20000015 	stw	zero,0(r4)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
                size--;
2000cc9c:	297fffc4 	addi	r5,r5,-1
2000cca0:	21000104 	addi	r4,r4,4
2000cca4:	003ffb06 	br	2000cc94 <OS_TaskStkClr+0xc>
2000cca8:	f800283a 	ret

2000ccac <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
2000ccac:	defff204 	addi	sp,sp,-56
2000ccb0:	dc800615 	stw	r18,24(sp)
2000ccb4:	dc400515 	stw	r17,20(sp)
2000ccb8:	dfc00d15 	stw	ra,52(sp)
2000ccbc:	df000c15 	stw	fp,48(sp)
2000ccc0:	ddc00b15 	stw	r23,44(sp)
2000ccc4:	dd800a15 	stw	r22,40(sp)
2000ccc8:	dd400915 	stw	r21,36(sp)
2000cccc:	dd000815 	stw	r20,32(sp)
2000ccd0:	dcc00715 	stw	r19,28(sp)
2000ccd4:	dc000415 	stw	r16,16(sp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
2000ccd8:	3c803fcc 	andi	r18,r7,255
2000ccdc:	00800504 	movi	r2,20
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
2000cce0:	da400e17 	ldw	r9,56(sp)
2000cce4:	dc401217 	ldw	r17,72(sp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
2000cce8:	14804136 	bltu	r2,r18,2000cdf0 <OSTaskCreateExt+0x144>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ccec:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000ccf0:	057fff84 	movi	r21,-2
2000ccf4:	1d44703a 	and	r2,r3,r21
2000ccf8:	1001703a 	wrctl	status,r2
        return (OS_ERR_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
2000ccfc:	00800034 	movhi	r2,0
2000cd00:	10818104 	addi	r2,r2,1540
2000cd04:	14c00003 	ldbu	r19,0(r2)
2000cd08:	98803fcc 	andi	r2,r19,255
2000cd0c:	10000326 	beq	r2,zero,2000cd1c <OSTaskCreateExt+0x70>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000cd10:	1801703a 	wrctl	status,r3
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
2000cd14:	04c00f04 	movi	r19,60
2000cd18:	00003606 	br	2000cdf4 <OSTaskCreateExt+0x148>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
2000cd1c:	94a1883a 	add	r16,r18,r18
2000cd20:	00800034 	movhi	r2,0
2000cd24:	109e0004 	addi	r2,r2,30720
2000cd28:	8421883a 	add	r16,r16,r16
2000cd2c:	1421883a 	add	r16,r2,r16
2000cd30:	80800017 	ldw	r2,0(r16)
2000cd34:	10002b1e 	bne	r2,zero,2000cde4 <OSTaskCreateExt+0x138>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
2000cd38:	05000044 	movi	r20,1
2000cd3c:	302d883a 	mov	r22,r6
2000cd40:	282f883a 	mov	r23,r5
2000cd44:	2039883a 	mov	fp,r4
2000cd48:	85000015 	stw	r20,0(r16)
2000cd4c:	1801703a 	wrctl	status,r3
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
2000cd50:	d9000f17 	ldw	r4,60(sp)
2000cd54:	d9401017 	ldw	r5,64(sp)
2000cd58:	8c7fffcc 	andi	r17,r17,65535
2000cd5c:	880d883a 	mov	r6,r17
2000cd60:	da400315 	stw	r9,12(sp)
2000cd64:	000cc880 	call	2000cc88 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
2000cd68:	e009883a 	mov	r4,fp
2000cd6c:	b80b883a 	mov	r5,r23
2000cd70:	b00d883a 	mov	r6,r22
2000cd74:	880f883a 	mov	r7,r17
2000cd78:	000e1b00 	call	2000e1b0 <OSTaskStkInit>
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
2000cd7c:	d8c01017 	ldw	r3,64(sp)
2000cd80:	da400317 	ldw	r9,12(sp)
2000cd84:	d9800f17 	ldw	r6,60(sp)
2000cd88:	d8c00015 	stw	r3,0(sp)
2000cd8c:	d8c01117 	ldw	r3,68(sp)
2000cd90:	dc400215 	stw	r17,8(sp)
2000cd94:	9009883a 	mov	r4,r18
2000cd98:	d8c00115 	stw	r3,4(sp)
2000cd9c:	100b883a 	mov	r5,r2
2000cda0:	49ffffcc 	andi	r7,r9,65535
2000cda4:	0009f380 	call	20009f38 <OS_TCBInit>
        if (err == OS_ERR_NONE) {
2000cda8:	10c03fcc 	andi	r3,r2,255
2000cdac:	1800061e 	bne	r3,zero,2000cdc8 <OSTaskCreateExt+0x11c>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
2000cdb0:	00800034 	movhi	r2,0
2000cdb4:	10817344 	addi	r2,r2,1485
2000cdb8:	10800003 	ldbu	r2,0(r2)
2000cdbc:	15000d1e 	bne	r2,r20,2000cdf4 <OSTaskCreateExt+0x148>
                OS_Sched();
2000cdc0:	00098400 	call	20009840 <OS_Sched>
2000cdc4:	00000b06 	br	2000cdf4 <OSTaskCreateExt+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000cdc8:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000cdcc:	2546703a 	and	r3,r4,r21
2000cdd0:	1801703a 	wrctl	status,r3
            }
        } else {
            OS_ENTER_CRITICAL();
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
2000cdd4:	80000015 	stw	zero,0(r16)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000cdd8:	2001703a 	wrctl	status,r4
2000cddc:	1027883a 	mov	r19,r2
2000cde0:	00000406 	br	2000cdf4 <OSTaskCreateExt+0x148>
2000cde4:	1801703a 	wrctl	status,r3
            OS_EXIT_CRITICAL();
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
2000cde8:	04c00a04 	movi	r19,40
2000cdec:	00000106 	br	2000cdf4 <OSTaskCreateExt+0x148>



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_ERR_PRIO_INVALID);
2000cdf0:	04c00a84 	movi	r19,42
        }
        return (err);
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
}
2000cdf4:	9805883a 	mov	r2,r19
2000cdf8:	dfc00d17 	ldw	ra,52(sp)
2000cdfc:	df000c17 	ldw	fp,48(sp)
2000ce00:	ddc00b17 	ldw	r23,44(sp)
2000ce04:	dd800a17 	ldw	r22,40(sp)
2000ce08:	dd400917 	ldw	r21,36(sp)
2000ce0c:	dd000817 	ldw	r20,32(sp)
2000ce10:	dcc00717 	ldw	r19,28(sp)
2000ce14:	dc800617 	ldw	r18,24(sp)
2000ce18:	dc400517 	ldw	r17,20(sp)
2000ce1c:	dc000417 	ldw	r16,16(sp)
2000ce20:	dec00e04 	addi	sp,sp,56
2000ce24:	f800283a 	ret

2000ce28 <OSTimeDly>:
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
2000ce28:	00800034 	movhi	r2,0
2000ce2c:	10818104 	addi	r2,r2,1540
2000ce30:	10800003 	ldbu	r2,0(r2)
2000ce34:	10001e1e 	bne	r2,zero,2000ceb0 <OSTimeDly+0x88>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
2000ce38:	20bfffcc 	andi	r2,r4,65535
2000ce3c:	10001c26 	beq	r2,zero,2000ceb0 <OSTimeDly+0x88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000ce40:	000f303a 	rdctl	r7,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000ce44:	00bfff84 	movi	r2,-2
2000ce48:	3884703a 	and	r2,r7,r2
2000ce4c:	1001703a 	wrctl	status,r2
        OS_ENTER_CRITICAL();
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
2000ce50:	00800034 	movhi	r2,0
2000ce54:	10818204 	addi	r2,r2,1544
2000ce58:	10c00017 	ldw	r3,0(r2)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
2000ce5c:	01400034 	movhi	r5,0
2000ce60:	29417f44 	addi	r5,r5,1533
2000ce64:	18800d03 	ldbu	r2,52(r3)
2000ce68:	288b883a 	add	r5,r5,r2
2000ce6c:	18800d43 	ldbu	r2,53(r3)
2000ce70:	008c303a 	nor	r6,zero,r2
2000ce74:	28800003 	ldbu	r2,0(r5)
2000ce78:	3084703a 	and	r2,r6,r2
2000ce7c:	28800005 	stb	r2,0(r5)
        if (OSRdyTbl[y] == 0) {
2000ce80:	10803fcc 	andi	r2,r2,255
2000ce84:	1000071e 	bne	r2,zero,2000cea4 <OSTimeDly+0x7c>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
2000ce88:	18800d83 	ldbu	r2,54(r3)
2000ce8c:	01800034 	movhi	r6,0
2000ce90:	31817f04 	addi	r6,r6,1532
2000ce94:	008a303a 	nor	r5,zero,r2
2000ce98:	30800003 	ldbu	r2,0(r6)
2000ce9c:	2884703a 	and	r2,r5,r2
2000cea0:	30800005 	stb	r2,0(r6)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
2000cea4:	19000b8d 	sth	r4,46(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000cea8:	3801703a 	wrctl	status,r7
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
2000ceac:	00098401 	jmpi	20009840 <OS_Sched>
2000ceb0:	f800283a 	ret

2000ceb4 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
2000ceb4:	defffd04 	addi	sp,sp,-12
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
2000ceb8:	00800034 	movhi	r2,0
2000cebc:	10818104 	addi	r2,r2,1540
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
2000cec0:	dfc00215 	stw	ra,8(sp)
2000cec4:	dc400115 	stw	r17,4(sp)
2000cec8:	dc000015 	stw	r16,0(sp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
2000cecc:	14400003 	ldbu	r17,0(r2)
2000ced0:	88803fcc 	andi	r2,r17,255
2000ced4:	1000261e 	bne	r2,zero,2000cf70 <OSTimeDlyHMSM+0xbc>
        return (OS_ERR_TIME_DLY_ISR);
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
2000ced8:	20c03fcc 	andi	r3,r4,255
2000cedc:	29403fcc 	andi	r5,r5,255
2000cee0:	1800061e 	bne	r3,zero,2000cefc <OSTimeDlyHMSM+0x48>
        if (minutes == 0) {
2000cee4:	2800051e 	bne	r5,zero,2000cefc <OSTimeDlyHMSM+0x48>
            if (seconds == 0) {
2000cee8:	30803fcc 	andi	r2,r6,255
2000ceec:	1000051e 	bne	r2,zero,2000cf04 <OSTimeDlyHMSM+0x50>
                if (ms == 0) {
2000cef0:	38bfffcc 	andi	r2,r7,65535
2000cef4:	10002026 	beq	r2,zero,2000cf78 <OSTimeDlyHMSM+0xc4>
2000cef8:	00000506 	br	2000cf10 <OSTimeDlyHMSM+0x5c>
                    return (OS_ERR_TIME_ZERO_DLY);
                }
            }
        }
    }
    if (minutes > 59) {
2000cefc:	00800ec4 	movi	r2,59
2000cf00:	11401f36 	bltu	r2,r5,2000cf80 <OSTimeDlyHMSM+0xcc>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
    }
    if (seconds > 59) {
2000cf04:	30803fcc 	andi	r2,r6,255
2000cf08:	01000ec4 	movi	r4,59
2000cf0c:	20801e36 	bltu	r4,r2,2000cf88 <OSTimeDlyHMSM+0xd4>
        return (OS_ERR_TIME_INVALID_SECONDS);
    }
    if (ms > 999) {
2000cf10:	393fffcc 	andi	r4,r7,65535
2000cf14:	0080f9c4 	movi	r2,999
2000cf18:	11001d36 	bltu	r2,r4,2000cf90 <OSTimeDlyHMSM+0xdc>
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
2000cf1c:	2c000f24 	muli	r16,r5,60
2000cf20:	18c38424 	muli	r3,r3,3600
2000cf24:	31803fcc 	andi	r6,r6,255
2000cf28:	81a1883a 	add	r16,r16,r6
2000cf2c:	80e1883a 	add	r16,r16,r3
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
2000cf30:	2100fa24 	muli	r4,r4,1000
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
2000cf34:	8400fa24 	muli	r16,r16,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
2000cf38:	0140fa04 	movi	r5,1000
2000cf3c:	0008c140 	call	20008c14 <__udivsi3>
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
2000cf40:	8089883a 	add	r4,r16,r2
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
2000cf44:	2020d43a 	srli	r16,r4,16
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
2000cf48:	213fffcc 	andi	r4,r4,65535
2000cf4c:	000ce280 	call	2000ce28 <OSTimeDly>
    while (loops > 0) {
2000cf50:	80bfffcc 	andi	r2,r16,65535
2000cf54:	10000f26 	beq	r2,zero,2000cf94 <OSTimeDlyHMSM+0xe0>
        OSTimeDly((INT16U)32768u);
2000cf58:	01200014 	movui	r4,32768
2000cf5c:	000ce280 	call	2000ce28 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
2000cf60:	01200014 	movui	r4,32768
2000cf64:	000ce280 	call	2000ce28 <OSTimeDly>
        loops--;
2000cf68:	843fffc4 	addi	r16,r16,-1
2000cf6c:	003ff806 	br	2000cf50 <OSTimeDlyHMSM+0x9c>
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return (OS_ERR_TIME_DLY_ISR);
2000cf70:	04401544 	movi	r17,85
2000cf74:	00000706 	br	2000cf94 <OSTimeDlyHMSM+0xe0>
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
        if (minutes == 0) {
            if (seconds == 0) {
                if (ms == 0) {
                    return (OS_ERR_TIME_ZERO_DLY);
2000cf78:	04401504 	movi	r17,84
2000cf7c:	00000506 	br	2000cf94 <OSTimeDlyHMSM+0xe0>
                }
            }
        }
    }
    if (minutes > 59) {
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
2000cf80:	04401444 	movi	r17,81
2000cf84:	00000306 	br	2000cf94 <OSTimeDlyHMSM+0xe0>
    }
    if (seconds > 59) {
        return (OS_ERR_TIME_INVALID_SECONDS);
2000cf88:	04401484 	movi	r17,82
2000cf8c:	00000106 	br	2000cf94 <OSTimeDlyHMSM+0xe0>
    }
    if (ms > 999) {
        return (OS_ERR_TIME_INVALID_MS);
2000cf90:	044014c4 	movi	r17,83
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
}
2000cf94:	8805883a 	mov	r2,r17
2000cf98:	dfc00217 	ldw	ra,8(sp)
2000cf9c:	dc400117 	ldw	r17,4(sp)
2000cfa0:	dc000017 	ldw	r16,0(sp)
2000cfa4:	dec00304 	addi	sp,sp,12
2000cfa8:	f800283a 	ret

2000cfac <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
2000cfac:	defffe04 	addi	sp,sp,-8
2000cfb0:	dfc00115 	stw	ra,4(sp)
2000cfb4:	dc000015 	stw	r16,0(sp)
    OS_CPU_SR  cpu_sr = 0;
#endif



    if (prio >= OS_LOWEST_PRIO) {
2000cfb8:	21003fcc 	andi	r4,r4,255
2000cfbc:	008004c4 	movi	r2,19
2000cfc0:	11003636 	bltu	r2,r4,2000d09c <OSTimeDlyResume+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000cfc4:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000cfc8:	00ffff84 	movi	r3,-2
2000cfcc:	10c6703a 	and	r3,r2,r3
2000cfd0:	1801703a 	wrctl	status,r3
        return (OS_ERR_PRIO_INVALID);
    }
    OS_ENTER_CRITICAL();
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
2000cfd4:	2109883a 	add	r4,r4,r4
2000cfd8:	00c00034 	movhi	r3,0
2000cfdc:	18de0004 	addi	r3,r3,30720
2000cfe0:	2109883a 	add	r4,r4,r4
2000cfe4:	1909883a 	add	r4,r3,r4
2000cfe8:	20c00017 	ldw	r3,0(r4)
    if (ptcb == (OS_TCB *)0) {
2000cfec:	18000226 	beq	r3,zero,2000cff8 <OSTimeDlyResume+0x4c>
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
    }
    if (ptcb == OS_TCB_RESERVED) {
2000cff0:	01400044 	movi	r5,1
2000cff4:	1940031e 	bne	r3,r5,2000d004 <OSTimeDlyResume+0x58>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000cff8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
2000cffc:	040010c4 	movi	r16,67
2000d000:	00002706 	br	2000d0a0 <OSTimeDlyResume+0xf4>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
2000d004:	19000b8b 	ldhu	r4,46(r3)
2000d008:	2000031e 	bne	r4,zero,2000d018 <OSTimeDlyResume+0x6c>
2000d00c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
2000d010:	04001404 	movi	r16,80
2000d014:	00002206 	br	2000d0a0 <OSTimeDlyResume+0xf4>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
2000d018:	19000c03 	ldbu	r4,48(r3)
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
2000d01c:	18000b8d 	sth	zero,46(r3)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
2000d020:	21800dcc 	andi	r6,r4,55
2000d024:	30000426 	beq	r6,zero,2000d038 <OSTimeDlyResume+0x8c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
2000d028:	2100320c 	andi	r4,r4,200
2000d02c:	19000c05 	stb	r4,48(r3)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
2000d030:	19400c45 	stb	r5,49(r3)
2000d034:	00000106 	br	2000d03c <OSTimeDlyResume+0x90>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
2000d038:	18000c45 	stb	zero,49(r3)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
2000d03c:	19000c03 	ldbu	r4,48(r3)
2000d040:	2100020c 	andi	r4,r4,8
2000d044:	2021883a 	mov	r16,r4
2000d048:	2000111e 	bne	r4,zero,2000d090 <OSTimeDlyResume+0xe4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
2000d04c:	01400034 	movhi	r5,0
2000d050:	29417f04 	addi	r5,r5,1532
2000d054:	29000003 	ldbu	r4,0(r5)
2000d058:	19800d83 	ldbu	r6,54(r3)
2000d05c:	3108b03a 	or	r4,r6,r4
2000d060:	29000005 	stb	r4,0(r5)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
2000d064:	19000d03 	ldbu	r4,52(r3)
2000d068:	01400034 	movhi	r5,0
2000d06c:	29417f44 	addi	r5,r5,1533
2000d070:	2909883a 	add	r4,r5,r4
2000d074:	21400003 	ldbu	r5,0(r4)
2000d078:	18c00d43 	ldbu	r3,53(r3)
2000d07c:	28c6b03a 	or	r3,r5,r3
2000d080:	20c00005 	stb	r3,0(r4)
2000d084:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
2000d088:	00098400 	call	20009840 <OS_Sched>
2000d08c:	00000406 	br	2000d0a0 <OSTimeDlyResume+0xf4>
2000d090:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
2000d094:	0021883a 	mov	r16,zero
2000d098:	00000106 	br	2000d0a0 <OSTimeDlyResume+0xf4>
#endif



    if (prio >= OS_LOWEST_PRIO) {
        return (OS_ERR_PRIO_INVALID);
2000d09c:	04000a84 	movi	r16,42
        OS_Sched();                                            /* See if this is new highest priority  */
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
}
2000d0a0:	8005883a 	mov	r2,r16
2000d0a4:	dfc00117 	ldw	ra,4(sp)
2000d0a8:	dc000017 	ldw	r16,0(sp)
2000d0ac:	dec00204 	addi	sp,sp,8
2000d0b0:	f800283a 	ret

2000d0b4 <OSTimeGet>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000d0b4:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000d0b8:	00bfff84 	movi	r2,-2
2000d0bc:	1884703a 	and	r2,r3,r2
2000d0c0:	1001703a 	wrctl	status,r2
#endif



    OS_ENTER_CRITICAL();
    ticks = OSTime;
2000d0c4:	00800034 	movhi	r2,0
2000d0c8:	10818304 	addi	r2,r2,1548
2000d0cc:	10800017 	ldw	r2,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000d0d0:	1801703a 	wrctl	status,r3
    OS_EXIT_CRITICAL();
    return (ticks);
}
2000d0d4:	f800283a 	ret

2000d0d8 <OSTimeSet>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000d0d8:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000d0dc:	00bfff84 	movi	r2,-2
2000d0e0:	1884703a 	and	r2,r3,r2
2000d0e4:	1001703a 	wrctl	status,r2
#endif



    OS_ENTER_CRITICAL();
    OSTime = ticks;
2000d0e8:	00800034 	movhi	r2,0
2000d0ec:	10818304 	addi	r2,r2,1548
2000d0f0:	11000015 	stw	r4,0(r2)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000d0f4:	1801703a 	wrctl	status,r3
2000d0f8:	f800283a 	ret

2000d0fc <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
2000d0fc:	deffff04 	addi	sp,sp,-4
2000d100:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU, cpu);
2000d104:	000e0d80 	call	2000e0d8 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
2000d108:	00800044 	movi	r2,1
2000d10c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
2000d110:	dfc00017 	ldw	ra,0(sp)
2000d114:	dec00104 	addi	sp,sp,4
2000d118:	f800283a 	ret

2000d11c <alt_sys_init>:
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
2000d11c:	01080074 	movhi	r4,8193
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
2000d120:	defffe04 	addi	sp,sp,-8
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
2000d124:	01c0fa04 	movi	r7,1000
2000d128:	01800044 	movi	r6,1
2000d12c:	21042804 	addi	r4,r4,4256
2000d130:	000b883a 	mov	r5,zero
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
2000d134:	dfc00115 	stw	ra,4(sp)
2000d138:	dc000015 	stw	r16,0(sp)
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
2000d13c:	000d8640 	call	2000d864 <alt_avalon_timer_sc_init>

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
2000d140:	04000034 	movhi	r16,0
2000d144:	84016304 	addi	r16,r16,1420
2000d148:	01000034 	movhi	r4,0
2000d14c:	800b883a 	mov	r5,r16
2000d150:	2100ca04 	addi	r4,r4,808
2000d154:	000dacc0 	call	2000dacc <alt_dev_llist_insert>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_0, sgdma_0);
2000d158:	01000034 	movhi	r4,0
2000d15c:	2100be04 	addi	r4,r4,760
2000d160:	000b883a 	mov	r5,zero
2000d164:	01800084 	movi	r6,2
2000d168:	000d7a40 	call	2000d7a4 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_1, sgdma_1);
2000d16c:	01000034 	movhi	r4,0
2000d170:	2100b204 	addi	r4,r4,712
2000d174:	000b883a 	mov	r5,zero
2000d178:	018000c4 	movi	r6,3
2000d17c:	000d7a40 	call	2000d7a4 <alt_avalon_sgdma_init>
2000d180:	01000034 	movhi	r4,0
2000d184:	2100a704 	addi	r4,r4,668
2000d188:	800b883a 	mov	r5,r16
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
    ALTERA_AVALON_UART_INIT ( UART, uart);
}
2000d18c:	dfc00117 	ldw	ra,4(sp)
2000d190:	dc000017 	ldw	r16,0(sp)
2000d194:	dec00204 	addi	sp,sp,8
2000d198:	000dacc1 	jmpi	2000dacc <alt_dev_llist_insert>

2000d19c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
2000d19c:	2005883a 	mov	r2,r4
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
2000d1a0:	21000017 	ldw	r4,0(r4)
2000d1a4:	11c00217 	ldw	r7,8(r2)
2000d1a8:	21000a04 	addi	r4,r4,40
2000d1ac:	000d1c41 	jmpi	2000d1c4 <altera_avalon_jtag_uart_read>

2000d1b0 <altera_avalon_jtag_uart_write_fd>:
      fd->fd_flags);
}

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
2000d1b0:	2005883a 	mov	r2,r4
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
2000d1b4:	21000017 	ldw	r4,0(r4)
2000d1b8:	11c00217 	ldw	r7,8(r2)
2000d1bc:	21000a04 	addi	r4,r4,40
2000d1c0:	000d2201 	jmpi	2000d220 <altera_avalon_jtag_uart_write>

2000d1c4 <altera_avalon_jtag_uart_read>:

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char* buffer, int space, int flags)
{
  unsigned int base = sp->base;
2000d1c4:	21000017 	ldw	r4,0(r4)

  char * ptr = buffer;
  char * end = buffer + space;
2000d1c8:	298d883a 	add	r6,r5,r6

  while (ptr < end)
2000d1cc:	2805883a 	mov	r2,r5

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
    else if(flags & O_NONBLOCK)
2000d1d0:	3a10000c 	andi	r8,r7,16384
  unsigned int base = sp->base;

  char * ptr = buffer;
  char * end = buffer + space;

  while (ptr < end)
2000d1d4:	11800b2e 	bgeu	r2,r6,2000d204 <altera_avalon_jtag_uart_read+0x40>
  {
    unsigned int data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
2000d1d8:	20c00037 	ldwio	r3,0(r4)

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
2000d1dc:	1a60000c 	andi	r9,r3,32768
2000d1e0:	48000326 	beq	r9,zero,2000d1f0 <altera_avalon_jtag_uart_read+0x2c>
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
2000d1e4:	10c00005 	stb	r3,0(r2)
2000d1e8:	10800044 	addi	r2,r2,1
2000d1ec:	003ff906 	br	2000d1d4 <altera_avalon_jtag_uart_read+0x10>
    else if (ptr != buffer)
2000d1f0:	11400226 	beq	r2,r5,2000d1fc <altera_avalon_jtag_uart_read+0x38>
      break;   
    
  }

  if (ptr != buffer)
    return ptr - buffer;
2000d1f4:	1145c83a 	sub	r2,r2,r5
2000d1f8:	f800283a 	ret

    if (data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK)
      *ptr++ = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
    else if (ptr != buffer)
      break;
    else if(flags & O_NONBLOCK)
2000d1fc:	403ff526 	beq	r8,zero,2000d1d4 <altera_avalon_jtag_uart_read+0x10>
2000d200:	00000106 	br	2000d208 <altera_avalon_jtag_uart_read+0x44>
      break;   
    
  }

  if (ptr != buffer)
2000d204:	117ffb1e 	bne	r2,r5,2000d1f4 <altera_avalon_jtag_uart_read+0x30>
    return ptr - buffer;
  else if (flags & O_NONBLOCK)
2000d208:	39d0000c 	andi	r7,r7,16384
2000d20c:	3800021e 	bne	r7,zero,2000d218 <altera_avalon_jtag_uart_read+0x54>
    return -EWOULDBLOCK;
  else
    return -EIO;
2000d210:	00bffec4 	movi	r2,-5
2000d214:	f800283a 	ret
  }

  if (ptr != buffer)
    return ptr - buffer;
  else if (flags & O_NONBLOCK)
    return -EWOULDBLOCK;
2000d218:	00bffd44 	movi	r2,-11
  else
    return -EIO;
}
2000d21c:	f800283a 	ret

2000d220 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
2000d220:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
2000d224:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
2000d228:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
2000d22c:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
2000d230:	2980072e 	bgeu	r5,r6,2000d250 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
2000d234:	38c00037 	ldwio	r3,0(r7)
2000d238:	18ffffec 	andhi	r3,r3,65535
2000d23c:	183ffc26 	beq	r3,zero,2000d230 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
2000d240:	28c00007 	ldb	r3,0(r5)
2000d244:	20c00035 	stwio	r3,0(r4)
2000d248:	29400044 	addi	r5,r5,1
2000d24c:	003ff806 	br	2000d230 <altera_avalon_jtag_uart_write+0x10>

  return count;
}
2000d250:	f800283a 	ret

2000d254 <alt_avalon_sgdma_irq>:
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
2000d254:	20800317 	ldw	r2,12(r4)
2000d258:	10800404 	addi	r2,r2,16
2000d25c:	10c00037 	ldwio	r3,0(r2)
2000d260:	18e00034 	orhi	r3,r3,32768
2000d264:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
2000d268:	20800317 	ldw	r2,12(r4)
2000d26c:	10800437 	ldwio	r2,16(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
2000d270:	20c00917 	ldw	r3,36(r4)
2000d274:	18000d26 	beq	r3,zero,2000d2ac <alt_avalon_sgdma_irq+0x58>
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
2000d278:	defffe04 	addi	sp,sp,-8
2000d27c:	dfc00115 	stw	ra,4(sp)
2000d280:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000d284:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000d288:	00bfff84 	movi	r2,-2
2000d28c:	8084703a 	and	r2,r16,r2
2000d290:	1001703a 	wrctl	status,r2
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
    cpu_sr = alt_irq_disable_all();
    (dev->callback)(dev->callback_context);
2000d294:	21000a17 	ldw	r4,40(r4)
2000d298:	183ee83a 	callr	r3
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000d29c:	8001703a 	wrctl	status,r16
    alt_irq_enable_all(cpu_sr);
  }
}
2000d2a0:	dfc00117 	ldw	ra,4(sp)
2000d2a4:	dc000017 	ldw	r16,0(sp)
2000d2a8:	dec00204 	addi	sp,sp,8
2000d2ac:	f800283a 	ret

2000d2b0 <alt_avalon_sgdma_do_async_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
2000d2b0:	20c00317 	ldw	r3,12(r4)
2000d2b4:	18800037 	ldwio	r2,0(r3)
2000d2b8:	1080040c 	andi	r2,r2,16
2000d2bc:	1000191e 	bne	r2,zero,2000d324 <alt_avalon_sgdma_do_async_transfer+0x74>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
2000d2c0:	18c00404 	addi	r3,r3,16
2000d2c4:	19c00037 	ldwio	r7,0(r3)
2000d2c8:	01bff7c4 	movi	r6,-33
2000d2cc:	398c703a 	and	r6,r7,r6
2000d2d0:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
2000d2d4:	20c00317 	ldw	r3,12(r4)
2000d2d8:	01803fc4 	movi	r6,255
2000d2dc:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
2000d2e0:	20c00317 	ldw	r3,12(r4)
2000d2e4:	19400835 	stwio	r5,32(r3)
2000d2e8:	20c00317 	ldw	r3,12(r4)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
2000d2ec:	21400917 	ldw	r5,36(r4)
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
2000d2f0:	18c00404 	addi	r3,r3,16
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
2000d2f4:	28000526 	beq	r5,zero,2000d30c <alt_avalon_sgdma_do_async_transfer+0x5c>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
2000d2f8:	19400037 	ldwio	r5,0(r3)
2000d2fc:	21000b17 	ldw	r4,44(r4)
2000d300:	21001814 	ori	r4,r4,96

    control |= (dev->chain_control                          |
2000d304:	2148b03a 	or	r4,r4,r5
2000d308:	00000406 	br	2000d31c <alt_avalon_sgdma_do_async_transfer+0x6c>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
2000d30c:	19400037 	ldwio	r5,0(r3)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
2000d310:	013ffbc4 	movi	r4,-17
2000d314:	2908703a 	and	r4,r5,r4
2000d318:	21001814 	ori	r4,r4,96

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
2000d31c:	19000035 	stwio	r4,0(r3)
2000d320:	f800283a 	ret
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
2000d324:	00bffc04 	movi	r2,-16
  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
}
2000d328:	f800283a 	ret

2000d32c <alt_avalon_sgdma_do_sync_transfer>:
  alt_sgdma_descriptor *desc)
{
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
2000d32c:	20c00317 	ldw	r3,12(r4)
2000d330:	18800037 	ldwio	r2,0(r3)
2000d334:	1080040c 	andi	r2,r2,16
2000d338:	103ffc1e 	bne	r2,zero,2000d32c <alt_avalon_sgdma_do_sync_transfer>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
2000d33c:	18c00404 	addi	r3,r3,16
2000d340:	19800037 	ldwio	r6,0(r3)
2000d344:	00bff7c4 	movi	r2,-33
2000d348:	308c703a 	and	r6,r6,r2
2000d34c:	19800035 	stwio	r6,0(r3)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
2000d350:	20c00317 	ldw	r3,12(r4)
2000d354:	01803fc4 	movi	r6,255
2000d358:	19800035 	stwio	r6,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
2000d35c:	20c00317 	ldw	r3,12(r4)
2000d360:	19400835 	stwio	r5,32(r3)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
2000d364:	20c00317 	ldw	r3,12(r4)
2000d368:	18c00404 	addi	r3,r3,16
2000d36c:	19400037 	ldwio	r5,0(r3)
2000d370:	29401814 	ori	r5,r5,96
2000d374:	19400035 	stwio	r5,0(r3)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
2000d378:	20c00317 	ldw	r3,12(r4)
2000d37c:	19400037 	ldwio	r5,0(r3)
2000d380:	2940040c 	andi	r5,r5,16
2000d384:	283ffc1e 	bne	r5,zero,2000d378 <alt_avalon_sgdma_do_sync_transfer+0x4c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
2000d388:	18c00404 	addi	r3,r3,16
2000d38c:	19400037 	ldwio	r5,0(r3)
2000d390:	2884703a 	and	r2,r5,r2
2000d394:	18800035 	stwio	r2,0(r3)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
2000d398:	20c00317 	ldw	r3,12(r4)
2000d39c:	18800037 	ldwio	r2,0(r3)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
2000d3a0:	01003fc4 	movi	r4,255
2000d3a4:	19000035 	stwio	r4,0(r3)

  return status;
}
2000d3a8:	f800283a 	ret

2000d3ac <alt_avalon_sgdma_register_callback>:
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
  dev->callback         = callback;
2000d3ac:	21400915 	stw	r5,36(r4)
  dev->callback_context = context;
2000d3b0:	21c00a15 	stw	r7,40(r4)
  dev->chain_control    = chain_control;
2000d3b4:	21800b15 	stw	r6,44(r4)
2000d3b8:	f800283a 	ret

2000d3bc <alt_avalon_sgdma_start>:
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
2000d3bc:	20800317 	ldw	r2,12(r4)
2000d3c0:	10800404 	addi	r2,r2,16
2000d3c4:	10c00037 	ldwio	r3,0(r2)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
2000d3c8:	18c00814 	ori	r3,r3,32
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
2000d3cc:	10c00035 	stwio	r3,0(r2)
2000d3d0:	f800283a 	ret

2000d3d4 <alt_avalon_sgdma_stop>:
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
2000d3d4:	20800317 	ldw	r2,12(r4)
2000d3d8:	10800404 	addi	r2,r2,16
2000d3dc:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
2000d3e0:	00fff7c4 	movi	r3,-33
2000d3e4:	20c6703a 	and	r3,r4,r3
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
2000d3e8:	10c00035 	stwio	r3,0(r2)
2000d3ec:	f800283a 	ret

2000d3f0 <alt_avalon_sgdma_check_descriptor_status>:
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
2000d3f0:	208007a3 	ldbuio	r2,30(r4)
2000d3f4:	10801fcc 	andi	r2,r2,127
2000d3f8:	1000041e 	bne	r2,zero,2000d40c <alt_avalon_sgdma_check_descriptor_status+0x1c>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
  }

  if( IORD_8DIRECT(&desc->control, 0) &
2000d3fc:	208007e3 	ldbuio	r2,31(r4)
2000d400:	1080200c 	andi	r2,r2,128
2000d404:	1000031e 	bne	r2,zero,2000d414 <alt_avalon_sgdma_check_descriptor_status+0x24>
2000d408:	f800283a 	ret
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
2000d40c:	00bffec4 	movi	r2,-5
2000d410:	f800283a 	ret
  }

  if( IORD_8DIRECT(&desc->control, 0) &
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
2000d414:	00bfe244 	movi	r2,-119
  }

    return 0;
}
2000d418:	f800283a 	ret

2000d41c <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
2000d41c:	defffe04 	addi	sp,sp,-8
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
2000d420:	d1602104 	addi	r5,gp,-32636
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
2000d424:	dc000015 	stw	r16,0(sp)
2000d428:	dfc00115 	stw	ra,4(sp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
2000d42c:	000dbd40 	call	2000dbd4 <alt_find_dev>
2000d430:	1021883a 	mov	r16,r2

  if (NULL == dev) {
2000d434:	10000a1e 	bne	r2,zero,2000d460 <alt_avalon_sgdma_open+0x44>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
2000d438:	00800034 	movhi	r2,0
2000d43c:	10816704 	addi	r2,r2,1436
2000d440:	10800017 	ldw	r2,0(r2)
2000d444:	10000226 	beq	r2,zero,2000d450 <alt_avalon_sgdma_open+0x34>
2000d448:	103ee83a 	callr	r2
2000d44c:	00000206 	br	2000d458 <alt_avalon_sgdma_open+0x3c>
2000d450:	00800034 	movhi	r2,0
2000d454:	10816b04 	addi	r2,r2,1452
    ALT_ERRNO = ENODEV;
2000d458:	00c004c4 	movi	r3,19
2000d45c:	10c00015 	stw	r3,0(r2)
  }

  return dev;
}
2000d460:	8005883a 	mov	r2,r16
2000d464:	dfc00117 	ldw	ra,4(sp)
2000d468:	dc000017 	ldw	r16,0(sp)
2000d46c:	dec00204 	addi	sp,sp,8
2000d470:	f800283a 	ret

2000d474 <alt_avalon_sgdma_enable_desc_poll>:
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
2000d474:	20c00317 	ldw	r3,12(r4)
2000d478:	18c00404 	addi	r3,r3,16
2000d47c:	19000037 	ldwio	r4,0(r3)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
2000d480:	00a00434 	movhi	r2,32784
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
2000d484:	280a953a 	slli	r5,r5,20
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
2000d488:	10bfffc4 	addi	r2,r2,-1
2000d48c:	2084703a 	and	r2,r4,r2
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
2000d490:	295ffc2c 	andhi	r5,r5,32752
2000d494:	29400134 	orhi	r5,r5,4

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
2000d498:	288ab03a 	or	r5,r5,r2
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
2000d49c:	19400035 	stwio	r5,0(r3)
2000d4a0:	f800283a 	ret

2000d4a4 <alt_avalon_sgdma_disable_desc_poll>:
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
2000d4a4:	20800317 	ldw	r2,12(r4)
2000d4a8:	10800404 	addi	r2,r2,16
2000d4ac:	11000037 	ldwio	r4,0(r2)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
2000d4b0:	00ffff34 	movhi	r3,65532
2000d4b4:	18ffffc4 	addi	r3,r3,-1
2000d4b8:	20c6703a 	and	r3,r4,r3

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
2000d4bc:	10c00035 	stwio	r3,0(r2)
2000d4c0:	f800283a 	ret

2000d4c4 <alt_avalon_sgdma_construct_descriptor_burst>:
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
2000d4c4:	288007c3 	ldbu	r2,31(r5)
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
2000d4c8:	d8c00617 	ldw	r3,24(sp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
2000d4cc:	10801fcc 	andi	r2,r2,127
2000d4d0:	288007e5 	stbio	r2,31(r5)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
2000d4d4:	3004d23a 	srli	r2,r6,8
2000d4d8:	21800005 	stb	r6,0(r4)
  desc->write_addr               = write_addr;
2000d4dc:	21c00205 	stb	r7,8(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
2000d4e0:	20800045 	stb	r2,1(r4)
2000d4e4:	3004d43a 	srli	r2,r6,16
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
2000d4e8:	21400405 	stb	r5,16(r4)
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
2000d4ec:	300cd63a 	srli	r6,r6,24
2000d4f0:	20800085 	stb	r2,2(r4)
  desc->write_addr               = write_addr;
2000d4f4:	3804d23a 	srli	r2,r7,8
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
2000d4f8:	218000c5 	stb	r6,3(r4)
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
2000d4fc:	20000105 	stb	zero,4(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
2000d500:	20800245 	stb	r2,9(r4)
2000d504:	3804d43a 	srli	r2,r7,16
2000d508:	380ed63a 	srli	r7,r7,24
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
2000d50c:	20000145 	stb	zero,5(r4)
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
2000d510:	20800285 	stb	r2,10(r4)
  desc->next                     = (alt_u32 *) next;
2000d514:	2804d23a 	srli	r2,r5,8
   */
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
2000d518:	21c002c5 	stb	r7,11(r4)
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
2000d51c:	20000185 	stb	zero,6(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
2000d520:	20800445 	stb	r2,17(r4)
2000d524:	2804d43a 	srli	r2,r5,16
2000d528:	280ad63a 	srli	r5,r5,24
  desc->read_addr_pad            = 0x0;
2000d52c:	200001c5 	stb	zero,7(r4)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
2000d530:	20800485 	stb	r2,18(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
2000d534:	d880000b 	ldhu	r2,0(sp)
  IOWR_8DIRECT(&next->control, 0,
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
2000d538:	214004c5 	stb	r5,19(r4)
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
2000d53c:	20000305 	stb	zero,12(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
2000d540:	20800605 	stb	r2,24(r4)
2000d544:	1004d23a 	srli	r2,r2,8

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
2000d548:	20000345 	stb	zero,13(r4)
2000d54c:	20000385 	stb	zero,14(r4)
  desc->next_pad                 = 0x0;
  desc->bytes_to_transfer        = length_or_eop;
2000d550:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
2000d554:	d8800417 	ldw	r2,16(sp)

  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
2000d558:	200003c5 	stb	zero,15(r4)
  desc->next_pad                 = 0x0;
2000d55c:	20000505 	stb	zero,20(r4)
  desc->bytes_to_transfer        = length_or_eop;
  desc->actual_bytes_transferred = 0;
  desc->status                   = 0x0;

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
2000d560:	20800685 	stb	r2,26(r4)
  desc->write_burst              = write_burst;
2000d564:	d8800517 	ldw	r2,20(sp)
  desc->read_addr                = read_addr;
  desc->write_addr               = write_addr;
  desc->next                     = (alt_u32 *) next;
  desc->read_addr_pad            = 0x0;
  desc->write_addr_pad           = 0x0;
  desc->next_pad                 = 0x0;
2000d568:	20000545 	stb	zero,21(r4)
2000d56c:	20000585 	stb	zero,22(r4)
2000d570:	200005c5 	stb	zero,23(r4)
  desc->bytes_to_transfer        = length_or_eop;
  desc->actual_bytes_transferred = 0;
2000d574:	20000705 	stb	zero,28(r4)
2000d578:	20000745 	stb	zero,29(r4)
  desc->status                   = 0x0;
2000d57c:	20000785 	stb	zero,30(r4)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
  desc->write_burst              = write_burst;
2000d580:	208006c5 	stb	r2,27(r4)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
2000d584:	d8800117 	ldw	r2,4(sp)
2000d588:	d9400317 	ldw	r5,12(sp)
2000d58c:	1004c03a 	cmpne	r2,r2,zero
2000d590:	11bfe004 	addi	r6,r2,-128
2000d594:	d8800217 	ldw	r2,8(sp)
2000d598:	280ac03a 	cmpne	r5,r5,zero
2000d59c:	280a90ba 	slli	r5,r5,2
2000d5a0:	1004c03a 	cmpne	r2,r2,zero
2000d5a4:	1004907a 	slli	r2,r2,1
2000d5a8:	1184b03a 	or	r2,r2,r6
2000d5ac:	114ab03a 	or	r5,r2,r5
2000d5b0:	18803fcc 	andi	r2,r3,255
2000d5b4:	10000326 	beq	r2,zero,2000d5c4 <alt_avalon_sgdma_construct_descriptor_burst+0x100>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
2000d5b8:	18c003cc 	andi	r3,r3,15
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
2000d5bc:	180490fa 	slli	r2,r3,3
2000d5c0:	00000106 	br	2000d5c8 <alt_avalon_sgdma_construct_descriptor_burst+0x104>
2000d5c4:	0005883a 	mov	r2,zero
2000d5c8:	2884b03a 	or	r2,r5,r2
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
2000d5cc:	01400804 	movi	r5,32
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
2000d5d0:	208007c5 	stb	r2,31(r4)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
2000d5d4:	000dabc1 	jmpi	2000dabc <alt_dcache_flush>

2000d5d8 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
2000d5d8:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
2000d5dc:	d880080b 	ldhu	r2,32(sp)
2000d5e0:	d8000115 	stw	zero,4(sp)
2000d5e4:	d8000615 	stw	zero,24(sp)
2000d5e8:	d8800015 	stw	r2,0(sp)
2000d5ec:	d8800917 	ldw	r2,36(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
2000d5f0:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
2000d5f4:	d8800215 	stw	r2,8(sp)
2000d5f8:	d8800a17 	ldw	r2,40(sp)
2000d5fc:	d8800315 	stw	r2,12(sp)
2000d600:	d8800b17 	ldw	r2,44(sp)
2000d604:	d8800415 	stw	r2,16(sp)
2000d608:	d8800c17 	ldw	r2,48(sp)
2000d60c:	d8800515 	stw	r2,20(sp)
2000d610:	000d4c40 	call	2000d4c4 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
2000d614:	dfc00717 	ldw	ra,28(sp)
2000d618:	dec00804 	addi	sp,sp,32
2000d61c:	f800283a 	ret

2000d620 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
2000d620:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
2000d624:	d880060b 	ldhu	r2,24(sp)
2000d628:	d8000315 	stw	zero,12(sp)
2000d62c:	d8000415 	stw	zero,16(sp)
2000d630:	d8800015 	stw	r2,0(sp)
2000d634:	d8800717 	ldw	r2,28(sp)
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
2000d638:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
2000d63c:	d8800115 	stw	r2,4(sp)
2000d640:	d8800817 	ldw	r2,32(sp)
2000d644:	d8800215 	stw	r2,8(sp)
2000d648:	000d5d80 	call	2000d5d8 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
2000d64c:	dfc00517 	ldw	ra,20(sp)
2000d650:	dec00604 	addi	sp,sp,24
2000d654:	f800283a 	ret

2000d658 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
2000d658:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
2000d65c:	d8c00817 	ldw	r3,32(sp)
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
2000d660:	3005883a 	mov	r2,r6
  alt_avalon_sgdma_construct_descriptor_burst(
2000d664:	39ffffcc 	andi	r7,r7,65535
2000d668:	d8c00315 	stw	r3,12(sp)
2000d66c:	d8c00917 	ldw	r3,36(sp)
2000d670:	d9c00015 	stw	r7,0(sp)
2000d674:	d8000115 	stw	zero,4(sp)
2000d678:	d8000215 	stw	zero,8(sp)
2000d67c:	d8000415 	stw	zero,16(sp)
2000d680:	d8c00515 	stw	r3,20(sp)
2000d684:	d8000615 	stw	zero,24(sp)
2000d688:	000d883a 	mov	r6,zero
2000d68c:	100f883a 	mov	r7,r2
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
2000d690:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
2000d694:	000d4c40 	call	2000d4c4 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
2000d698:	dfc00717 	ldw	ra,28(sp)
2000d69c:	dec00804 	addi	sp,sp,32
2000d6a0:	f800283a 	ret

2000d6a4 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
2000d6a4:	defffd04 	addi	sp,sp,-12
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
2000d6a8:	d8800317 	ldw	r2,12(sp)
2000d6ac:	d8000115 	stw	zero,4(sp)
2000d6b0:	39ffffcc 	andi	r7,r7,65535
2000d6b4:	d8800015 	stw	r2,0(sp)
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
2000d6b8:	dfc00215 	stw	ra,8(sp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
2000d6bc:	000d6580 	call	2000d658 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
2000d6c0:	dfc00217 	ldw	ra,8(sp)
2000d6c4:	dec00304 	addi	sp,sp,12
2000d6c8:	f800283a 	ret

2000d6cc <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
2000d6cc:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(
2000d6d0:	d8800a17 	ldw	r2,40(sp)
2000d6d4:	39ffffcc 	andi	r7,r7,65535
2000d6d8:	d9c00015 	stw	r7,0(sp)
2000d6dc:	d8800115 	stw	r2,4(sp)
2000d6e0:	d8800817 	ldw	r2,32(sp)
2000d6e4:	d8000515 	stw	zero,20(sp)
2000d6e8:	000f883a 	mov	r7,zero
2000d6ec:	d8800215 	stw	r2,8(sp)
2000d6f0:	d8800917 	ldw	r2,36(sp)
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
2000d6f4:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(
2000d6f8:	d8800315 	stw	r2,12(sp)
2000d6fc:	d8800b17 	ldw	r2,44(sp)
2000d700:	d8800415 	stw	r2,16(sp)
2000d704:	d8800c03 	ldbu	r2,48(sp)
2000d708:	d8800615 	stw	r2,24(sp)
2000d70c:	000d4c40 	call	2000d4c4 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
2000d710:	dfc00717 	ldw	ra,28(sp)
2000d714:	dec00804 	addi	sp,sp,32
2000d718:	f800283a 	ret

2000d71c <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
2000d71c:	defffa04 	addi	sp,sp,-24
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
2000d720:	d8800617 	ldw	r2,24(sp)
2000d724:	d8000315 	stw	zero,12(sp)
2000d728:	39ffffcc 	andi	r7,r7,65535
2000d72c:	d8800015 	stw	r2,0(sp)
2000d730:	d8800717 	ldw	r2,28(sp)
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
2000d734:	dfc00515 	stw	ra,20(sp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
2000d738:	d8800115 	stw	r2,4(sp)
2000d73c:	d8800817 	ldw	r2,32(sp)
2000d740:	d8800215 	stw	r2,8(sp)
2000d744:	d8800903 	ldbu	r2,36(sp)
2000d748:	d8800415 	stw	r2,16(sp)
2000d74c:	000d6cc0 	call	2000d6cc <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
2000d750:	dfc00517 	ldw	ra,20(sp)
2000d754:	dec00604 	addi	sp,sp,24
2000d758:	f800283a 	ret

2000d75c <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
2000d75c:	defff804 	addi	sp,sp,-32
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
2000d760:	d880080b 	ldhu	r2,32(sp)
2000d764:	d8000415 	stw	zero,16(sp)
2000d768:	d8000515 	stw	zero,20(sp)
2000d76c:	d8800015 	stw	r2,0(sp)
2000d770:	d8800917 	ldw	r2,36(sp)
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
2000d774:	dfc00715 	stw	ra,28(sp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
2000d778:	d8800115 	stw	r2,4(sp)
2000d77c:	d8800a17 	ldw	r2,40(sp)
2000d780:	d8800215 	stw	r2,8(sp)
2000d784:	d8800b17 	ldw	r2,44(sp)
2000d788:	d8800315 	stw	r2,12(sp)
2000d78c:	d8800c03 	ldbu	r2,48(sp)
2000d790:	d8800615 	stw	r2,24(sp)
2000d794:	000d4c40 	call	2000d4c4 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
2000d798:	dfc00717 	ldw	ra,28(sp)
2000d79c:	dec00804 	addi	sp,sp,32
2000d7a0:	f800283a 	ret

2000d7a4 <alt_avalon_sgdma_init>:

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
2000d7a4:	20c00317 	ldw	r3,12(r4)
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
2000d7a8:	defffb04 	addi	sp,sp,-20
2000d7ac:	dc800315 	stw	r18,12(sp)
2000d7b0:	dc400215 	stw	r17,8(sp)
2000d7b4:	dc000115 	stw	r16,4(sp)
2000d7b8:	dfc00415 	stw	ra,16(sp)
2000d7bc:	2021883a 	mov	r16,r4
2000d7c0:	2825883a 	mov	r18,r5
2000d7c4:	3023883a 	mov	r17,r6

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
2000d7c8:	00800074 	movhi	r2,1
2000d7cc:	18800435 	stwio	r2,16(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
2000d7d0:	20c00317 	ldw	r3,12(r4)
2000d7d4:	18800435 	stwio	r2,16(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
2000d7d8:	20800317 	ldw	r2,12(r4)
2000d7dc:	10000435 	stwio	zero,16(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
2000d7e0:	20800317 	ldw	r2,12(r4)
2000d7e4:	00c03fc4 	movi	r3,255
2000d7e8:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
2000d7ec:	d1602104 	addi	r5,gp,-32636
2000d7f0:	000dacc0 	call	2000dacc <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
2000d7f4:	01880074 	movhi	r6,8193
2000d7f8:	d8000015 	stw	zero,0(sp)
2000d7fc:	9009883a 	mov	r4,r18
2000d800:	880b883a 	mov	r5,r17
2000d804:	31b49504 	addi	r6,r6,-11692
2000d808:	800f883a 	mov	r7,r16
2000d80c:	000dc540 	call	2000dc54 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
2000d810:	dfc00417 	ldw	ra,16(sp)
2000d814:	dc800317 	ldw	r18,12(sp)
2000d818:	dc400217 	ldw	r17,8(sp)
2000d81c:	dc000117 	ldw	r16,4(sp)
2000d820:	dec00504 	addi	sp,sp,20
2000d824:	f800283a 	ret

2000d828 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
2000d828:	defffe04 	addi	sp,sp,-8
2000d82c:	dfc00115 	stw	ra,4(sp)
2000d830:	dc000015 	stw	r16,0(sp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
2000d834:	20000035 	stwio	zero,0(r4)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
2000d838:	20800137 	ldwio	r2,4(r4)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000d83c:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000d840:	00bfff84 	movi	r2,-2
2000d844:	8084703a 	and	r2,r16,r2
2000d848:	1001703a 	wrctl	status,r2
  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  alt_tick ();
2000d84c:	000e0200 	call	2000e020 <alt_tick>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000d850:	8001703a 	wrctl	status,r16
  alt_irq_enable_all(cpu_sr);
}
2000d854:	dfc00117 	ldw	ra,4(sp)
2000d858:	dc000017 	ldw	r16,0(sp)
2000d85c:	dec00204 	addi	sp,sp,8
2000d860:	f800283a 	ret

2000d864 <alt_avalon_timer_sc_init>:
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
2000d864:	00c00034 	movhi	r3,0
2000d868:	18c18a04 	addi	r3,r3,1576
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
2000d86c:	2005883a 	mov	r2,r4
2000d870:	2809883a 	mov	r4,r5
2000d874:	19400017 	ldw	r5,0(r3)
2000d878:	defffe04 	addi	sp,sp,-8
2000d87c:	dfc00115 	stw	ra,4(sp)
2000d880:	2800011e 	bne	r5,zero,2000d888 <alt_avalon_timer_sc_init+0x24>
  {
    _alt_tick_rate = nticks;
2000d884:	19c00015 	stw	r7,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
2000d888:	00c001c4 	movi	r3,7
2000d88c:	10c00135 	stwio	r3,4(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
2000d890:	300b883a 	mov	r5,r6
2000d894:	01880074 	movhi	r6,8193
2000d898:	d8000015 	stw	zero,0(sp)
2000d89c:	31b60a04 	addi	r6,r6,-10200
2000d8a0:	100f883a 	mov	r7,r2
2000d8a4:	000dc540 	call	2000dc54 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
2000d8a8:	dfc00117 	ldw	ra,4(sp)
2000d8ac:	dec00204 	addi	sp,sp,8
2000d8b0:	f800283a 	ret

2000d8b4 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
2000d8b4:	2005883a 	mov	r2,r4
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_read(&dev->state, buffer, space,
2000d8b8:	21000017 	ldw	r4,0(r4)
2000d8bc:	11c00217 	ldw	r7,8(r2)
2000d8c0:	21000a04 	addi	r4,r4,40
2000d8c4:	000d8dc1 	jmpi	2000d8dc <altera_avalon_uart_read>

2000d8c8 <altera_avalon_uart_write_fd>:
      fd->fd_flags);
}

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
2000d8c8:	2005883a 	mov	r2,r4
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_write(&dev->state, buffer, space,
2000d8cc:	21000017 	ldw	r4,0(r4)
2000d8d0:	11c00217 	ldw	r7,8(r2)
2000d8d4:	21000a04 	addi	r4,r4,40
2000d8d8:	000d9681 	jmpi	2000d968 <altera_avalon_uart_write>

2000d8dc <altera_avalon_uart_read>:
  int flags)
{
  int block;
  unsigned int status;

  block = !(flags & O_NONBLOCK);
2000d8dc:	39d0000c 	andi	r7,r7,16384

  do
  {
    status = IORD_ALTERA_AVALON_UART_STATUS(sp->base);
2000d8e0:	20c00017 	ldw	r3,0(r4)
2000d8e4:	18c00204 	addi	r3,r3,8
2000d8e8:	18800037 	ldwio	r2,0(r3)

    /* clear any error flags */

    IOWR_ALTERA_AVALON_UART_STATUS(sp->base, 0);
2000d8ec:	18000035 	stwio	zero,0(r3)

    if (status & ALTERA_AVALON_UART_CONTROL_RRDY_MSK)
2000d8f0:	10c0200c 	andi	r3,r2,128
2000d8f4:	1800021e 	bne	r3,zero,2000d900 <altera_avalon_uart_read+0x24>
      {
        return 1;
      }
    }
  }
  while (block);
2000d8f8:	383ff926 	beq	r7,zero,2000d8e0 <altera_avalon_uart_read+0x4>
2000d8fc:	00000706 	br	2000d91c <altera_avalon_uart_read+0x40>

    IOWR_ALTERA_AVALON_UART_STATUS(sp->base, 0);

    if (status & ALTERA_AVALON_UART_CONTROL_RRDY_MSK)
    {
      ptr[0] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
2000d900:	20c00017 	ldw	r3,0(r4)
2000d904:	18c00037 	ldwio	r3,0(r3)
2000d908:	28c00005 	stb	r3,0(r5)

      if (!(status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
2000d90c:	108000cc 	andi	r2,r2,3
2000d910:	103ff91e 	bne	r2,zero,2000d8f8 <altera_avalon_uart_read+0x1c>
      ALTERA_AVALON_UART_STATUS_FE_MSK)))
      {
        return 1;
2000d914:	00800044 	movi	r2,1
2000d918:	f800283a 	ret
2000d91c:	00800034 	movhi	r2,0
2000d920:	10816704 	addi	r2,r2,1436
2000d924:	10800017 	ldw	r2,0(r2)
2000d928:	10000926 	beq	r2,zero,2000d950 <altera_avalon_uart_read+0x74>
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
2000d92c:	deffff04 	addi	sp,sp,-4
2000d930:	dfc00015 	stw	ra,0(sp)
2000d934:	103ee83a 	callr	r2
      }
    }
  }
  while (block);

  ALT_ERRNO = EWOULDBLOCK;
2000d938:	00c002c4 	movi	r3,11
2000d93c:	10c00015 	stw	r3,0(r2)
 
  return 0;
2000d940:	0005883a 	mov	r2,zero
}
2000d944:	dfc00017 	ldw	ra,0(sp)
2000d948:	dec00104 	addi	sp,sp,4
2000d94c:	f800283a 	ret
2000d950:	00800034 	movhi	r2,0
2000d954:	10816b04 	addi	r2,r2,1452
      }
    }
  }
  while (block);

  ALT_ERRNO = EWOULDBLOCK;
2000d958:	00c002c4 	movi	r3,11
2000d95c:	10c00015 	stw	r3,0(r2)
 
  return 0;
2000d960:	0005883a 	mov	r2,zero
}
2000d964:	f800283a 	ret

2000d968 <altera_avalon_uart_write>:
 */

int 
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
2000d968:	defffd04 	addi	sp,sp,-12
2000d96c:	dc400115 	stw	r17,4(sp)
2000d970:	dc000015 	stw	r16,0(sp)
2000d974:	dfc00215 	stw	ra,8(sp)
2000d978:	3023883a 	mov	r17,r6
  int block;
  unsigned int status;
  int count;

  block = !(flags & O_NONBLOCK);
2000d97c:	39d0000c 	andi	r7,r7,16384
  count = len;
2000d980:	3021883a 	mov	r16,r6

  do
  {
    status = IORD_ALTERA_AVALON_UART_STATUS(sp->base);
2000d984:	20800017 	ldw	r2,0(r4)
2000d988:	10c00237 	ldwio	r3,8(r2)
   
    if (status & ALTERA_AVALON_UART_STATUS_TRDY_MSK)
2000d98c:	18c0100c 	andi	r3,r3,64
2000d990:	18000526 	beq	r3,zero,2000d9a8 <altera_avalon_uart_write+0x40>
    {
      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, *ptr++);
2000d994:	28c00044 	addi	r3,r5,1
2000d998:	29400007 	ldb	r5,0(r5)
2000d99c:	11400135 	stwio	r5,4(r2)
      count--;
2000d9a0:	843fffc4 	addi	r16,r16,-1
  {
    status = IORD_ALTERA_AVALON_UART_STATUS(sp->base);
   
    if (status & ALTERA_AVALON_UART_STATUS_TRDY_MSK)
    {
      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, *ptr++);
2000d9a4:	180b883a 	mov	r5,r3
      count--;
    }
  }
  while (block && count);
2000d9a8:	3800021e 	bne	r7,zero,2000d9b4 <altera_avalon_uart_write+0x4c>
2000d9ac:	803ff51e 	bne	r16,zero,2000d984 <altera_avalon_uart_write+0x1c>
2000d9b0:	00000b06 	br	2000d9e0 <altera_avalon_uart_write+0x78>

  if (count)
2000d9b4:	80000a26 	beq	r16,zero,2000d9e0 <altera_avalon_uart_write+0x78>
2000d9b8:	00800034 	movhi	r2,0
2000d9bc:	10816704 	addi	r2,r2,1436
2000d9c0:	10800017 	ldw	r2,0(r2)
2000d9c4:	10000226 	beq	r2,zero,2000d9d0 <altera_avalon_uart_write+0x68>
2000d9c8:	103ee83a 	callr	r2
2000d9cc:	00000206 	br	2000d9d8 <altera_avalon_uart_write+0x70>
2000d9d0:	00800034 	movhi	r2,0
2000d9d4:	10816b04 	addi	r2,r2,1452
  {
    ALT_ERRNO = EWOULDBLOCK;
2000d9d8:	00c002c4 	movi	r3,11
2000d9dc:	10c00015 	stw	r3,0(r2)
  }

  return (len - count);
}
2000d9e0:	8c05c83a 	sub	r2,r17,r16
2000d9e4:	dfc00217 	ldw	ra,8(sp)
2000d9e8:	dc400117 	ldw	r17,4(sp)
2000d9ec:	dc000017 	ldw	r16,0(sp)
2000d9f0:	dec00304 	addi	sp,sp,12
2000d9f4:	f800283a 	ret

2000d9f8 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
2000d9f8:	defffd04 	addi	sp,sp,-12
2000d9fc:	dc400115 	stw	r17,4(sp)
2000da00:	dfc00215 	stw	ra,8(sp)
2000da04:	dc000015 	stw	r16,0(sp)
2000da08:	2023883a 	mov	r17,r4
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
2000da0c:	20001b16 	blt	r4,zero,2000da7c <close+0x84>
2000da10:	21000324 	muli	r4,r4,12
2000da14:	00800034 	movhi	r2,0
2000da18:	1080d504 	addi	r2,r2,852
2000da1c:	2089883a 	add	r4,r4,r2

  if (fd)
2000da20:	20001626 	beq	r4,zero,2000da7c <close+0x84>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
2000da24:	20c00017 	ldw	r3,0(r4)
2000da28:	18c00417 	ldw	r3,16(r3)
2000da2c:	18000326 	beq	r3,zero,2000da3c <close+0x44>
2000da30:	183ee83a 	callr	r3
2000da34:	1021883a 	mov	r16,r2
2000da38:	00000106 	br	2000da40 <close+0x48>
2000da3c:	0021883a 	mov	r16,zero

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
2000da40:	8809883a 	mov	r4,r17
2000da44:	000dfc80 	call	2000dfc8 <alt_release_fd>
    if (rval < 0)
    {
      ALT_ERRNO = -rval;
      return -1;
    }
    return 0;
2000da48:	0005883a 	mov	r2,zero
    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
    if (rval < 0)
2000da4c:	8000160e 	bge	r16,zero,2000daa8 <close+0xb0>
2000da50:	00800034 	movhi	r2,0
2000da54:	10816704 	addi	r2,r2,1436
2000da58:	10800017 	ldw	r2,0(r2)
2000da5c:	10000226 	beq	r2,zero,2000da68 <close+0x70>
2000da60:	103ee83a 	callr	r2
2000da64:	00000206 	br	2000da70 <close+0x78>
2000da68:	00800034 	movhi	r2,0
2000da6c:	10816b04 	addi	r2,r2,1452
    {
      ALT_ERRNO = -rval;
2000da70:	0421c83a 	sub	r16,zero,r16
2000da74:	14000015 	stw	r16,0(r2)
2000da78:	00000a06 	br	2000daa4 <close+0xac>
2000da7c:	00800034 	movhi	r2,0
2000da80:	10816704 	addi	r2,r2,1436
2000da84:	10800017 	ldw	r2,0(r2)
2000da88:	10000226 	beq	r2,zero,2000da94 <close+0x9c>
2000da8c:	103ee83a 	callr	r2
2000da90:	00000206 	br	2000da9c <close+0xa4>
2000da94:	00800034 	movhi	r2,0
2000da98:	10816b04 	addi	r2,r2,1452
    }
    return 0;
  }
  else
  {
    ALT_ERRNO = EBADFD;
2000da9c:	00c01444 	movi	r3,81
2000daa0:	10c00015 	stw	r3,0(r2)
    return -1;
2000daa4:	00bfffc4 	movi	r2,-1
  }
}
2000daa8:	dfc00217 	ldw	ra,8(sp)
2000daac:	dc400117 	ldw	r17,4(sp)
2000dab0:	dc000017 	ldw	r16,0(sp)
2000dab4:	dec00304 	addi	sp,sp,12
2000dab8:	f800283a 	ret

2000dabc <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
2000dabc:	f800283a 	ret

2000dac0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
2000dac0:	f800283a 	ret

2000dac4 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
2000dac4:	3005883a 	mov	r2,r6
2000dac8:	f800283a 	ret

2000dacc <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
2000dacc:	20000226 	beq	r4,zero,2000dad8 <alt_dev_llist_insert+0xc>
2000dad0:	20800217 	ldw	r2,8(r4)
2000dad4:	1000131e 	bne	r2,zero,2000db24 <alt_dev_llist_insert+0x58>
2000dad8:	00800034 	movhi	r2,0
2000dadc:	10816704 	addi	r2,r2,1436
2000dae0:	10800017 	ldw	r2,0(r2)
2000dae4:	10000926 	beq	r2,zero,2000db0c <alt_dev_llist_insert+0x40>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
2000dae8:	deffff04 	addi	sp,sp,-4
2000daec:	dfc00015 	stw	ra,0(sp)
2000daf0:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
2000daf4:	00c00584 	movi	r3,22
2000daf8:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
2000dafc:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
2000db00:	dfc00017 	ldw	ra,0(sp)
2000db04:	dec00104 	addi	sp,sp,4
2000db08:	f800283a 	ret
2000db0c:	00800034 	movhi	r2,0
2000db10:	10816b04 	addi	r2,r2,1452
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
2000db14:	00c00584 	movi	r3,22
2000db18:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
2000db1c:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
2000db20:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
2000db24:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
2000db28:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
2000db2c:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
2000db30:	28800017 	ldw	r2,0(r5)
2000db34:	11000115 	stw	r4,4(r2)
  list->next           = entry;
2000db38:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
2000db3c:	0005883a 	mov	r2,zero
2000db40:	f800283a 	ret

2000db44 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
2000db44:	defffd04 	addi	sp,sp,-12
2000db48:	dc400115 	stw	r17,4(sp)
2000db4c:	dc000015 	stw	r16,0(sp)
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
2000db50:	04480074 	movhi	r17,8193
2000db54:	04080074 	movhi	r16,8193
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
2000db58:	dfc00215 	stw	ra,8(sp)
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
2000db5c:	843a0b04 	addi	r16,r16,-6100
2000db60:	8c7a0c04 	addi	r17,r17,-6096
2000db64:	84400436 	bltu	r16,r17,2000db78 <_do_ctors+0x34>
        (*ctor) (); 
2000db68:	80800017 	ldw	r2,0(r16)

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
2000db6c:	843fff04 	addi	r16,r16,-4
        (*ctor) (); 
2000db70:	103ee83a 	callr	r2
2000db74:	003ffb06 	br	2000db64 <_do_ctors+0x20>
}
2000db78:	dfc00217 	ldw	ra,8(sp)
2000db7c:	dc400117 	ldw	r17,4(sp)
2000db80:	dc000017 	ldw	r16,0(sp)
2000db84:	dec00304 	addi	sp,sp,12
2000db88:	f800283a 	ret

2000db8c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
2000db8c:	defffd04 	addi	sp,sp,-12
2000db90:	dc400115 	stw	r17,4(sp)
2000db94:	dc000015 	stw	r16,0(sp)
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
2000db98:	04480074 	movhi	r17,8193
2000db9c:	04080074 	movhi	r16,8193
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
2000dba0:	dfc00215 	stw	ra,8(sp)
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
2000dba4:	843a0b04 	addi	r16,r16,-6100
2000dba8:	8c7a0c04 	addi	r17,r17,-6096
2000dbac:	84400436 	bltu	r16,r17,2000dbc0 <_do_dtors+0x34>
        (*dtor) (); 
2000dbb0:	80800017 	ldw	r2,0(r16)

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
2000dbb4:	843fff04 	addi	r16,r16,-4
        (*dtor) (); 
2000dbb8:	103ee83a 	callr	r2
2000dbbc:	003ffb06 	br	2000dbac <_do_dtors+0x20>
}
2000dbc0:	dfc00217 	ldw	ra,8(sp)
2000dbc4:	dc400117 	ldw	r17,4(sp)
2000dbc8:	dc000017 	ldw	r16,0(sp)
2000dbcc:	dec00304 	addi	sp,sp,12
2000dbd0:	f800283a 	ret

2000dbd4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
2000dbd4:	defffb04 	addi	sp,sp,-20
2000dbd8:	dcc00315 	stw	r19,12(sp)
2000dbdc:	dc800215 	stw	r18,8(sp)
2000dbe0:	dc400115 	stw	r17,4(sp)
2000dbe4:	dc000015 	stw	r16,0(sp)
2000dbe8:	dfc00415 	stw	ra,16(sp)
2000dbec:	2027883a 	mov	r19,r4
2000dbf0:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
2000dbf4:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
2000dbf8:	00084040 	call	20008404 <strlen>
2000dbfc:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
2000dc00:	84400726 	beq	r16,r17,2000dc20 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
2000dc04:	81000217 	ldw	r4,8(r16)
2000dc08:	980b883a 	mov	r5,r19
2000dc0c:	900d883a 	mov	r6,r18
2000dc10:	000e4d40 	call	2000e4d4 <memcmp>
2000dc14:	10000426 	beq	r2,zero,2000dc28 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
2000dc18:	84000017 	ldw	r16,0(r16)
2000dc1c:	003ff806 	br	2000dc00 <alt_find_dev+0x2c>
  }
  
  /* No match found */
  
  return NULL;
2000dc20:	0005883a 	mov	r2,zero
2000dc24:	00000106 	br	2000dc2c <alt_find_dev+0x58>
2000dc28:	8005883a 	mov	r2,r16
}
2000dc2c:	dfc00417 	ldw	ra,16(sp)
2000dc30:	dcc00317 	ldw	r19,12(sp)
2000dc34:	dc800217 	ldw	r18,8(sp)
2000dc38:	dc400117 	ldw	r17,4(sp)
2000dc3c:	dc000017 	ldw	r16,0(sp)
2000dc40:	dec00504 	addi	sp,sp,20
2000dc44:	f800283a 	ret

2000dc48 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
2000dc48:	0009883a 	mov	r4,zero
2000dc4c:	01420004 	movi	r5,2048
2000dc50:	000e3f41 	jmpi	2000e3f4 <alt_icache_flush>

2000dc54 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
2000dc54:	000dcf01 	jmpi	2000dcf0 <alt_iic_isr_register>

2000dc58 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000dc58:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000dc5c:	00bfff84 	movi	r2,-2
2000dc60:	3084703a 	and	r2,r6,r2
2000dc64:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
2000dc68:	00800034 	movhi	r2,0
2000dc6c:	10818804 	addi	r2,r2,1568
2000dc70:	01000044 	movi	r4,1
2000dc74:	10c00017 	ldw	r3,0(r2)
2000dc78:	214a983a 	sll	r5,r4,r5
2000dc7c:	28cab03a 	or	r5,r5,r3
2000dc80:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
2000dc84:	10800017 	ldw	r2,0(r2)
2000dc88:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000dc8c:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
2000dc90:	0005883a 	mov	r2,zero
2000dc94:	f800283a 	ret

2000dc98 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000dc98:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000dc9c:	00bfff84 	movi	r2,-2
2000dca0:	3084703a 	and	r2,r6,r2
2000dca4:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
2000dca8:	00800034 	movhi	r2,0
2000dcac:	10818804 	addi	r2,r2,1568
2000dcb0:	013fff84 	movi	r4,-2
2000dcb4:	10c00017 	ldw	r3,0(r2)
2000dcb8:	214a183a 	rol	r5,r4,r5
2000dcbc:	28ca703a 	and	r5,r5,r3
2000dcc0:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
2000dcc4:	10800017 	ldw	r2,0(r2)
2000dcc8:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000dccc:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
2000dcd0:	0005883a 	mov	r2,zero
2000dcd4:	f800283a 	ret

2000dcd8 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
2000dcd8:	000530fa 	rdctl	r2,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
2000dcdc:	00c00044 	movi	r3,1
2000dce0:	194a983a 	sll	r5,r3,r5
2000dce4:	1144703a 	and	r2,r2,r5
}
2000dce8:	1004c03a 	cmpne	r2,r2,zero
2000dcec:	f800283a 	ret

2000dcf0 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
2000dcf0:	00c007c4 	movi	r3,31
2000dcf4:	19401616 	blt	r3,r5,2000dd50 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
2000dcf8:	defffe04 	addi	sp,sp,-8
2000dcfc:	dfc00115 	stw	ra,4(sp)
2000dd00:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000dd04:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000dd08:	00ffff84 	movi	r3,-2
2000dd0c:	80c6703a 	and	r3,r16,r3
2000dd10:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
2000dd14:	280490fa 	slli	r2,r5,3
2000dd18:	00c00034 	movhi	r3,0
2000dd1c:	18de1504 	addi	r3,r3,30804
2000dd20:	1891883a 	add	r8,r3,r2
2000dd24:	41800015 	stw	r6,0(r8)
    alt_irq[id].context = isr_context;
2000dd28:	41c00115 	stw	r7,4(r8)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
2000dd2c:	30000226 	beq	r6,zero,2000dd38 <alt_iic_isr_register+0x48>
2000dd30:	000dc580 	call	2000dc58 <alt_ic_irq_enable>
2000dd34:	00000106 	br	2000dd3c <alt_iic_isr_register+0x4c>
2000dd38:	000dc980 	call	2000dc98 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000dd3c:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
2000dd40:	dfc00117 	ldw	ra,4(sp)
2000dd44:	dc000017 	ldw	r16,0(sp)
2000dd48:	dec00204 	addi	sp,sp,8
2000dd4c:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
2000dd50:	00bffa84 	movi	r2,-22
2000dd54:	f800283a 	ret

2000dd58 <alt_open_fd.constprop.0>:
 *
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
2000dd58:	defffe04 	addi	sp,sp,-8
2000dd5c:	dc000015 	stw	r16,0(sp)
2000dd60:	2021883a 	mov	r16,r4
{
  int old;

  old = open (name, flags, mode);
2000dd64:	2809883a 	mov	r4,r5
2000dd68:	300b883a 	mov	r5,r6
2000dd6c:	01807fc4 	movi	r6,511
 *
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
2000dd70:	dfc00115 	stw	ra,4(sp)
{
  int old;

  old = open (name, flags, mode);
2000dd74:	000de480 	call	2000de48 <open>

  if (old >= 0)
2000dd78:	10001116 	blt	r2,zero,2000ddc0 <alt_open_fd.constprop.0+0x68>
  {
    fd->dev      = alt_fd_list[old].dev;
2000dd7c:	10c00324 	muli	r3,r2,12
2000dd80:	01000034 	movhi	r4,0
2000dd84:	2100d504 	addi	r4,r4,852
2000dd88:	20cb883a 	add	r5,r4,r3
2000dd8c:	29400017 	ldw	r5,0(r5)
2000dd90:	81400015 	stw	r5,0(r16)
    fd->priv     = alt_fd_list[old].priv;
2000dd94:	20cb883a 	add	r5,r4,r3
    fd->fd_flags = alt_fd_list[old].fd_flags;
2000dd98:	20c7883a 	add	r3,r4,r3
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2000dd9c:	29400117 	ldw	r5,4(r5)
    fd->fd_flags = alt_fd_list[old].fd_flags;
2000dda0:	18c00217 	ldw	r3,8(r3)

    alt_release_fd (old);
2000dda4:	1009883a 	mov	r4,r2
  old = open (name, flags, mode);

  if (old >= 0)
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
2000dda8:	81400115 	stw	r5,4(r16)
    fd->fd_flags = alt_fd_list[old].fd_flags;
2000ddac:	80c00215 	stw	r3,8(r16)

    alt_release_fd (old);
  }
} 
2000ddb0:	dfc00117 	ldw	ra,4(sp)
2000ddb4:	dc000017 	ldw	r16,0(sp)
2000ddb8:	dec00204 	addi	sp,sp,8
  {
    fd->dev      = alt_fd_list[old].dev;
    fd->priv     = alt_fd_list[old].priv;
    fd->fd_flags = alt_fd_list[old].fd_flags;

    alt_release_fd (old);
2000ddbc:	000dfc81 	jmpi	2000dfc8 <alt_release_fd>
  }
} 
2000ddc0:	dfc00117 	ldw	ra,4(sp)
2000ddc4:	dc000017 	ldw	r16,0(sp)
2000ddc8:	dec00204 	addi	sp,sp,8
2000ddcc:	f800283a 	ret

2000ddd0 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
2000ddd0:	defffb04 	addi	sp,sp,-20
2000ddd4:	dc000015 	stw	r16,0(sp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
2000ddd8:	04000034 	movhi	r16,0
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
2000dddc:	2005883a 	mov	r2,r4
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
2000dde0:	8400d804 	addi	r16,r16,864
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
2000dde4:	dc400115 	stw	r17,4(sp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
2000dde8:	04400044 	movi	r17,1
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
2000ddec:	dcc00315 	stw	r19,12(sp)
2000ddf0:	dc800215 	stw	r18,8(sp)
2000ddf4:	2827883a 	mov	r19,r5
2000ddf8:	3025883a 	mov	r18,r6
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
2000ddfc:	100b883a 	mov	r5,r2
2000de00:	8009883a 	mov	r4,r16
2000de04:	880d883a 	mov	r6,r17
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
2000de08:	dfc00415 	stw	ra,16(sp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
2000de0c:	000dd580 	call	2000dd58 <alt_open_fd.constprop.0>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
2000de10:	813ffd04 	addi	r4,r16,-12
2000de14:	980b883a 	mov	r5,r19
2000de18:	000d883a 	mov	r6,zero
2000de1c:	000dd580 	call	2000dd58 <alt_open_fd.constprop.0>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
2000de20:	81000304 	addi	r4,r16,12
2000de24:	900b883a 	mov	r5,r18
2000de28:	880d883a 	mov	r6,r17
}  
2000de2c:	dfc00417 	ldw	ra,16(sp)
2000de30:	dcc00317 	ldw	r19,12(sp)
2000de34:	dc800217 	ldw	r18,8(sp)
2000de38:	dc400117 	ldw	r17,4(sp)
2000de3c:	dc000017 	ldw	r16,0(sp)
2000de40:	dec00504 	addi	sp,sp,20
{
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
2000de44:	000dd581 	jmpi	2000dd58 <alt_open_fd.constprop.0>

2000de48 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
2000de48:	defff904 	addi	sp,sp,-28
2000de4c:	dc000015 	stw	r16,0(sp)
2000de50:	2821883a 	mov	r16,r5
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
2000de54:	01400034 	movhi	r5,0
2000de58:	29416304 	addi	r5,r5,1420
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
2000de5c:	dd400515 	stw	r21,20(sp)
2000de60:	dd000415 	stw	r20,16(sp)
2000de64:	dc800215 	stw	r18,8(sp)
2000de68:	dc400115 	stw	r17,4(sp)
2000de6c:	dfc00615 	stw	ra,24(sp)
2000de70:	dcc00315 	stw	r19,12(sp)
2000de74:	2023883a 	mov	r17,r4
2000de78:	3025883a 	mov	r18,r6
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
2000de7c:	000dbd40 	call	2000dbd4 <alt_find_dev>
2000de80:	1029883a 	mov	r20,r2
{ 
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
  int status = -ENODEV;
  int isafs = 0;
2000de84:	002b883a 	mov	r21,zero
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
2000de88:	1000051e 	bne	r2,zero,2000dea0 <open+0x58>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
2000de8c:	8809883a 	mov	r4,r17
2000de90:	000e2ac0 	call	2000e2ac <alt_find_file>
2000de94:	1029883a 	mov	r20,r2

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
2000de98:	10003b26 	beq	r2,zero,2000df88 <open+0x140>
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
    isafs = 1;
2000de9c:	05400044 	movi	r21,1
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
  {
    if ((index = alt_get_fd (dev)) < 0)
2000dea0:	a009883a 	mov	r4,r20
2000dea4:	000e3580 	call	2000e358 <alt_get_fd>
2000dea8:	1027883a 	mov	r19,r2
2000deac:	10003916 	blt	r2,zero,2000df94 <open+0x14c>
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
2000deb0:	12000324 	muli	r8,r2,12
2000deb4:	00c00034 	movhi	r3,0
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
2000deb8:	01500034 	movhi	r5,16384
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
2000debc:	18c0d504 	addi	r3,r3,852
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
2000dec0:	297fffc4 	addi	r5,r5,-1
    {
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
2000dec4:	40c9883a 	add	r4,r8,r3
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
2000dec8:	814a703a 	and	r5,r16,r5
2000decc:	42000204 	addi	r8,r8,8
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
2000ded0:	a8000626 	beq	r21,zero,2000deec <open+0xa4>
      status = index;
    }
    else
    {
      fd = &alt_fd_list[index];
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
2000ded4:	1a07883a 	add	r3,r3,r8
2000ded8:	19400015 	stw	r5,0(r3)
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
2000dedc:	a0800317 	ldw	r2,12(r20)
2000dee0:	1000141e 	bne	r2,zero,2000df34 <open+0xec>
2000dee4:	9805883a 	mov	r2,r19
2000dee8:	00002e06 	br	2000dfa4 <open+0x15c>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
2000deec:	00800034 	movhi	r2,0

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
2000def0:	29500034 	orhi	r5,r5,16384
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
2000def4:	10816204 	addi	r2,r2,1416

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
2000def8:	1a11883a 	add	r8,r3,r8
2000defc:	41400015 	stw	r5,0(r8)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
2000df00:	200d883a 	mov	r6,r4
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
2000df04:	11400017 	ldw	r5,0(r2)
2000df08:	0005883a 	mov	r2,zero
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
2000df0c:	1a000017 	ldw	r8,0(r3)
2000df10:	31c00017 	ldw	r7,0(r6)
2000df14:	41c0031e 	bne	r8,r7,2000df24 <open+0xdc>
2000df18:	19c00217 	ldw	r7,8(r3)
2000df1c:	3800010e 	bge	r7,zero,2000df24 <open+0xdc>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
2000df20:	19001e1e 	bne	r3,r4,2000df9c <open+0x154>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
2000df24:	10800044 	addi	r2,r2,1
2000df28:	18c00304 	addi	r3,r3,12
2000df2c:	28bff72e 	bgeu	r5,r2,2000df0c <open+0xc4>
2000df30:	003fea06 	br	2000dedc <open+0x94>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
2000df34:	800d883a 	mov	r6,r16
2000df38:	880b883a 	mov	r5,r17
2000df3c:	900f883a 	mov	r7,r18
2000df40:	103ee83a 	callr	r2
2000df44:	1021883a 	mov	r16,r2
2000df48:	9805883a 	mov	r2,r19
    status = -ENODEV;
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
2000df4c:	8000150e 	bge	r16,zero,2000dfa4 <open+0x15c>
  {
    alt_release_fd (index);  
2000df50:	9809883a 	mov	r4,r19
2000df54:	000dfc80 	call	2000dfc8 <alt_release_fd>
2000df58:	00800034 	movhi	r2,0
2000df5c:	10816704 	addi	r2,r2,1436
2000df60:	10800017 	ldw	r2,0(r2)
2000df64:	10000226 	beq	r2,zero,2000df70 <open+0x128>
2000df68:	103ee83a 	callr	r2
2000df6c:	00000206 	br	2000df78 <open+0x130>
2000df70:	00800034 	movhi	r2,0
2000df74:	10816b04 	addi	r2,r2,1452
    ALT_ERRNO = -status;
2000df78:	0421c83a 	sub	r16,zero,r16
2000df7c:	14000015 	stw	r16,0(r2)
    return -1;
2000df80:	00bfffc4 	movi	r2,-1
2000df84:	00000706 	br	2000dfa4 <open+0x15c>
      }
    }
  }
  else
  {
    status = -ENODEV;
2000df88:	043ffb44 	movi	r16,-19
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
2000df8c:	04ffffc4 	movi	r19,-1
2000df90:	003fef06 	br	2000df50 <open+0x108>
2000df94:	1021883a 	mov	r16,r2
2000df98:	003fed06 	br	2000df50 <open+0x108>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
2000df9c:	043ffcc4 	movi	r16,-13
2000dfa0:	003feb06 	br	2000df50 <open+0x108>
  }
  
  /* return the reference upon success */

  return index;
}
2000dfa4:	dfc00617 	ldw	ra,24(sp)
2000dfa8:	dd400517 	ldw	r21,20(sp)
2000dfac:	dd000417 	ldw	r20,16(sp)
2000dfb0:	dcc00317 	ldw	r19,12(sp)
2000dfb4:	dc800217 	ldw	r18,8(sp)
2000dfb8:	dc400117 	ldw	r17,4(sp)
2000dfbc:	dc000017 	ldw	r16,0(sp)
2000dfc0:	dec00704 	addi	sp,sp,28
2000dfc4:	f800283a 	ret

2000dfc8 <alt_release_fd>:
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
  if (fd > 2)
2000dfc8:	00800084 	movi	r2,2
2000dfcc:	1100060e 	bge	r2,r4,2000dfe8 <alt_release_fd+0x20>
  {
    alt_fd_list[fd].fd_flags = 0;
2000dfd0:	21000324 	muli	r4,r4,12
2000dfd4:	00800034 	movhi	r2,0
2000dfd8:	1080d504 	addi	r2,r2,852
2000dfdc:	1107883a 	add	r3,r2,r4
2000dfe0:	18000215 	stw	zero,8(r3)
    alt_fd_list[fd].dev      = 0;
2000dfe4:	18000015 	stw	zero,0(r3)
2000dfe8:	f800283a 	ret

2000dfec <alt_alarm_stop>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
2000dfec:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
2000dff0:	00bfff84 	movi	r2,-2
2000dff4:	1884703a 	and	r2,r3,r2
2000dff8:	1001703a 	wrctl	status,r2
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
2000dffc:	21400117 	ldw	r5,4(r4)
2000e000:	20800017 	ldw	r2,0(r4)
2000e004:	11400115 	stw	r5,4(r2)
  entry->previous->next = entry->next;
2000e008:	21400117 	ldw	r5,4(r4)
2000e00c:	28800015 	stw	r2,0(r5)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
2000e010:	21000115 	stw	r4,4(r4)
  entry->next     = entry;
2000e014:	21000015 	stw	r4,0(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
2000e018:	1801703a 	wrctl	status,r3
2000e01c:	f800283a 	ret

2000e020 <alt_tick>:

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
2000e020:	d0a04a17 	ldw	r2,-32472(gp)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
2000e024:	defffb04 	addi	sp,sp,-20
2000e028:	dc000015 	stw	r16,0(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
2000e02c:	d4202a17 	ldw	r16,-32600(gp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
2000e030:	10800044 	addi	r2,r2,1
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
2000e034:	dc800215 	stw	r18,8(sp)
2000e038:	dc400115 	stw	r17,4(sp)
2000e03c:	dfc00415 	stw	ra,16(sp)
2000e040:	dcc00315 	stw	r19,12(sp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
2000e044:	d0a04a15 	stw	r2,-32472(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
2000e048:	d4602a04 	addi	r17,gp,-32600
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
        {
          alarm->rollover = 1;
2000e04c:	04800044 	movi	r18,1

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
2000e050:	84401a26 	beq	r16,r17,2000e0bc <alt_tick+0x9c>
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
2000e054:	80800403 	ldbu	r2,16(r16)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  {
    next = (alt_alarm*) alarm->llist.next;
2000e058:	84c00017 	ldw	r19,0(r16)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
2000e05c:	10000326 	beq	r2,zero,2000e06c <alt_tick+0x4c>
2000e060:	d0a04a17 	ldw	r2,-32472(gp)
2000e064:	1000011e 	bne	r2,zero,2000e06c <alt_tick+0x4c>
    {
      alarm->rollover = 0;
2000e068:	80000405 	stb	zero,16(r16)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
2000e06c:	d0e04a17 	ldw	r3,-32472(gp)
2000e070:	80800217 	ldw	r2,8(r16)
2000e074:	18800f36 	bltu	r3,r2,2000e0b4 <alt_tick+0x94>
2000e078:	80800403 	ldbu	r2,16(r16)
2000e07c:	10000d1e 	bne	r2,zero,2000e0b4 <alt_tick+0x94>
    {
      next_callback = alarm->callback (alarm->context);
2000e080:	80800317 	ldw	r2,12(r16)
2000e084:	81000517 	ldw	r4,20(r16)
2000e088:	103ee83a 	callr	r2

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
2000e08c:	1000031e 	bne	r2,zero,2000e09c <alt_tick+0x7c>
      {
        alt_alarm_stop (alarm);
2000e090:	8009883a 	mov	r4,r16
2000e094:	000dfec0 	call	2000dfec <alt_alarm_stop>
2000e098:	00000606 	br	2000e0b4 <alt_tick+0x94>
      }
      else
      {
        alarm->time += next_callback;
2000e09c:	80c00217 	ldw	r3,8(r16)
2000e0a0:	10c5883a 	add	r2,r2,r3
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
2000e0a4:	d0e04a17 	ldw	r3,-32472(gp)
      {
        alt_alarm_stop (alarm);
      }
      else
      {
        alarm->time += next_callback;
2000e0a8:	80800215 	stw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
2000e0ac:	10c0012e 	bgeu	r2,r3,2000e0b4 <alt_tick+0x94>
        {
          alarm->rollover = 1;
2000e0b0:	84800405 	stb	r18,16(r16)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
2000e0b4:	9821883a 	mov	r16,r19
2000e0b8:	003fe506 	br	2000e050 <alt_tick+0x30>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
2000e0bc:	dfc00417 	ldw	ra,16(sp)
2000e0c0:	dcc00317 	ldw	r19,12(sp)
2000e0c4:	dc800217 	ldw	r18,8(sp)
2000e0c8:	dc400117 	ldw	r17,4(sp)
2000e0cc:	dc000017 	ldw	r16,0(sp)
2000e0d0:	dec00504 	addi	sp,sp,20

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
2000e0d4:	00092601 	jmpi	20009260 <OSTimeTick>

2000e0d8 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
2000e0d8:	000170fa 	wrctl	ienable,zero
2000e0dc:	f800283a 	ret

2000e0e0 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
2000e0e0:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
2000e0e4:	d0e00117 	ldw	r3,-32764(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
2000e0e8:	d1204317 	ldw	r4,-32500(gp)

      stw ra,  0(sp)
2000e0ec:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
2000e0f0:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
2000e0f4:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
2000e0f8:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
2000e0fc:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
2000e100:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
2000e104:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
2000e108:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
2000e10c:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
2000e110:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
2000e114:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
2000e118:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
2000e11c:	000e2900 	call	2000e290 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
2000e120:	d1203e17 	ldw	r4,-32520(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
2000e124:	d1603607 	ldb	r5,-32552(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
2000e128:	d1204315 	stw	r4,-32500(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
2000e12c:	d1603645 	stb	r5,-32551(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
2000e130:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
2000e134:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
2000e138:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
2000e13c:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
2000e140:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
2000e144:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
2000e148:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
2000e14c:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
2000e150:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
2000e154:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
2000e158:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
2000e15c:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
2000e160:	d0e00115 	stw	r3,-32764(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
2000e164:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
2000e168:	f800283a 	ret

2000e16c <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
2000e16c:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
2000e170:	047fff84 	movi	r17,-2
      and   r18, r18, r17
2000e174:	9464703a 	and	r18,r18,r17
      wrctl status, r18
2000e178:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
2000e17c:	000e2900 	call	2000e290 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
2000e180:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
2000e184:	d4a03445 	stb	r18,-32559(gp)

      /*
       * start execution of the new task.
       */

      br 9b
2000e188:	003fe506 	br	2000e120 <OSCtxSw+0x40>

2000e18c <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
2000e18c:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
2000e190:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
2000e194:	10800054 	ori	r2,r2,1
      wrctl status, r2
2000e198:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
2000e19c:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
2000e1a0:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
2000e1a4:	dec00204 	addi	sp,sp,8

      callr r2
2000e1a8:	103ee83a 	callr	r2

      nop
2000e1ac:	0001883a 	nop

2000e1b0 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
2000e1b0:	defffb04 	addi	sp,sp,-20
2000e1b4:	dc400115 	stw	r17,4(sp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
2000e1b8:	047fff04 	movi	r17,-4
2000e1bc:	3462703a 	and	r17,r6,r17
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
2000e1c0:	dc000015 	stw	r16,0(sp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
2000e1c4:	8c3ef704 	addi	r16,r17,-1060
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
2000e1c8:	dcc00315 	stw	r19,12(sp)
2000e1cc:	dc800215 	stw	r18,8(sp)
2000e1d0:	2027883a 	mov	r19,r4
2000e1d4:	2825883a 	mov	r18,r5
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));

   _REENT_INIT_PTR (local_impure_ptr);
2000e1d8:	8009883a 	mov	r4,r16
2000e1dc:	000b883a 	mov	r5,zero
2000e1e0:	01810904 	movi	r6,1060
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
2000e1e4:	dfc00415 	stw	ra,16(sp)
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));

   _REENT_INIT_PTR (local_impure_ptr);
2000e1e8:	000e5040 	call	2000e504 <memset>
2000e1ec:	88bfb204 	addi	r2,r17,-312
2000e1f0:	80800115 	stw	r2,4(r16)
2000e1f4:	88bfcc04 	addi	r2,r17,-208
2000e1f8:	80800215 	stw	r2,8(r16)
2000e1fc:	88bfe604 	addi	r2,r17,-104
2000e200:	80800315 	stw	r2,12(r16)
2000e204:	00800034 	movhi	r2,0
2000e208:	10806e04 	addi	r2,r2,440
2000e20c:	80800d15 	stw	r2,52(r16)
2000e210:	00800044 	movi	r2,1
2000e214:	80802915 	stw	r2,164(r16)
2000e218:	008cc384 	movi	r2,13070
2000e21c:	80802b0d 	sth	r2,172(r16)
2000e220:	00aaf344 	movi	r2,-21555
2000e224:	80802b8d 	sth	r2,174(r16)
2000e228:	00848d04 	movi	r2,4660
2000e22c:	80802c0d 	sth	r2,176(r16)
2000e230:	00b99b44 	movi	r2,-6547
2000e234:	80802c8d 	sth	r2,178(r16)
2000e238:	00b7bb04 	movi	r2,-8468
2000e23c:	80802d0d 	sth	r2,180(r16)
2000e240:	00800144 	movi	r2,5
2000e244:	80802d8d 	sth	r2,182(r16)
2000e248:	008002c4 	movi	r2,11
2000e24c:	80802e0d 	sth	r2,184(r16)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
2000e250:	00880074 	movhi	r2,8193
2000e254:	10b86404 	addi	r2,r2,-7792
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
2000e258:	84ffff15 	stw	r19,-4(r16)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
2000e25c:	84bffe15 	stw	r18,-8(r16)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
2000e260:	843ffd15 	stw	r16,-12(r16)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
2000e264:	80bff315 	stw	r2,-52(r16)
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
}
2000e268:	88beea04 	addi	r2,r17,-1112
2000e26c:	dfc00417 	ldw	ra,16(sp)
2000e270:	dcc00317 	ldw	r19,12(sp)
2000e274:	dc800217 	ldw	r18,8(sp)
2000e278:	dc400117 	ldw	r17,4(sp)
2000e27c:	dc000017 	ldw	r16,0(sp)
2000e280:	dec00504 	addi	sp,sp,20
2000e284:	f800283a 	ret

2000e288 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
2000e288:	f800283a 	ret

2000e28c <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
2000e28c:	f800283a 	ret

2000e290 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
2000e290:	f800283a 	ret

2000e294 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
2000e294:	f800283a 	ret

2000e298 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
2000e298:	f800283a 	ret

2000e29c <OSInitHookBegin>:
    cticks_hook();
#endif
}

void OSInitHookBegin(void)
{
2000e29c:	f800283a 	ret

2000e2a0 <OSInitHookEnd>:
    OSTmrCtr = 0;
#endif
}

void OSInitHookEnd(void)
{
2000e2a0:	f800283a 	ret

2000e2a4 <OSTaskIdleHook>:
}

void OSTaskIdleHook(void)
{
2000e2a4:	f800283a 	ret

2000e2a8 <OSTCBInitHook>:
}

void OSTCBInitHook(OS_TCB *ptcb)
{
2000e2a8:	f800283a 	ret

2000e2ac <alt_find_file>:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
2000e2ac:	00800034 	movhi	r2,0
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
2000e2b0:	defffa04 	addi	sp,sp,-24
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
2000e2b4:	10816504 	addi	r2,r2,1428
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
2000e2b8:	dc000015 	stw	r16,0(sp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
2000e2bc:	14000017 	ldw	r16,0(r2)
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
2000e2c0:	dd000415 	stw	r20,16(sp)
2000e2c4:	dcc00315 	stw	r19,12(sp)
2000e2c8:	dc800215 	stw	r18,8(sp)
2000e2cc:	dfc00515 	stw	ra,20(sp)
2000e2d0:	dc400115 	stw	r17,4(sp)
2000e2d4:	2027883a 	mov	r19,r4
2000e2d8:	1025883a 	mov	r18,r2
 
  while (next != (alt_dev*) &alt_fs_list)
  {
    len = strlen(next->name);
    
    if (next->name[len-1] == '/')
2000e2dc:	05000bc4 	movi	r20,47
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
2000e2e0:	84801226 	beq	r16,r18,2000e32c <alt_find_file+0x80>
  {
    len = strlen(next->name);
2000e2e4:	84400217 	ldw	r17,8(r16)
2000e2e8:	8809883a 	mov	r4,r17
2000e2ec:	00084040 	call	20008404 <strlen>
    
    if (next->name[len-1] == '/')
2000e2f0:	8887883a 	add	r3,r17,r2
2000e2f4:	18ffffc7 	ldb	r3,-1(r3)
2000e2f8:	1d00011e 	bne	r3,r20,2000e300 <alt_find_file+0x54>
    {
      len -= 1;
2000e2fc:	10bfffc4 	addi	r2,r2,-1
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
2000e300:	9887883a 	add	r3,r19,r2
2000e304:	18c00007 	ldb	r3,0(r3)
2000e308:	1d000126 	beq	r3,r20,2000e310 <alt_find_file+0x64>
2000e30c:	1800051e 	bne	r3,zero,2000e324 <alt_find_file+0x78>
        !memcmp (next->name, name, len))
2000e310:	8809883a 	mov	r4,r17
2000e314:	980b883a 	mov	r5,r19
2000e318:	100d883a 	mov	r6,r2
2000e31c:	000e4d40 	call	2000e4d4 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
2000e320:	10000426 	beq	r2,zero,2000e334 <alt_find_file+0x88>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
2000e324:	84000017 	ldw	r16,0(r16)
2000e328:	003fed06 	br	2000e2e0 <alt_find_file+0x34>
  }
  
  /* No match found */
  
  return NULL;     
2000e32c:	0005883a 	mov	r2,zero
2000e330:	00000106 	br	2000e338 <alt_find_file+0x8c>
2000e334:	8005883a 	mov	r2,r16
}
2000e338:	dfc00517 	ldw	ra,20(sp)
2000e33c:	dd000417 	ldw	r20,16(sp)
2000e340:	dcc00317 	ldw	r19,12(sp)
2000e344:	dc800217 	ldw	r18,8(sp)
2000e348:	dc400117 	ldw	r17,4(sp)
2000e34c:	dc000017 	ldw	r16,0(sp)
2000e350:	dec00604 	addi	sp,sp,24
2000e354:	f800283a 	ret

2000e358 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
2000e358:	defffc04 	addi	sp,sp,-16
2000e35c:	dc000115 	stw	r16,4(sp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
2000e360:	04000034 	movhi	r16,0
2000e364:	84018704 	addi	r16,r16,1564
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
2000e368:	dc400215 	stw	r17,8(sp)
2000e36c:	2023883a 	mov	r17,r4

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
2000e370:	81000017 	ldw	r4,0(r16)
2000e374:	d80d883a 	mov	r6,sp
2000e378:	000b883a 	mov	r5,zero
2000e37c:	dfc00315 	stw	ra,12(sp)
2000e380:	000bbf40 	call	2000bbf4 <OSSemPend>
2000e384:	01000034 	movhi	r4,0
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
2000e388:	0005883a 	mov	r2,zero
2000e38c:	8007883a 	mov	r3,r16
2000e390:	2100d504 	addi	r4,r4,852
2000e394:	01800804 	movi	r6,32
2000e398:	11400324 	muli	r5,r2,12
2000e39c:	290b883a 	add	r5,r5,r4
  {
    if (!alt_fd_list[i].dev)
2000e3a0:	29c00017 	ldw	r7,0(r5)
2000e3a4:	3800081e 	bne	r7,zero,2000e3c8 <alt_get_fd+0x70>
2000e3a8:	1021883a 	mov	r16,r2
    {
      alt_fd_list[i].dev = dev;
      if (i > alt_max_fd)
2000e3ac:	00800034 	movhi	r2,0
2000e3b0:	10816204 	addi	r2,r2,1416
2000e3b4:	11000017 	ldw	r4,0(r2)

  for (i = 0; i < ALT_MAX_FD; i++)
  {
    if (!alt_fd_list[i].dev)
    {
      alt_fd_list[i].dev = dev;
2000e3b8:	2c400015 	stw	r17,0(r5)
      if (i > alt_max_fd)
2000e3bc:	2400050e 	bge	r4,r16,2000e3d4 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
2000e3c0:	14000015 	stw	r16,0(r2)
      }
      rc = i;
      goto alt_get_fd_exit;
2000e3c4:	00000306 	br	2000e3d4 <alt_get_fd+0x7c>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
2000e3c8:	10800044 	addi	r2,r2,1
2000e3cc:	11bff21e 	bne	r2,r6,2000e398 <alt_get_fd+0x40>
 */

int alt_get_fd (alt_dev* dev)
{
  alt_32 i;
  int rc = -EMFILE;
2000e3d0:	043ffa04 	movi	r16,-24
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
2000e3d4:	19000017 	ldw	r4,0(r3)
2000e3d8:	000be300 	call	2000be30 <OSSemPost>

  return rc;
}
2000e3dc:	8005883a 	mov	r2,r16
2000e3e0:	dfc00317 	ldw	ra,12(sp)
2000e3e4:	dc400217 	ldw	r17,8(sp)
2000e3e8:	dc000117 	ldw	r16,4(sp)
2000e3ec:	dec00404 	addi	sp,sp,16
2000e3f0:	f800283a 	ret

2000e3f4 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
2000e3f4:	00820004 	movi	r2,2048
2000e3f8:	1140012e 	bgeu	r2,r5,2000e400 <alt_icache_flush+0xc>
2000e3fc:	100b883a 	mov	r5,r2
  if (len > NIOS2_ICACHE_SIZE)
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
2000e400:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
2000e404:	2005883a 	mov	r2,r4
2000e408:	1140032e 	bgeu	r2,r5,2000e418 <alt_icache_flush+0x24>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
2000e40c:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
2000e410:	10800804 	addi	r2,r2,32
2000e414:	003ffc06 	br	2000e408 <alt_icache_flush+0x14>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
2000e418:	210007cc 	andi	r4,r4,31
2000e41c:	20000126 	beq	r4,zero,2000e424 <alt_icache_flush+0x30>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
2000e420:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
2000e424:	0000203a 	flushp
2000e428:	f800283a 	ret

2000e42c <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
2000e42c:	213ffe84 	addi	r4,r4,-6
2000e430:	008003c4 	movi	r2,15
2000e434:	11001636 	bltu	r2,r4,2000e490 <alt_exception_cause_generated_bad_addr+0x64>
2000e438:	200890ba 	slli	r4,r4,2
2000e43c:	00880074 	movhi	r2,8193
2000e440:	10b91404 	addi	r2,r2,-7088
2000e444:	2089883a 	add	r4,r4,r2
2000e448:	20800017 	ldw	r2,0(r4)
2000e44c:	1000683a 	jmp	r2
2000e450:	2000e498 	cmpnei	zero,r4,914
2000e454:	2000e498 	cmpnei	zero,r4,914
2000e458:	2000e490 	cmplti	zero,r4,914
2000e45c:	2000e490 	cmplti	zero,r4,914
2000e460:	2000e490 	cmplti	zero,r4,914
2000e464:	2000e498 	cmpnei	zero,r4,914
2000e468:	2000e490 	cmplti	zero,r4,914
2000e46c:	2000e490 	cmplti	zero,r4,914
2000e470:	2000e498 	cmpnei	zero,r4,914
2000e474:	2000e498 	cmpnei	zero,r4,914
2000e478:	2000e490 	cmplti	zero,r4,914
2000e47c:	2000e498 	cmpnei	zero,r4,914
2000e480:	2000e490 	cmplti	zero,r4,914
2000e484:	2000e490 	cmplti	zero,r4,914
2000e488:	2000e490 	cmplti	zero,r4,914
2000e48c:	2000e498 	cmpnei	zero,r4,914
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
2000e490:	0005883a 	mov	r2,zero
2000e494:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
2000e498:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
2000e49c:	f800283a 	ret

2000e4a0 <atexit>:
2000e4a0:	200b883a 	mov	r5,r4
2000e4a4:	000d883a 	mov	r6,zero
2000e4a8:	0009883a 	mov	r4,zero
2000e4ac:	000f883a 	mov	r7,zero
2000e4b0:	000e5241 	jmpi	2000e524 <__register_exitproc>

2000e4b4 <exit>:
2000e4b4:	defffe04 	addi	sp,sp,-8
2000e4b8:	000b883a 	mov	r5,zero
2000e4bc:	dc000015 	stw	r16,0(sp)
2000e4c0:	dfc00115 	stw	ra,4(sp)
2000e4c4:	2021883a 	mov	r16,r4
2000e4c8:	000e6740 	call	2000e674 <__call_exitprocs>
2000e4cc:	8009883a 	mov	r4,r16
2000e4d0:	000e8100 	call	2000e810 <_exit>

2000e4d4 <memcmp>:
2000e4d4:	218d883a 	add	r6,r4,r6
2000e4d8:	21800826 	beq	r4,r6,2000e4fc <memcmp+0x28>
2000e4dc:	20800003 	ldbu	r2,0(r4)
2000e4e0:	28c00003 	ldbu	r3,0(r5)
2000e4e4:	10c00226 	beq	r2,r3,2000e4f0 <memcmp+0x1c>
2000e4e8:	10c5c83a 	sub	r2,r2,r3
2000e4ec:	f800283a 	ret
2000e4f0:	21000044 	addi	r4,r4,1
2000e4f4:	29400044 	addi	r5,r5,1
2000e4f8:	003ff706 	br	2000e4d8 <memcmp+0x4>
2000e4fc:	0005883a 	mov	r2,zero
2000e500:	f800283a 	ret

2000e504 <memset>:
2000e504:	2005883a 	mov	r2,r4
2000e508:	2007883a 	mov	r3,r4
2000e50c:	218d883a 	add	r6,r4,r6
2000e510:	19800326 	beq	r3,r6,2000e520 <memset+0x1c>
2000e514:	19400005 	stb	r5,0(r3)
2000e518:	18c00044 	addi	r3,r3,1
2000e51c:	003ffc06 	br	2000e510 <memset+0xc>
2000e520:	f800283a 	ret

2000e524 <__register_exitproc>:
2000e524:	00800034 	movhi	r2,0
2000e528:	defff904 	addi	sp,sp,-28
2000e52c:	10813f04 	addi	r2,r2,1276
2000e530:	dcc00315 	stw	r19,12(sp)
2000e534:	14c00017 	ldw	r19,0(r2)
2000e538:	dc000015 	stw	r16,0(sp)
2000e53c:	dd400515 	stw	r21,20(sp)
2000e540:	9c000c17 	ldw	r16,48(r19)
2000e544:	dd000415 	stw	r20,16(sp)
2000e548:	dc800215 	stw	r18,8(sp)
2000e54c:	dc400115 	stw	r17,4(sp)
2000e550:	dfc00615 	stw	ra,24(sp)
2000e554:	202b883a 	mov	r21,r4
2000e558:	2823883a 	mov	r17,r5
2000e55c:	3029883a 	mov	r20,r6
2000e560:	3825883a 	mov	r18,r7
2000e564:	8000021e 	bne	r16,zero,2000e570 <__register_exitproc+0x4c>
2000e568:	9c000d04 	addi	r16,r19,52
2000e56c:	9c000c15 	stw	r16,48(r19)
2000e570:	80800117 	ldw	r2,4(r16)
2000e574:	00c007c4 	movi	r3,31
2000e578:	1880100e 	bge	r3,r2,2000e5bc <__register_exitproc+0x98>
2000e57c:	00800034 	movhi	r2,0
2000e580:	10800004 	addi	r2,r2,0
2000e584:	1000021e 	bne	r2,zero,2000e590 <__register_exitproc+0x6c>
2000e588:	00bfffc4 	movi	r2,-1
2000e58c:	00003006 	br	2000e650 <__register_exitproc+0x12c>
2000e590:	01002304 	movi	r4,140
2000e594:	00000000 	call	20000000 <__alt_data_end>
2000e598:	1021883a 	mov	r16,r2
2000e59c:	103ffa26 	beq	r2,zero,2000e588 <__register_exitproc+0x64>
2000e5a0:	10000115 	stw	zero,4(r2)
2000e5a4:	98800c17 	ldw	r2,48(r19)
2000e5a8:	80800015 	stw	r2,0(r16)
2000e5ac:	9c000c15 	stw	r16,48(r19)
2000e5b0:	80002215 	stw	zero,136(r16)
2000e5b4:	a800071e 	bne	r21,zero,2000e5d4 <__register_exitproc+0xb0>
2000e5b8:	00001c06 	br	2000e62c <__register_exitproc+0x108>
2000e5bc:	a8001b26 	beq	r21,zero,2000e62c <__register_exitproc+0x108>
2000e5c0:	80802217 	ldw	r2,136(r16)
2000e5c4:	1000091e 	bne	r2,zero,2000e5ec <__register_exitproc+0xc8>
2000e5c8:	00800034 	movhi	r2,0
2000e5cc:	10800004 	addi	r2,r2,0
2000e5d0:	103fed26 	beq	r2,zero,2000e588 <__register_exitproc+0x64>
2000e5d4:	01004204 	movi	r4,264
2000e5d8:	00000000 	call	20000000 <__alt_data_end>
2000e5dc:	103fea26 	beq	r2,zero,2000e588 <__register_exitproc+0x64>
2000e5e0:	10004015 	stw	zero,256(r2)
2000e5e4:	10004115 	stw	zero,260(r2)
2000e5e8:	80802215 	stw	r2,136(r16)
2000e5ec:	81000117 	ldw	r4,4(r16)
2000e5f0:	01400044 	movi	r5,1
2000e5f4:	2107883a 	add	r3,r4,r4
2000e5f8:	18c7883a 	add	r3,r3,r3
2000e5fc:	10c7883a 	add	r3,r2,r3
2000e600:	1d000015 	stw	r20,0(r3)
2000e604:	290a983a 	sll	r5,r5,r4
2000e608:	11004017 	ldw	r4,256(r2)
2000e60c:	2148b03a 	or	r4,r4,r5
2000e610:	11004015 	stw	r4,256(r2)
2000e614:	1c802015 	stw	r18,128(r3)
2000e618:	00c00084 	movi	r3,2
2000e61c:	a8c0031e 	bne	r21,r3,2000e62c <__register_exitproc+0x108>
2000e620:	10c04117 	ldw	r3,260(r2)
2000e624:	194ab03a 	or	r5,r3,r5
2000e628:	11404115 	stw	r5,260(r2)
2000e62c:	80800117 	ldw	r2,4(r16)
2000e630:	10c00044 	addi	r3,r2,1
2000e634:	10800084 	addi	r2,r2,2
2000e638:	1085883a 	add	r2,r2,r2
2000e63c:	1085883a 	add	r2,r2,r2
2000e640:	80c00115 	stw	r3,4(r16)
2000e644:	80a1883a 	add	r16,r16,r2
2000e648:	84400015 	stw	r17,0(r16)
2000e64c:	0005883a 	mov	r2,zero
2000e650:	dfc00617 	ldw	ra,24(sp)
2000e654:	dd400517 	ldw	r21,20(sp)
2000e658:	dd000417 	ldw	r20,16(sp)
2000e65c:	dcc00317 	ldw	r19,12(sp)
2000e660:	dc800217 	ldw	r18,8(sp)
2000e664:	dc400117 	ldw	r17,4(sp)
2000e668:	dc000017 	ldw	r16,0(sp)
2000e66c:	dec00704 	addi	sp,sp,28
2000e670:	f800283a 	ret

2000e674 <__call_exitprocs>:
2000e674:	00800034 	movhi	r2,0
2000e678:	10813f04 	addi	r2,r2,1276
2000e67c:	10800017 	ldw	r2,0(r2)
2000e680:	defff304 	addi	sp,sp,-52
2000e684:	ddc00a15 	stw	r23,40(sp)
2000e688:	d8800015 	stw	r2,0(sp)
2000e68c:	05c00034 	movhi	r23,0
2000e690:	10800c04 	addi	r2,r2,48
2000e694:	dc800515 	stw	r18,20(sp)
2000e698:	dfc00c15 	stw	ra,48(sp)
2000e69c:	df000b15 	stw	fp,44(sp)
2000e6a0:	dd800915 	stw	r22,36(sp)
2000e6a4:	dd400815 	stw	r21,32(sp)
2000e6a8:	dd000715 	stw	r20,28(sp)
2000e6ac:	dcc00615 	stw	r19,24(sp)
2000e6b0:	dc400415 	stw	r17,16(sp)
2000e6b4:	dc000315 	stw	r16,12(sp)
2000e6b8:	d9000115 	stw	r4,4(sp)
2000e6bc:	2825883a 	mov	r18,r5
2000e6c0:	d8800215 	stw	r2,8(sp)
2000e6c4:	bdc00004 	addi	r23,r23,0
2000e6c8:	d8800017 	ldw	r2,0(sp)
2000e6cc:	dc400217 	ldw	r17,8(sp)
2000e6d0:	14c00c17 	ldw	r19,48(r2)
2000e6d4:	98004226 	beq	r19,zero,2000e7e0 <__call_exitprocs+0x16c>
2000e6d8:	9c000117 	ldw	r16,4(r19)
2000e6dc:	00900034 	movhi	r2,16384
2000e6e0:	10bfffc4 	addi	r2,r2,-1
2000e6e4:	9d002217 	ldw	r20,136(r19)
2000e6e8:	857fffc4 	addi	r21,r16,-1
2000e6ec:	80a1883a 	add	r16,r16,r2
2000e6f0:	8421883a 	add	r16,r16,r16
2000e6f4:	8421883a 	add	r16,r16,r16
2000e6f8:	a42d883a 	add	r22,r20,r16
2000e6fc:	84000204 	addi	r16,r16,8
2000e700:	9c21883a 	add	r16,r19,r16
2000e704:	a8002616 	blt	r21,zero,2000e7a0 <__call_exitprocs+0x12c>
2000e708:	90000326 	beq	r18,zero,2000e718 <__call_exitprocs+0xa4>
2000e70c:	a0002026 	beq	r20,zero,2000e790 <__call_exitprocs+0x11c>
2000e710:	b1002017 	ldw	r4,128(r22)
2000e714:	24801e1e 	bne	r4,r18,2000e790 <__call_exitprocs+0x11c>
2000e718:	99000117 	ldw	r4,4(r19)
2000e71c:	82000017 	ldw	r8,0(r16)
2000e720:	213fffc4 	addi	r4,r4,-1
2000e724:	a900021e 	bne	r21,r4,2000e730 <__call_exitprocs+0xbc>
2000e728:	9d400115 	stw	r21,4(r19)
2000e72c:	00000106 	br	2000e734 <__call_exitprocs+0xc0>
2000e730:	80000015 	stw	zero,0(r16)
2000e734:	40001626 	beq	r8,zero,2000e790 <__call_exitprocs+0x11c>
2000e738:	9f000117 	ldw	fp,4(r19)
2000e73c:	a0000526 	beq	r20,zero,2000e754 <__call_exitprocs+0xe0>
2000e740:	00800044 	movi	r2,1
2000e744:	1552983a 	sll	r9,r2,r21
2000e748:	a1404017 	ldw	r5,256(r20)
2000e74c:	494a703a 	and	r5,r9,r5
2000e750:	2800021e 	bne	r5,zero,2000e75c <__call_exitprocs+0xe8>
2000e754:	403ee83a 	callr	r8
2000e758:	00000906 	br	2000e780 <__call_exitprocs+0x10c>
2000e75c:	a1004117 	ldw	r4,260(r20)
2000e760:	4908703a 	and	r4,r9,r4
2000e764:	2000041e 	bne	r4,zero,2000e778 <__call_exitprocs+0x104>
2000e768:	d9000117 	ldw	r4,4(sp)
2000e76c:	b1400017 	ldw	r5,0(r22)
2000e770:	403ee83a 	callr	r8
2000e774:	00000206 	br	2000e780 <__call_exitprocs+0x10c>
2000e778:	b1000017 	ldw	r4,0(r22)
2000e77c:	403ee83a 	callr	r8
2000e780:	99000117 	ldw	r4,4(r19)
2000e784:	e13fd01e 	bne	fp,r4,2000e6c8 <__call_exitprocs+0x54>
2000e788:	89000017 	ldw	r4,0(r17)
2000e78c:	24ffce1e 	bne	r4,r19,2000e6c8 <__call_exitprocs+0x54>
2000e790:	ad7fffc4 	addi	r21,r21,-1
2000e794:	b5bfff04 	addi	r22,r22,-4
2000e798:	843fff04 	addi	r16,r16,-4
2000e79c:	003fd906 	br	2000e704 <__call_exitprocs+0x90>
2000e7a0:	b8000f26 	beq	r23,zero,2000e7e0 <__call_exitprocs+0x16c>
2000e7a4:	99400117 	ldw	r5,4(r19)
2000e7a8:	99000017 	ldw	r4,0(r19)
2000e7ac:	2800091e 	bne	r5,zero,2000e7d4 <__call_exitprocs+0x160>
2000e7b0:	20000826 	beq	r4,zero,2000e7d4 <__call_exitprocs+0x160>
2000e7b4:	89000015 	stw	r4,0(r17)
2000e7b8:	a0000226 	beq	r20,zero,2000e7c4 <__call_exitprocs+0x150>
2000e7bc:	a009883a 	mov	r4,r20
2000e7c0:	00000000 	call	20000000 <__alt_data_end>
2000e7c4:	9809883a 	mov	r4,r19
2000e7c8:	00000000 	call	20000000 <__alt_data_end>
2000e7cc:	8cc00017 	ldw	r19,0(r17)
2000e7d0:	003fc006 	br	2000e6d4 <__call_exitprocs+0x60>
2000e7d4:	9823883a 	mov	r17,r19
2000e7d8:	2027883a 	mov	r19,r4
2000e7dc:	003fbd06 	br	2000e6d4 <__call_exitprocs+0x60>
2000e7e0:	dfc00c17 	ldw	ra,48(sp)
2000e7e4:	df000b17 	ldw	fp,44(sp)
2000e7e8:	ddc00a17 	ldw	r23,40(sp)
2000e7ec:	dd800917 	ldw	r22,36(sp)
2000e7f0:	dd400817 	ldw	r21,32(sp)
2000e7f4:	dd000717 	ldw	r20,28(sp)
2000e7f8:	dcc00617 	ldw	r19,24(sp)
2000e7fc:	dc800517 	ldw	r18,20(sp)
2000e800:	dc400417 	ldw	r17,16(sp)
2000e804:	dc000317 	ldw	r16,12(sp)
2000e808:	dec00d04 	addi	sp,sp,52
2000e80c:	f800283a 	ret

2000e810 <_exit>:
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
2000e810:	00800034 	movhi	r2,0
2000e814:	10817344 	addi	r2,r2,1485
2000e818:	10000005 	stb	zero,0(r2)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
2000e81c:	20000226 	beq	r4,zero,2000e828 <_exit+0x18>
    ALT_SIM_FAIL();
2000e820:	002af070 	cmpltui	zero,zero,43969
2000e824:	00000106 	br	2000e82c <_exit+0x1c>
  } else {
    ALT_SIM_PASS();
2000e828:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
2000e82c:	003fff06 	br	2000e82c <_exit+0x1c>
